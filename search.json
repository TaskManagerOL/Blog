[{"title":"Dump","url":"/2023/06/06/Dump/","content":"\n  496258dec4991da124968c9b9064201631d6debeb3fc8f7f1718eb628506283ddf0f485404846649fcd1d5f700eafc62198af26c6fdf8f90f460af898b502ebad7cece447a2a7d1048709b88d411f10c6afefd19012e0c50f99a3a048873255f57b9b4e30cf6b2eee3baef35438a0749e23ca124af25ef5c1ae7bc01173ef11c966eb8550524cf6bb35b1fdb43cdcbf6d61422e152185a78efb8e3c8a473f6a624da0661cd248d75d8d5fe7c90a7f30abbaa8d57f0b85c52e8d446b839b16ff7a9e5ca9b5b8920558134151a7c76449bc0bb545a507522e5dfbc753095f58a02a41ce930a6d991803798c21d3658569f958474a296ec8f21565b2d90067cf9e9136401af064efc52196210715a77eaf8c471faade34c6f9e15333609e20948683572294d894cd658c4f9ae159bd006b79c87ac861b0133fd50dcc47bb505be7594096b5d5e86347dc3b111fb296fbf75ec943a66b4c6fe7be3d88f538836ecb59056e8fe64b9869b8b7e0c4a3f829c65f9762aee32cedcd0647192b7e756dc71554582b1c3892c1951b89b3095b39e77e8fd6554f5ff41e1a85c1ef0dd399430ce7c455f86c8c5d8b14e873922dc21c2ee0a2cee495b7f5042f618d587e338c967246221db1de23ab3981185d0fb1ab485355f0376d37bdab11eeb827d79e13ded79835ef738f73b22c93e6490385633b841f05c1edb723f5121a09e948178d638b2de451ff10310243f64d2d78d97adab2b85067443d7d51153d40090088f81ae75480fd6db1afe01b136f04e8e18e039ad9d9bb0ef8ab5a6ae3193e6262aaa03ebf69bb857a62fef0c3c92d3b53ccc69a73150ab704ad681983318a8f728e81aecb959858dbc2764a2f74f4f3e69bf4ac8967e229239a0a72c71ccfd2480475a7ec1f4e347df14bf65f0cc8d153d72cdb185c6d2d1cb8d0fc2a69182a4a164595684b33cf0a8c01ef3b08c953f4e10f9eab2e4aa8b8e5a1dd18fc1a885ce28942e3c90ac6298d924572700e18c3501cf0c51513d2e37d4a1d4218db3612342aacadb6758e1a56cfc6633f09693a523850e269acd4b4826c3daef9da9b6b7fafef156572d54258d610246d0934dee2e23d9c345792b0525b4048391eab985179f9404c8930039ad2e4687934a200966e8c490cf0f420783a4639a71fe5484799967b3096e73d5ab60381b5a6091ea9ffe98e18171450cca06442d71aab68c016d0e2349b2ea8d5c015c989823619c21a03668b7b74526c2f5a6c4ab4f8af9fb3588c47d2c75089d2abf7462bacc3fa1a3f9f801015843fe1f7012f050ea33c70a5da504e77fae9c67d138d30cbab2869bc32cbdb8bc3ec77e9254136626342539631527b4cd425cd42356d1547e27493031055ff468a6a9ffa1ee6990526baceeb0060d780bbe0c74515b93b812e6c8e18a32e6fb54284004ef86fa8fd6b1516f747797046a4e7ac3090b240f478ba437e35f09ba0053e581f71d2f4dda0bc8311f8f28e1cf52f8aa460f171ebb5a55cccf9abc0f72281875911ce8c24a90673c251583510f66530a256017b6d66cef438f64479d154585cdad7e4e4f8f50f3123c99aa933f7abf605339fbb853b166ed1899539820f800e3b2f661dcf29a4e0c0f8b3932dd2e5d68dd40346abe60f40bdac45b97cde05247d33fabd1da3c713db3d19e3bc196de412acf46b2436e3f468efd48c3918c3a9f100f71a9bf895d8800549a3bc3df45f2638c5ee352580fc22ca331acba53f47766c581b8c17d42c403cba89da4dbb6bb471c1df6e3207dbc551da4e07f98a9514ce6a30aefc7593e74f2a79d14cae4ff23c41c3813a35a2f5421c190b161d0226f50da732cf337bbf2a61e53601dc137e0bc28b73c6d48869012efc1443f9f5f71f53b108271eb97067463d792c80af52c83535b3155d4ac6bf71facd51f6f81daba939f58670bd0c06776cad82c8c49c0b8a3a3db003d86152d320ea366cc150e377f7e057c891d103dd9af2d63c6f8e09929d1f79b3342826ee24fa2b290715cada2d4acc8478ec203fbfa8cab74cf7324d019c217ce1479220a5b7ec3ab839cbe4361a15d2afaf9c2463079ced5adb74306aa955cb8cc4bc95be7e2198a2967422021a69828a77dfeaffa006f32f086a93a5e981921855407f39b62da1fd4faffb827c39f84fa555c115156cb81f4e8ec0cefde41b973100f9aef54a5cfa0ac6a02475183e9c209595a5225a056f5df33ab2a6c025138b427f41948676188ea2456c0ea50cc9068b323bfb96da3eb5f43dfbd8610137230f280b6731f167aad4337ebae8420acad61a4cb965cd329bce2231a637f540573f51d14a50d6fccd1a0f3635f9a9776f53ec21afe07460fb9d34b53fd58ae87b287791651ca3163d1365ce65c8ac7769cffa76d6a3fb2f3f438336275e20d6a29047f35dd1175f5f8b84d971efe04c59d63732565f29a6d51d2f377a43872db4cc5f542ce8eec272aa4619a5623ef6042b0ac87e6c651f27c520248270a9b41577de8c21c0127c553d321d943d5fe1e177e6a3d3154bd640cb264464b97bd9a04a1cab529a698ba8c3f84f856105175c7090d7fd05907c5ab540407027630eab785b7f14cf30399309e1b5b4913c41c1b6550576b39fa7b0584482dec71f627503588be311984bc272920051ce144d646b575dcf8c3d1e2c3f67ffb7cdb43e9aefcf662c25b46aca1ff3a04d0fb3b116c1bf7753fa86a4b8da4ee072928f23a9a3440b51e3b011de2dfc0dd220f4a21d4f8c9f2927226c917128d95ad7db0347a9414c32aaa0193c8071f9ba3865326c7f5db3d131b7b6d8e6e634704d9d27ac849ad824f7e5c8ca3da96d1118fd4166cca7bcfa8c39b1cadcb6cdaad5f53618d8eb25dbbf306f4f6282f06398c198c04f4f99e2c56fc52484dda633686b041ae91e7cae58d8cc352f51fb2ffdea36ef82a3b165545ca32b7fe05591af8038382ad14d32c6bd79888fd7c3deca526c4a27e129e1b6324c921c2778caca8d0dc291c086b13fe1394502c29e90e7a73695a0bd9444939eb9efa23cd7289a12142353ca0224f59b7ec84ee25d18b3f83414e65393b8a9c579baf9caad06d71ad28d7eb69960b7753daa082075eddd9616548195fe195c1efbe1e47e00eb3945628cee19a74b808a6610c61cb86fa4a217b9897fd245c30195382232ce6b0d211e56c2c77decef115ba38d07e7f6396c19597d446a97f89e9357b1dbbd6910dbbc71963e230424e69050f7b18406fd57448174d443badebe041d01dea10d4815b467733c68ae3d1ef9a54bd59ce7dc1e4d73f630237226da68fb12b3f9559ed1b91a7b78948cf4fb69835653c532de8a72807514e257420d85132ae892a6aa2355239b0b250f27f7c595702f1ddaead699f17f0e76a59d18140bdaa5c475ffaeae7e7d7e80f7a971e6ca4926643c94c561f51527671a749879747d4b339e1bf6aa00072183c0384348bff3b1d27a74a8e08aebdc163fae5df23f5fb4d6e9b3814f6c02098a4a72a30d35c1797d4b12d17e349b9b0d15ec56da8839a0c9e161821b99188470c0454607594b9bb7d7aedcaa9aece8e969e35e84f86463c6b95190abc4d6fb62ba8ebfe31a0714de63e8f1062615a0cfa4000c716a951b66f37f18177d6c13f950c830672a6e82b87203ca157ba28c5dd3372167d90fe03a2ad19145f8ed1d7fd3dd35b5b13437add9a80f6f81babb87e6fdb724225cc7e7ea3700af2af74cd2d4475a1e73f069057fc9f41787ad1c1ff18c43d5c6f650f265e49154c4d964e0094362dd46837358f08c340\n  \n    \n      \n      \n        右边眼睛字体图标显示时回车插入🔑\n      \n    \n  \n\n","categories":["随笔"],"tags":["😶‍🌫️"]},{"title":"Ajax","url":"/2023/06/24/Ajax/","content":"客户端和服务端服务器：上网过程中，负责存放和对外提供资源的电脑，叫做服务器\n客户端：上网过程中负责获取和消费资源的电脑，叫做客户端\nURL地址的概念URL中文叫统一资源定位符，用于标识互联网上的每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而正确的访问到对应的资源\n地址的组成部分URL地址一般由三部分组成：\n\n客户端与服务器之间的通信协议（协议）\n存有该资源的服务器名称（域名）\n资源在服务器上具体的存放位置（路径）\n\n了解Ajax什么是AjaxAjax的全程是异步 Javascript 和 XML\n通俗的理解是：在网页中利用XMLHttpRequest对象和服务进行数据交互的方式就是Ajax\n为什么要学Ajax之前所学的技术，只能把网页做得更美观。但是Ajax能让我们轻松实现网页与服务器之间的数据交互\nAjax的典型应用场景\n数据分页显示：当点击页码值的时候，通过ajax的形式，根据页码值动态刷新表格的数据\n数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过ajax的形式，来实现数据的交互\n\nJQuery中的Ajax了解JQuery中的Ajax浏览器中提供的XMLHttpRequest用法比较复杂，所以jQuery对XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地降低了Ajax的使用难度\njQuery中发送Ajax请求最常用的三个方法如下：\n\n$.get()\n$.post()\n$.ajax()\n\n$.get()函数的语法jQuery中此函数功能单一，专门用来发起get请求，从而将服务器上的资源请求到客户端来使用。\n语法：$.get(url,{data},[callback])\n\nurl：类型为字符串，必选项，指要请求的资源地址\ndata：类型为对象，非必选项，指请求资源期间要携带的参数\ncallback：类型为函数，非必选项，指请求成功时的回调函数\n\n$.post()函数的语法jQuery中此函数功能单一，专门用来发起post请求，从而向服务器提交数据\n语法：$.post(url,{data},[callback])\n\nurl：类型为字符串，必选项，指要请求的资源地址\ndata：类型为对象，非必选项，指请求资源期间要携带的参数\ncallback：类型为函数，非必选项，指请求成功时的回调函数\n\n$.ajax()函数的语法相比于前两个函数，jQuery中提供的此函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置\n$.ajax()函数的基本语法如下：\n$.ajax({    type:’\t‘,\t\t&#x2F;&#x2F;请求的方式，如 GET or POST    url:’\t‘,\t\t&#x2F;&#x2F;请求的URL地址    data:{\t},\t\t&#x2F;&#x2F;这次请求要携带的数据    success:function(res){\t}\t\t &#x2F;&#x2F;请求成功之后的回调函数})\n接口接口的概念使用Ajax请求数据时，被请求的URL地址，就叫做数据接口，同时每个接口必须有请求方式\n接口文档接口文档的概念接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用\n接口文档的组成部分接口文档可以包含很多信息，一般包含一下内容\n\n接口名称：用于标识各个接口的简单说明\n接口URL：接口的调用地址\n调用方式：接口的调用方式\n参数格式：接口需要传递的参数\n响应格式：接口的返回值的详细描述\n返回示例：举个成功的例子\n\nform表单表单的概念表单在网页中主要负责数据采集。HTML的form就是用于采集用户输入的信息，并通过form标签的提交操作，把采集到的信息提交到服务器端中进行处理。\n表单的组成部分\n表单标签\n表单域\n表单按钮\n\nform标签的属性action\n值：URL地址\n描述：规定当提交表单时，向何处发送表单数据\n\nmethod\n值：get或者post\n描述：规定以何种方法把表单数据提交到action URL\n\ntarget\n_blank:在新窗口中打开\n_self:默认，在相同的框架中打开\n_parent:在父框架集中打开\n_top:在整个窗口中打开\nframename:在指定框架中打开\n\nenctype\napplication&#x2F;x-www-form-urlencoded：默认的编码方式。基于uri的percent-encoding编码的，表单里的数据被编码为名称&#x2F;值对，但是在用文本的传输和MP3等大型文件的时候，使用这种编码就显得 效率低下\nmultipart&#x2F;form-data：指定传输数据为二进制类型，比如图片、mp3、文件。 这个一般文件上传时用。它告诉我们传输的数据要用到多媒体传输协议，由于多媒体传输的都是大量的数据，所以规定上传文件必须是post方法，type&#x3D;”file”，浏览器会把整个表单以控件为单位分割。并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text&#x2F;plain),name(控件name)等信息，并加上分割符(boundary)。\ntext&#x2F;plain：纯文体的传输。空格转换为 “+” 加号，但不对特殊字符编码。\n\n表单的缺点如果使用表单提交数据，则会导致页面之前的状态和数据丢失\n解决方案是：表单只负责采集数据，Ajax负责将数据提交到服务器\n快速获取表单中的数据\nserialize函数\n\n模板引擎基本概念可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面\n好处\n减少了字符串的拼接操作\n使代码结构更加清晰\n使代码更易于阅读和维护\n\nart-template模板引擎\n导入art-template\n只要导入模板引擎，在window全局多一个函数，叫做template(‘模板的id’,需要渲染的数据对象)\n\n\n定义数据\n定义模板\n例如script type&#x3D;”text&#x2F;html”  这样就可以在script里面写html且不报错\n在双括号里面写你调用数据的名字\n\n\n调用template函数\n渲染HTML\n再用你要放html的box渲染，element.html()即可\n\n\n\nart-template标准语法p30\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"ES6","url":"/2023/06/24/ES6/","content":"ES 是脚本语言的规范，而平时经常编写的 JS 是 ES 的一种体现，所以 ES 的新特性其实指的就是 JS 的新特性\nlet相当于局部变量\nconst常量，不可修改\n解构赋值可以用 let [ …… ] &#x3D; 数组名、let { ……. } &#x3D; 对象名 ，这样的方式来快速取值\n模板字符串通常情况下你str是没办法换行的，想要换行的话就要用”” + 这样 但是 ES6 中给到了&#96;&#96;反引号 在反引号中可以随便换行 :laughing:\n对象的简便写法如果对象的名字和值一样 就可以直接写一个\n还有就是对象函数 可以省略function 直接写 名字(){} 这样\n箭头函数函数声明 变成了\n\nlet fn &#x3D; (a,b) &#x3D;&gt; {    return a+b;} \n\n这样 省略了function\n\nthis 是静态的 this 始终指向函数声明时所在作用域下的 this 的值\n\n不能作为构造函数实名化对象\n\n不能使用 arguments 变量\n\n当形参只有一个的时候可以省略小括号，当代码体只有一个的时候可以省略花括号\n\n\n函数参数的默认值设置在小括号里可以直接等于\n\nadd &#x3D; (c&#x3D;1) &#x3D;&gt;    return c;\n结果是1 \n\n与结构赋值结合\n\nconnect &#x3D; (username,password)  &#x3D;&gt; {    console.log(username)}connect({    username:”111”    password:”222”})\n\n可以这样使用\nrest参数ES6引用 rest 参数，用于获取函数的实参，用来代替 arguments \n用法如下\n\nfn &#x3D; (a,b,…args){    输出…}fn(传值)\n\n值得一提的是 rest 函数必须要放到参数最后\n扩展运算符… 运算符可以把数组转化为逗号分割的参数序列\nsymbolsymbol是一种类似于字符串的数据类型\n迭代器 interator一个用于快速遍历数组的 新属性next()会迭代调用数组元素，每次迭代一个，直到用完\n\nconst num &#x3D; [1,2,3,4];let it &#x3D; num[Symbol.interator] ();&#x2F;&#x2F;调用必须console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());&#x2F;&#x2F; 这样就会快速生成四个对象 value 会遍历 对象中还有一个 done 值 如果被遍历完了 done 就会变成true\n\n生成器其实就是一个特殊的函数，异步编程 纯回调函数\n\nfunction * gen(){    part1;    yield ‘sign1’;    part2;    yield ‘sign2’;    part3;}\nlet it &#x3D; gen();it.next();it.next();it.next();\n\n这样的话会逐渐执行part1，然后part2，然后part3\n甚至可以用 yield 来传参，这里截取片段来展示\n\nlet one &#x3D; yield 111;console.log(one);\n…\nit.next(‘AAA’) &#x2F;&#x2F;这样就会输出AAA\n\nPromise (比较重要 面试常问)Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果\n使用Promise方案主要有以下好处\n\n可以很好的解决回调地狱的问题（避免了层层嵌套的回调函数\n语法非常简洁。promise对象提供了简洁的API 使得控制异步操作更加容易\n\n&#x3D;&#x3D;简单学学 如果想要了解还可以再看&#x3D;&#x3D;\nSetES6提供了新的数据结构 Set (集合)。类似于数组，但是成员的值都是唯一的，集合实现了 iterator 接口 所以可以使用扩展运算符和for of进行遍历\n会自动去重 类似数学中的集合 \n.size是个数 .add增加 .delete删除 .has检测 .clear清空\nMapES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了 iterator 接口，所以可以使用 扩展运算符 和 for  of 进行遍历\nclassES6 提供了更接近传统语言的写法，引入了 Class 这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上 ES6 的 class 可以看作 只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更面向对象编程的语法而已。\n对象方法扩展\nObject.assign(a,b) 对象的合并该方法可以使两个对象合并 由后面的覆盖前面的 \n\nObject.setPrototypeOf 设置原型对象 可以放到_proto_中去\n\n\n模块化模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小的文件组合起来\n模块化的优势有以下几点：\n\n防止命名冲突\n代码复用\n高维护性\n\nES6模块化语法模块化语法主要由两个命令构成：export 和 import\n\nexport 命令用于规范模块的对外接口\n\nlet name = &quot;name&quot;;let teach = () =&gt; &#123;\tconsole.log(name);&#125;export &#123;name,teach&#125;;\n\nexport default &#123;\tname:&quot;name&quot;;    teach:function()&#123;\tconsole.log(name);\t&#125;&#125;\n\n\n\n\nimport 命令用于输入其他模块提供的功能\n\nimport &#123;name,teach&#125; from &quot;url&quot;\n\n&#x3D;&#x3D;ES7~ES11没学&#x3D;&#x3D;\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"Git","url":"/2023/06/24/Git/","content":"[TOC]\n工作图\n\n初始化（工作区）\n使用 git init 初始化\n新建 .gitignore文件来忽略不上传的文件\n也可以在github上初始化之后，git clone  \n\n\n缓存区\ngit add \n\n如果你想上传所有文件  \nsetting   to .\n如果你想让你上传的文件有着相同的后缀\nsetting  to *.(suffix)\n\n提交区（本地git库&#x2F;版本库）\ngit commit \n\n-m  “该次提交的提交信息”\n\n远程仓库\ngit remote \n\n-v 显示所有仓库\nshow [remote]显示远程仓库信息\nadd [origin(shortname) [url]] 添加远程版本库，shortname为远程库名字（一般默认origin），url为远程仓库地址\nrm name 删除远程仓库\nrename old_name new_name 修改仓库名\n\n在使用远程仓库之前建议配置一个ssh连接 教程 – 菜鸟教程 \n\n\n分支\n分支系统是版本控制系统中最为重要的部分，使用其意味着你可以从开发主线当中分出来一条支线，从而在不影响主线开发的同时继续开发\n\n创建分支命令（无分支名时，命令效果为查看当前的本地分支）\n\ngit branch （branch_name）\n\n切换分支命令\n\ngit checkout  -(参数)（branch_name）\n\n -b 创建新分支的同时进入分支\n-d 删除该分支\n\ngit merge\n\n合并分支至当前分支命令\n\n提交 拉取\ngit push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;\n\n提交操作 提交本地的git库 中的本地分支至远程分支 \n当然，一般来说本地分支和远程分支名字相同，所以可以省略冒号及其后面的部分\n若本地和远程版本有差异，则可以使用–force进行强制推送（或者-f）\n第一次上传可以使用-u以设置默认值之后就可以使用不带任何参数的git push了\n\ngit pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n\n将远程主机 的 远程分支拉过来与本地的分支合并\n若远程分支是和当前分支合并，则可以省略冒号后面的部分\n\n撤销 删除\ngit restore \n\n单使用该命令会将工作区更改了且未上传缓存区的文件撤销更改\n–staged 将上传缓存区的对应文件撤出，且不会撤销工作区文件的更改\n\ngit rm \n\n单使用该命令会将工作区的对应文件删除\n–cached 将缓存区中的对应文件删除\n -r 用于遍历删除文件夹及其下的子文件夹 \n -f 用于删除文件夹\n\ngit reset \n\n用于回退你上传到提交区(本地git库)的操作\n–soft &lt;提交信息&#x2F;版本号&gt;\n只撤销该次git commit，并将文件回退到git add中\n–mixed &lt;提交信息&#x2F;版本号&gt;\n撤销git commit和git add\n–hard &lt;提交信息&#x2F;版本号&gt;\n将一切返回到上次git commit提交时的状态，包括工作区文件\n\n查看\ngit status\n\n查看当前的git状态\n\ngit log\n\n查看提交区的历史提交信息\n–oneline 使得提交信息较为简单紧凑\n-nx 其中x为查看日志的数量\n\npull request\nfork你需要修改的仓库\ngit clone将仓库置于本地\n根据issue或者自身需求来修改代码\ngit add 将修改后的代码add置于缓存区\n\ngit commit -m “update introduction”确认上传文件无误的前提下将代码commit至提交区\ngit push  将提交区的代码push至远程fork仓库\n在远程自己的fork仓库提出pr\n等待仓库所有者通过pr\n\n\nfork &amp; local仓库更新\n\n在自己的fork库中Fetch and merge将他人的fork库更新至自己的fork库\ncd进自己的工作区\ngit fetch -all将自己fork库的修改更新到自己的本地git库\ngit status查看自己工作区状态\ngit pull拉取自己fork库的更改到本地\n将自己的修改置于工作区\ngit status查看自己的工作区状态\n\n\n","categories":["工具使用"],"tags":["迁移","工具"]},{"title":"HTML","url":"/2023/06/24/HTML/","content":"标签\n单标签\n双标签\n\n文字样式变形\nstrong 加粗\nem 倾斜\ndel 删除线\nins 下划线\np&gt; 换行\n\n插入图片\nimg src=&quot;链接&quot; alt=&quot;若显示失败输入的字符&quot; width=&quot;左右大小&quot; height=&quot;高低&quot;  title=&quot;鼠标放在图片上显示的字&quot;/&gt;\t(src必须)\n\n\n\n路径\n相对路径\n下一条路径\timg src&#x3D;”本路径中含有图片的文件夹&#x2F;图片名称（包含后缀）”&#x2F;&gt;\n上一条路径\timg src&#x3D;”..&#x2F;图片名称（包含后缀）”&#x2F;&gt;\n\n\n绝对路径\n此电脑中的文件\timg src&#x3D;”C.........\\图片名称（包含后缀）”&gt;\t(注意相对和绝对的斜杠不一样)\n完整的网络地址\timg src&#x3D;”直接将网址输入”&#x2F;&gt;\n\n链接标签\n\n\n链接类型\n说明\n标签\n\n\n\n外部链接\ntarget中为下划线self就是关本界面开新界面，下划线blank就是直接开一个新界面\na href&#x3D;”直接将网址输入” target&#x3D;”…”&gt;显示出的字符\n\n\n内部链接\n即自己多个网页之间转跳的链接\na href&#x3D;”直接输入html的名字（加后缀”&gt;显示出的字符\n\n\n空链接\n常用于页面尚未完善时的框架\na href&#x3D;”#”&gt;显示出的字符\n\n\n下载链接\n当href指向一个zip或exe文件时，点击链接会直接下载\n\n\n\n网页元素链接\n文本、表格、音频、视频都能进行超链接\na href&#x3D;”…”&gt; img src&#x3D;”…”&#x2F;&gt;\n\n\n锚点链接\n可以直接转跳到页面内上下文 首先要对跳的地方进行设置 然后进行设置超链接\nh1 id&#x3D;”…”&gt;显示出的字符 a href&#x3D;”#…”&gt;\t显示出的字符\n\n\n注释\nctrl+&#x2F;\n!–输入想要输入的注释–&gt;\n\n\n\n\n\n特殊字符\n描述\n字符的代码(前面都加&amp;)\n\n\n\n\n空格\nnbsp;\n\n\n&lt;\n小于号\nlt;\n\n\n&gt;\n大于号\ngt;\n\n\n&amp;\n和号\namp;\n\n\n￥\n人民币号\nyen;\n\n\n©\n版权\ncopy;\n\n\n\n注册商标\nreg;\n\n\n°\n摄氏度\ndeg;\n\n\n+-\n正负号\nplusmn;\n\n\n×\n乘号\ntimes;\n\n\n➗\n除号\ndivide;\n\n\n^2^\n二次方\nsup2;\n\n\n^3^\n三次方\nsup3;\n\n\n表格标签\n表格的基本语法 \n\ntable&gt;是用于定义表格的标签。\ntr&gt;标签用于定义表格中的行，必须嵌套在table标签中。\ntd&gt;标签用于定义表格中的单元格，必须嵌套在tr标签中。\nth&gt;标签用于制作表头，必须嵌套在tr标签中。\nthead&gt;标签用于制作表头区域，必须嵌套在table标签中。\ntbody&gt;用于制作表格主体部分，必须嵌套在table标签中。\n\n\n表格属性（都要写到table标签中，CSS还会学，小小掌握即可）\n\nalign&#x3D;”…”表示表格与文字的对齐方式\nborder&#x3D;”…”表示边框厚度\ncellpadding&#x3D;”…” 规定文字与表格之间的空白，默认为一像素\ncellspacing&#x3D;”…”规定单元格之间的空隙，默认为2像素\nwidth、height&#x3D;”…” 规定单元格的宽度、高度\n\n\n合并单元格（必须在第一行和第一列添加标签 且记得删除多余的单元格，必须用于td标签中）\n\nrowspan&#x3D;”要合并的行”\n\ncolspan&#x3D;”要合并的列”\n\n\n\n\n列表标签\n无序列表（重点）–&gt;整齐简单不要求顺序用无需列表\nul&gt;表示无序列表，一般以项目符号呈现列表项（ul标签中只能存放li标签）\nli&gt;定义列表项 可以存放任何元素 相当于一个容器\n\n\n有序列表\nol&gt;表示有序列表 同样使用li标签\n\n\n自定义列表（重点）–&gt;当有很多小分支对一个大分支进行说明时使用自定义列表\ndl&gt;用于描述自定义列表（dl标签中只能存在dt和dd标签）\ndt&gt;用于描述名词\ndd&gt;用于对名词进行解释\n\n\n\n表单标签表单域\nform action&#x3D;”url地址” method&#x3D;”提交方式” name&#x3D;”表单域名称”&gt;\naction属性用于指定接收并处理表单数据的服务器程序的url地址 还没学完后面会扩展\nmethod属性用于设置表单数据的提交方式，其取值为get或post\nname属性用于指定表单的名称，以区分同一个页面中的多个表单域\n\n\n\n表单控件（表单元素）\ninput type&#x3D;”属性值” name&#x3D;”名称” value&#x3D;”用户自定义” checked&#x3D;”checked” maxlength&#x3D;”一个正整数”&gt;输入表单元素\n\ntype的属性值：\n\n\n\n属性值\n作用\n\n\n\nbutton\n定义可点击按钮（多数情况下用于通过javascript启动脚本）\n\n\ncheckbox\n定义复选框（与radio相对）\n\n\nfile\n定义输入字段和浏览按钮，供文件上传\n\n\nhidden\n定义隐藏的输入字段\n\n\nimage\n定义图像形式的提交按钮\n\n\npassword\n定义密码字段，该字段中的字符被掩码\n\n\nradio\n定义单选按钮（与checkbox相对，多选一必须有相同name）\n\n\nreset\n定义重置按钮，重置按钮会清除表单中的所有数据\n\n\nsubmit\n定义提交按钮，提交按钮会把表单数据发送到服务器\n\n\ntext\n定义单行的输入字段，用户可在其中输入文本，默认宽度为20个字符\n\n\n\nname属性：定义input元素的名称\n\nvalue属性：规定input元素的值\n\nchecked属性：规定此input元素首次加载时应当被选中 （用于单选和多选按钮 页面一打开就被选中就加这个属性）\n\nmaxlength属性：规定输入字段中的字符的最大长度\n\n\n\nlabel for&#x3D;”名称”&gt;要点击的字符或图片标签：用于绑定一个表单元素，当点击label标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，增加用户体验。\n\nid属性：与label标签搭配使用 放在input里面\n\n\nselect&gt;下拉表单元素用于多个选项选一个简洁页面 \n\noption&gt;选项只能嵌套在select元素中 （在option标签中定义selected&#x3D;”selected”，当前项为默认选项）\n\n\ntextarea&gt;文本域元素用于键入大量内容时\n\n\n提示信息\n记得添加增加用户体验的提示信息\n\nemmet语法\n标签*n+tab可以快速生成n个标签\n父子级关系输入标签一&gt;标签二+tab可以快速生成父子级标签\n兄弟级关系输入标签1+标签二+tab可以快速生成兄弟级标签\n输入标签.类名可以快速生成有类名的标签（类名后面加$*n可以生成很多不同的类名）\n\nHTML5新特性新特性虽然强大 但是都有兼容问题 基本是IE9+以上的版本才支持，如果不考虑兼容性问题，可以大量使用这些新特性\nHTML5新增的语义化标签参见CSS规范使用标签 打*的是语义化\nHTML5新增的多媒体文件视频\n尽量放mp4文件\n\n样式为video src&#x3D;””是一个双标签\n\n常见属性为autoplay（自动播放）&#x2F;controls（播放控件显示）&#x2F;width&#x2F;height&#x2F;loop（循环播放）&#x2F;preload（是否预加载 属性值为auto&#x2F;none）&#x2F;src&#x2F;poster（等待加载的画面图片）&#x2F;muted（静音播放）\n\n\n音频\n尽量放mp3文件\n样式基本同视频 属性只有autoplay&#x2F;controls&#x2F;loop&#x2F;src\n\nHTML新增的表单类型\ninput type后面的属性值增加了很多 例如email&#x2F;url&#x2F;date&#x2F;time&#x2F;month&#x2F;week&#x2F;number&#x2F;tel&#x2F;search&#x2F;color\n\n新增了很多表单属性 \n\nrequired:required；表示该表单不能为空  \nplaceholder:提示文本； 表示表单的提示信息  \nautofocus:autofocus;自动聚焦\nautocomplete:on&#x2F;off; 当用户在字段开始键入时，浏览器基于之前键入过的值，显示出字段中填写的选项\nmutiple:mutiple; 可以多选文件提交\n\n\n\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"CSS","url":"/2023/06/24/CSS/","content":"CSS参考手册：Ctrl+单击\nCSS规范\nCSS规则由两个主要的部分构成：选择器及一条或多条声明。\n属性和属性值以”键值对“的形式出现。\n属性和属性值之间用英文冒号来分割。\n多个”键值对“之间用英文分号进行区分。\n\nCSS代码风格\n展开风格书写代码。\n使用小写字母书写。\n空格规范：\n属性值前，冒号后面，保留一个空格。\n选择器和大括号之间保留一个空格。\n\n\n\nCSS选择器\n作用是选择标签\n\nCSS做两件事\n\n选对人（选择标签）\n做对事（更改标签样式）\n\n\n\n标签选择器\n是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定。\n\n（类名 {属性: 属性值;…} ）\n\n优点：快速将页面中同类型的标签统一设置样式。\n\n缺点：不能设计差异化样式，只能选择全部的当前标签。\n\n\n类选择器\n如果想要差异化选择不同的标签，单独选择一个或者某几个标签，可以使用类选择器。\n\n（.类名 {属性: 属性值;…} 在要改的标签使用class&#x3D;”…”） class键入类名可以使用多类名格式为class&#x3D;”类名1 类名2”（作用于交叉编辑）\n\n最常使用。\n\n不能使用标签名作为类选择器的类名，可以使用中横线命名，不要使用纯数字、中文进行命名。\n\n命名要有意义。\n\n\n\n类名\n命名\n\n\n\n头\nheader*\n\n\n内容\ncontent&#x2F;container（article*）\n\n\n尾\nfooter*\n\n\n导航\nnav*\n\n\n侧栏\nsidebar（aside*）\n\n\n定义文档某个区域\n（section*）\n\n\n栏目\ncolumn\n\n\n页面外围控制整体布局宽度\nwrapper\n\n\n左右中\nleft right center\n\n\n登录条\nloginbar\n\n\n标志\nlogo\n\n\n广告\nbanner\n\n\n页面主体\nmain\n\n\n热点\nhot\n\n\n新闻\nnews\n\n\n下载\ndownload\n\n\n子导航\nsubnav\n\n\n菜单\nmenu\n\n\n子菜单\nsubmenu\n\n\n搜索\nsearch\n\n\n友情链接\nfriendlink\n\n\n页脚\nfooter*\n\n\n版权\ncopyright\n\n\n滚动\nscroll\n\n\n内容\ncontent\n\n\n标签页\ntab\n\n\n文章列表\nlist\n\n\n提示信息\nmsg\n\n\n小技巧\ntips\n\n\n栏目标题\ntitle\n\n\n加入\njoinus\n\n\n指南\nguild\n\n\n服务\nservice\n\n\n注册\nregsiter\n\n\n状态\nstatus\n\n\n投票\nvote\n\n\n合作伙伴\npartner\n\n\n\n\nid选择器\n（#类名{属性：属性值；}）\n\n只能调用一次，如果有调用一次后，别的标签不允许再次使用。（后期于js结合使用）\n\n\n通配符选择器\n（*{属性：属性值；}）\n对网页中所有的标签进行修改。\n\n后代选择器\n同类选择器只不过在要选的深一层和第一层之间加了空格\n\n子元素选择器\n只选择某标签中的 一个子标签 样式为父标签&gt;子标签{… …}\n\n伪类选择器\n可以作用于链接、表单的特殊选择器\n\n样式为:link&#x2F;visited&#x2F;active&#x2F;hover&#x2F;focus{… …}\n\nlink为未被访问过的元素\nvisited为已经被访问过的元素\nactive表示鼠标按下但未弹起的元素\nhover表示鼠标悬停的元素\nfocus表示鼠标选定的元素（焦点）\n\n\n\n常见属性\nCtrl+单击\n\n字体属性：font的复合属性：将标签中的字体进行很多次变换可能很不方便，可以使用符合属性，格式为font: font-style font-weight font-size&#x2F;line-height font-family; 如此书写可以一行代码解决样式 粗细 大小 字体的四种属性。 （但是必须要有字号和字 体否则不起效果）\n\n文本属性：  \n\n文本的颜色color：可以通过预定颜色值、十六进制、RGB代码进行修改。\n对齐文本text-align：属性值为left、right、center\n装饰文本text-decoration：可以给文本加下划线上划线删除线，属性值有none、underline、overline、line-through\n文本缩进text-indent：输入像素可以缩进距离 （可以输入负值）单位不只是px 还有em（相当于当前字体大小的一个字体的距离）\n行间距line-height用于设置行间的距离（行高）设置的距离包括文字距离，是一整行的高低（&#x3D;&#x3D;让文字垂直居中方法：让行间距等于盒子高度&#x3D;&#x3D;）\n\n\n\nCSS引入方式行内样式表（行内式）\n在某个标签内写入style，优先级非常高\n\n内部样式表（嵌入式）\n放在head的style 练习时使用的方式\n\n外部样式表（链接式）\n单独写一个CSS文件，再将此文件引入到HTML中。（使用方法为建一个CSS的文件，直接在里面写样式，但要在引用的HTML文件中加入link标签） \n专业\n\nemmet语法\n采取简写形式：如w200+tab可以生成width:200px;\n\n元素显示模式块元素\n常见的块元素有h1~h6、p、div、ul、ol、li等（li前原点去除：list-style:none;)\n\n独占一行\n\n宽度、高度、外边距、内边距都控制\n\n默认宽度是父级容器的100%\n\n是一个容器及盒子，里面可以放行内或块级元素\n\n\n行内元素（内联元素）\n常见的行内元素有a、strong、b、em、i、del、s、ins、u、span等\n\n相邻行内元素在一行上，一行可以显示多个\n\n高宽的设置是无效的\n\n默认宽度就是它本身内容的宽度\n\n行内元素只能容纳文本或其他行内元素\n\n链接里不能再放链接，特殊情况链接可以放块级元素\n\n\n行内块元素\n常见的行内块元素有img&#x2F;、input&#x2F;、td他们同时具有块元素和行内元素的特点\n\n和相邻行内元素在一行上，但是他们之间会有空白间隙。一行可以显示多个（行内元素特点）\n\n默认宽度就是它本身内容的宽度（行内元素特点）\n\n行高、高度、外边距和内边距都可以控制（块级元素特点）\n\n\n元素显示模式的转化\n想转化什么就在style里面加入display:block&#x2F;inline&#x2F;inline-block;\n\nCSS的背景背景颜色及半透明\n样式为 background-color:颜色;(颜色不写默认是transparent 透明的)；\n想实现半透明只需在rgb颜色后加个a表示透明度即可 如rgba（0，0，0，0.5）即为半透明的黑色\n\n背景图片\n样式为 background-image:url(…);\n\n背景平铺\n样式为 background-repeat:……;\n属性值为no-repeat为取消平铺；属性值为repeat-x为横向铺一行，属性值为repeat-y为竖向铺一列；\n\n背景图片位置\n样式为 background-position:… …;\n前一个为x轴，后一个为y轴。可使用center这种方位名词，也可使用精确的位置，甚至可以混合。\n\n背景固定\n可以用于制作视差滚动效果\n\n样式为 background-attachment:scroll&#x2F;fixed;(默认滚动)\n\nscroll为滚动\nfixed为固定\n\n\n\n复合写法\nbackground:………………;\n\nCSS的三大特性层叠性\n相同选择器给设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。\n\n样式冲突，遵循的是就近原则，哪个样式离结构近，就执行哪个样式。\n\n样式不冲突，不层叠。\n\n\n继承性\n子标签会继承父标签中的某些样式。（恰当使用可以降低CSS的复杂性）\n\n通常继承：text font line color这些属性\n\n特殊继承：font: 12px&#x2F;24px;表示行高为24px，但可以写成font:12px&#x2F;1.5;表示行高为当前字体的1.5倍，子代继承同样适用1.5倍。\n\n\n优先级\n当同一个元素指定多个选择器，就会有优先级的产生\n\n选择器相同，则执行层叠性\n\n优先级为：！important&gt;行内样式（直接在标签里面写style）&gt;id&gt;类&gt;伪类&#x3D;标签&#x3D;属性选择&gt;继承&gt;通配符；\n\n复合选择器有权重叠加的问题，如子元素选择器就会相当于两个标签选择器的叠加。\n\n\n网页布局网页布局的本质：利用CSS摆盒子\n\n先准备好相应的网页元素，网页元素基本都是盒子box\n\n利用CSS设置好盒子样式，然后摆放到相应位置\n\n往盒子里转内容\n\n\n常见网页布局+ \n盒子模型\n所谓盒子模型：就是将HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器\n\nCSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容\n\n盒子模型的组成 每个元素都可以只设置上下左右 在元素后加-top&#x2F;bottom&#x2F;left&#x2F;right即可\n\nborder边框 可以使用复合写法 边框会影响盒子实际大小 测量要减去边框宽度\n\nborder-width设置边框粗细\nborder-style设置边框样式 solid实线边框 dashed虚线边框 dotted点线边框  outset3D边框\nborder-color设置边框颜色\nborder-collapse用于合并相邻的边框\n\n\ncontent内容\n\npadding内边距（内边距影响盒子的大小，当有宽度和高度属性时使用padding会撑大盒子，解决方法用宽度、高度减去padding*2 ）（当高、宽未指定时padding不再影响）  \n\n改变盒子边框和盒子内容距离\n可单写也可上下左右一起\n值个数为1一圈，值个数为2上下 左右，值个数为3上 左右 下，值个数为4顺时针\n\n\nmargin外边距\n\n改变盒子与盒子之间的距离\n\n输入方式和padding基本一样 \n\n常见应用：块级盒子居中对齐 条件：有宽度、左右外边距写为auto；行内、行内块元素水平居中给其父级元素添加text-align:center;即可。\n\n嵌套块元素塌陷：父元素和子元素的外边距会合并 解决方案：为父元素添加overflow:hidden或定义上内边距或定义上边框\n\n\n\n\n\nCSS第一行代码就是清除内外边距即*{padding:0;margin:0;}且行内元素尽量只设置左右边距（因为上下不起作用）。\n\n\n圆角边框\n样式：border-radius:…;\n\nradius意为半径后面输入的值越大盒子越圆；\n\n可以输入4个值表示四个角\n\n\n盒子阴影\n样式为 box-shadow:…; 盒子的阴影不占空间。\n\nh-shadow 表示水平位置的阴影\n\nv-shadow 表示竖直方向的阴影\n\nblur 表示阴影的模糊距离\n\nspread 表示阴影的尺寸\n\ncolor 表示阴影的颜色\n\ninset 改为内部阴影\n\n\n文字阴影\n样式为 text-shadow:…;\n属性值为盒子阴影的前三个和color\n\n浮动\n页面由标准流（普通流&#x2F;文档流）、浮动、定位构成。\n为什么需要浮动？1.将多个块级盒子在一行显示且不留空隙。2.实现两个盒子的左右对其。\n网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。\n样式为 float:属性值; 属性值可以为left和right和none float是用于创建浮动框的，将其移动到一边，直到左边缘或右边缘触及块或者另一个浮动框的边缘。\n浮动元素经常和标准流父级搭配使用 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置\n\n浮动特性\n浮动的元素会脱离标准流\n\n脱离标准普通流的控制（浮）移动到指定位置（动）（俗称脱标）\n浮动的盒子不再保留原先的位置\n\n\n浮动的元素会一行内显示并且元素顶部对齐\n\n当父级元素装不下时，多出的盒子会另起一行。\n\n\n浮动的元素会具有行内块元素的特性\n\n任何种类的元素都可以加浮动，但是加了浮动之后就会变成行内块元素。\n如果块级元素没有设置宽度，默认宽度是和父级一样宽，但是添加浮动后，它的大小根据内容决定。\n\n\n\n浮动布局的注意点\n通常是规定父级元素是标准流，然后子元素再规定为浮动。\n\n&#x3D;&#x3D;理论上一个元素浮动了，其他兄弟元素也需要浮动。&#x3D;&#x3D;\n\n浮动的盒子只会影响后面的标准流\n\n\n清除浮动\n由于父级盒子很多情况下不方便给高度，但是盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子\n由于浮动元素不再占有原文档流的位置，所以它会对后面的元素排版产生影响\n样式 选择器{clear:left&#x2F;right&#x2F;both;}\n清除浮动方法\n额外标签法（隔墙法 不常用）：在需要清除浮动的最后一个元素后写一个盒子（必须是块级元素  div最好），加上clear both。\n父级添加overflow：可以给父级元素添加overflow属性，将其属性值设置为hidden、auto、或scroll。hidden可以清除浮动。\nafter伪元素法：在父元素后面插入一个新盒子。\n双伪元素清除浮动：在新盒子的内部前面后面都插入一个盒子。\n\n\n\nps切图常见的图片格式\njpg图片格式：jpg对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的\ngif图像格式：GIF格式最多只能存储256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果，实际通常用于一些图片动画效果。\npng图像格式：是一种新兴的网络图形格式，结合了jpg和gif的特点，能够保持透明背景，如果想要切成透明背景的图片，就选用png格式的图像。\nPSD图像格式：是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计稿，对前端人员来说最大的优点就是可以直接从上面复制文字、测量距离和大小。\n\n常见的切图方式\n图层切图： 选中图层右键快速导出为PNG\n\n定位定位的应用用于使盒子自由的在某个盒子内移动位置或者固定屏幕中的某个位置，并且可以压住盒子。\n定位的组成\n定位模式 属性为position\nstatic为静态定位 相当于无定位 按照标准流摆放 通常不使用\n&#x3D;&#x3D;relative为相对定位&#x3D;&#x3D; 相对于自己原来的位置进行移动 只与自己原来的位置有关系 且原来在标准流的位置继续占有（人飞了，但是后面的人还给他留空）用于限制绝对定位（父相子绝）\n&#x3D;&#x3D;absolute为绝对定位&#x3D;&#x3D; 要看祖先元素 \n若无祖先 以浏览器界面对齐 \n若祖先元素有定位 以最近一级的有定位祖先元素对齐\n绝对定位的位置不再进行保留\n\n\n&#x3D;&#x3D;fixed为固定定位&#x3D;&#x3D; 固定住盒子 即使滑动页面也不会改变盒子  以可视窗口的距离来移动位置\n让固定的盒子以版心对其：先让固定的盒子left50%，然后margin版心宽度的一半\n\n\nsticky为粘性定位 刚开始相对定位 拉到盒子即将出可视空间时就变成固定定位\n\n\n边偏移 是定位的一个属性 有top&#x2F;bottom&#x2F;left&#x2F;right 后面可以直接加距离\n\n定位的叠放次序\n使用z-index属性值可以控制盒子的叠放顺序 \n数值可以时正整数、负整数、或是0，默认是auto，数值越大，盒子越靠上\n如果属性值相同，则按照书写顺序，后来者居上\n数字后面不可以加单位\n只有定位的盒子才有z-index属性\n\n定位的扩展\n加了绝对定位的盒子不可以通过margin水平居中 但是可以通过left50%＋margin-left半个盒子的距离来实现居中（垂直居中同理）\n行内元素添加固定或者绝对定位，可以直接设置高度和宽度\n浮动元素、绝对定位元素都不会触发外边距合并的问题\n浮动元素只会压住其底下标准流的盒子，但是不会压住下面标准流盒子里面的文字和图片，但绝对定位会完全压住下面标准流中的所有内容。（浮动不会压住文字图片的原因是，浮动本来就是用于文字围绕图片的）\n\n如果一个盒子既有left属性又有right属性，则会默认执行left属性 同理有top bottom属性会执行top属性\n属性的显示与隐藏本质是让一个元素显示或者隐藏\n\n&#x3D;&#x3D;display显示隐藏元素&#x3D;&#x3D;\n属性值为none时表示隐藏对象\n属性值为block时表示转换为块级元素，同时还有显示元素的意思\n隐藏元素后盒子消失且占有的位置消失\n\n\nvisibility可见性\n属性值为visible元素可视\n属性值为hidden元素隐藏\n隐藏元素的盒子消失但是占有的位置还在\n\n\noverflow溢出\n对内容超过盒子宽度高度的内容进行影响\n属性值visible显示\n属性值hidden隐藏\n属性值scroll溢出部分显示滚动条\n属性值auto自动添加滚动条（溢出显示滚动条，不溢出不显示）\n有定位的盒子慎用hidden属性值，因为其会隐藏多余的部分\n\n\n\nCSS属性书写顺序建议遵循以下顺序：\n1.布局定位属性：display、float……\n2.自身属性：width、margin、background…….\n3.文本属性：font、color、text…….\n4.其他：border-radius、box-shadow……\n页面设计整体思路1.必须确认页面的版心（核心区）\n2.分析页面中的行模块，以及每个行模块中的列模块\n3.一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置\n4.制作HTML先制作结构最后写样式\n5.一定要先清除布局结构，再写代码\n导航栏nav制作\n实际开发中，我们不会直接用链接a而是用li包含链接（li+a）的做法。\nli+a的语义更为清晰，且如果直接用a，搜索引擎容易辨别为有堆砌关键字的嫌疑，从而影响网站排名。\n通过网站内容、网站关键词、网站外链、用户体验方面可以怎加网站排名。\n\n\n\nCSS高级技术精灵图为什么使用精灵图：为了有效的减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites）（CSS 雪碧）\n核心原理 将全部图片加载到一个大图片中 包含所有需要请求的小图片\n精灵图的使用\n精灵技术主要针对背景图片使用，就是将多个小背景图片整合到一张大的图片中\n\n通过移动背景图片的位置，此时可以使用background-position\n\n移动的距离就是这个目标图片的x和y坐标。注意网页中的坐标有所不同\n\n坐标系有所不同 往上往左走都是负值\n\n\n字体图标主要用于显示网页中通用的、常用的一些小图标\n字体图标的优点\n轻量：一个字体图标要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\n\n灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\n\n兼容性：几乎支持所有浏览器\n\n\n字体图标的使用\n在相应网站选择需要的图标后下载 将font文件复制一份安装到放HTML文件的目录里\n\n将压缩包中的style.css文件中第一个大括号所包含的复制到CSS中\n\n需要字体图标的地方点击demo.html后选择需要的字体图标进行复制\n\n最后再写一个font-family:’icomoon’;就可以了\n\n\n字体图标的追加\n点击import icons点击selection.json 就可以重新加载\n重新加载后需要重新下载，就要把以前的删除\n\nCSS三角只需要使用CSS就可以实现\n\n给一个盒子没有高宽 但是有border 改变颜色大小就可以出来小三角\n\nCSS用户界面样式如何更改用户鼠标的样式\n鼠标样式的属性为cursor 常用属性值为default&#x2F;pointer&#x2F;move&#x2F;text&#x2F;not-allow\n\n表单轮廓\n表单轮廓的属性为outline 可以改变表单轮廓\n\n防止表单域进行拖拽\n防止拖拽文本域resize 右下角的小拖拽可以取消掉\n\n图片文字居中对其vertical-align属性常用于设置图片或者表单（行内块元素）和文字垂直对齐\n属性值常为baseline（默认）&#x2F;top&#x2F;middle&#x2F;bottom\n也可用于消除图片和border之间的空白线\n文字溢出用省略号表示单行溢出想要完成这样的操作–必须满足三个条件\n先强制一行内显示文本：white-space:nowrap;（默认normal自动换行）\n超出的部分隐藏：overflow:hidden;\n文字用省略号代替超出的部分：text-overflow:ellipsis;\n多行溢出多行文本溢出显示省略号，有较大兼容性问题。\n代码如下：\noverflow:hidden;\ntext-overflow:ellipsis;\n弹性伸缩盒子模型显示：display:-webkit-box;\n限制在一个块元素显示的文本的行数：-webkit-line-clamp:(number);\n设置或检索伸缩盒子对象的子元素的排列方式：-webkit-box-orient:vertical;\n（通常是后台人员制作）\n常见布局技巧margin负值的运用两个盒子之间只有一条border 可以通过margin取负值（border宽度）来实现\n当使用margin负值的时候 如果需要使用hover可以使用z-index来增加显示顺序\n行内块的巧妙运用有些多个小盒子水平对齐而且有空格 可以考虑用行内块元素制作\nCSS三角强化不同的三角形可以通过更改border属性来获得 从而美化网页\n如想要获得直角三角形可以让bottom&#x3D;0，left&#x3D;0，再让right为透明\nCSS3的新特性\n新增的CSS3特性有兼容性问题，ie9+才支持\n移动端支持有优于PC端\n\nCSS新增选择器属性选择器想要选择标签中某个属性\n样式为 标签[属性]{……} 甚至[……]里可以是 属性&#x3D;属性值 或 属性^&#x3D;属性值（表示以某属性值开头） 或 属性&amp;&#x3D;属性值（表示以某属性值结尾） 或 属性*&#x3D;属性值（表示含有某属性值）\n类选择器、属性选择器、伪类选择器权重都是10\n结构伪类选择器结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器里面的子元素\n样式为 \n标签:first-child&#x2F;last-child&#x2F;nth-child(n){……}  (n可以是数字、关键字（例如even偶数，odd奇数）、公式)\n或 \n标签:first-of-type&#x2F;last-of-type&#x2F;nth-of-type(n) 同上\n两者的区别是 第一个是先排序 再看标签 没有就没有 第二个是先看标签 再排序\n伪元素选择器伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构\n选择符 ::before&#x2F;after 分别是在元素内部的前面和后面插入内容 里面必须有属性content\n伪元素是行内元素 不可设置宽高 想设置可以更改或浮动\nCSS3盒子模型CSS3中可以通过box-sizing来指定盒子模型，有2个值：即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。\n可以分为两种情况：\n1.box-sizing:content-box 盒子大小为width+padding+border (默认)\n2.box-sizing:border-box 盒子大小为width  以后可以在*中加这个\nCSS其他特性使图片变模糊\n样式 filter:函数();\n例如blur函数 数值越大图像越模糊 有单位\n\n计算盒子宽度width:calc函数\ncalc函数可以允许宽度进行运算 如width:calc(100%-30px);\n\nCSS过渡太强了 不需要js或者flash也能做出动画效果\n过渡：是从一个状态 慢慢的过渡到另一个状态 \n可以让我们的页面更好看，更动感十足 常与hover搭配使用\n\n属性为transition:要过渡的属性 花费时间 运动曲线 何时开始;\n过渡属性：选择自己想要的属性\n花费时间：需要写单位\n运动曲线：linear（匀速）&#x2F;ease（逐渐慢下来）&#x2F;ease-in（加速）&#x2F;ease-out（减速）&#x2F;ease-in-out（先加速后减速）  可以省略\n何时开始：默认是0s 可以延迟触发 必须写单位 可以省略\n如果想要写多个属性 用，分开\n\nCSS3 2D转换\n转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果\n\n属性为transfrom\n\n可以设置元素转换的中心点 transform-origin：x y；\n\n\n属性值为translate（x，y）\n\n优点 不会影响到其他的元素位置\ntranslate的百分比单位是相对于自身元素的translate\n对行内标签没有效果\n\n\n属性值为rotate（度数）    单位为deg\n\n可以配合别的属性做出表单下拉效果\n\n\n属性值为scale（x，y）表示放大缩小\n\nx为宽 y为高 （2，1）为宽两倍高不变\n\n\n\nCSS3 动画动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，通常用于实现复杂的动画效果、相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。\n动画分两步，先定义动画，再使用动画\n用keyframes定义动画（类似定义类选择器）样式为\n@keyframes 动画名称{\n0%{… : … ;}\n…\n100%{… : … ;}\n}\n用animation调用动画太帅啦\n\nanimation-name:动画名称\nanimation-duration:持续时间\nanimation-timing-function:规定动画的速度曲线，默认是”ease”\n除了之前过渡的属性值 还增加了一个属性值 steps（）指定了时间函数中的间隔数量（步长）–&gt;可以用于制作打字机效果\n\n\nanimation-delay:规定动画何时开始\nanimation-iteration-count:规定动画被播放的次数（无数次infinite）\nanimation-direction:规定下一周期是否逆播放（alternate逆播放）\nanimation-play-state:规定动画是否正在运行或暂停 默认是running还有paused （可以用于hover）\nanimation-fill-mode:规定动画结束后状态，保持forwards回到初始backwards\n动画简写属性：animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态\n\nCSS3 3D转换特点 近大远小\n物体后面遮挡不可见\nx轴水平向右 y轴垂直向下 z轴垂直向屏幕外\n3D位移\n样式 transform:translate3d(x,y,z);   其中z通常使用px\n\n3D旋转3D可以让元素在三维平面内沿着x轴，y轴，z轴或者自定义轴进行旋转\n语法\n\ntransforms:rotate3d(x,y,z,deg)\ntransforms:rotateX(deg)\ntransforms:rotateY(deg)\ntransforms:rotateZ( deg) —&gt;这个和2D旋转效果一样\n\n透视perspective\n\n如果想要在网页中产生3D效果需要透视（理解成3D物体投影在2D平面中）\n模拟人类的视觉位置 可认为安排一只眼睛去看\n透视我们也称为视距：视距就是人的眼睛到屏幕的距离\n距离视觉点越近的在电脑平面成像就越大，越远成像越小\n透视的单位是像素\n&#x3D;&#x3D;透视写在被观察元素的父盒子上&#x3D;&#x3D;\n样式为perspective:…px;\n\n3D呈现属性为transform-style\n\n控制子元素是否开启三维立体环境\n属性值为flat不开启、属性值为preserve-3d子元素开启立体空间\n代码写给父级但影响的是子级\n\n项目规划样式的模块化开发可以写部分CSS用于多个HTML文件 每当使用时就引用\n制作网站favicon图标将准备的图标切成png图片\n将png图片转化为ico图标，这需要借助第三方的转化网站\n将制作好的图标放在网页根目录下\n在head标签中复制网站上的代码粘贴即可\n网站TDK三大标签SEO优化SEO汉译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。\n前端人员不做SEO但是也要符合TDK三大标签优化\nT：title \n\ntitle具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网站的入口和对网页主题归属的最佳判断点\n\n建议：网站名（产品名）-网站的介绍（尽量不要超过30个汉字）\n\n\nD：description\n\n简要说明网站是干什么的\n提倡description作为网站的总体业务和主题概括\n前端人员只需要准备好meta name&#x3D;”description” content&#x3D;””&#x2F;单标签给准备好就行 接下来交给SEO开发人员\n\nK：keywords\n\nkeywords是网站的关键词，是搜索引擎的关注点之一\nkeywords最好限制在6~8个关键词，关键词之间用英文逗号隔开\nmeta name&#x3D;”keywords” content&#x3D;””&#x2F;\n\nLOGO SEO 优化\nlogo中首先放一个h1标签，目的是提权，告诉搜索引擎，这个地方很重要\n\nh1里面再放一个链接 可以返回首页的 把logo的背景图片给链接即可\n\n为了搜索引擎收录我们 我们来链接里面要放文字（网站名称），但是名字不要显示出来\n\n方法是font-size:0; 这样就看不见文字了\n\n\n最后给链接一个title属性，这样鼠标放在logo上就有提示文字了\n\n\nWeb服务器服务器（也称主机）是提供计算服务的设备，它也是一台计算机。在网络环境下，根据服务器提供的服务类型不同，服务器又分为文件服务器、数据库服务器、应用程序服务器、web服务器等。\n远程服务器是别的公司为我们提供的一台电脑，我们只要把网站项目传到这台电脑上，任何人都可以利用域名\nFlex布局原理\nflex是“弹性布局”，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局\n\n当为父元素设置flex布局之后，子元素的float、clear、vertical-align属性将失效\n\n定义为display:flex；\n\n\n常见父项属性\nflex-direction：设置主轴的方向\n主轴与侧轴 默认主轴为x 侧轴为y\n属性值为row（x轴）&#x2F;row-reverse（从右到左）&#x2F;column（y轴）&#x2F;column-reverse（从下到上）\n\n\njustify-content：设置主轴上子元素的排列方式\n属性值为flex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;space-around（平分空间）&#x2F;&#x3D;&#x3D;space-between（先两边贴边 再平分剩余空间）&#x3D;&#x3D;\n\n\nflex-wrap：设置子元素是否换行\nflex布局中 默认的子元素是不换行的 如果装不开 会缩小子元素的宽度 放到父元素里面\n\n\nalign-items：设置侧轴上的子元素的排列方式（单行）\n属性值为flex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;stretch（拉伸）–&gt;变得和父级一样\n\n\nalign-content：设置侧轴上的子元素的排列方式（多行）\n设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况，在单行下是没有效果的\nflex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;space-around（平分空间）&#x2F;space-between（先两边贴边 再平分剩余空间）&#x2F;stretch（设置子项元素高度平分父元素高度）\n\n\nflex-flow：复合属性\n\n常见子项属性\nflex子项目占的份数\n\n分配的是&#x3D;&#x3D;剩余空间&#x3D;&#x3D;\n\n样式为flex:数字;\n\n\n\nalign-self控制子项自己在侧轴的排列方式\n\nalign-self允许某单个项目有与其他项目不同的对齐方式 可以覆盖align-items\n\n\norder属性定义子项的排列顺序（先后顺序）\n\n数值越小 排列越靠前 默认为0\n\n\n\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"Hexo","url":"/2023/06/06/Hexo/","content":"\nBlog的墙面上镌刻有文字，你在细心收集后发现它们其实可以拼接在一起，好像……\n好像这是这个建筑形成的过程。\n\nHexo简单使用\n有一串奇怪的数字，在你研究过后发现这似乎是Blog搭建所需的时间！你惊叹，这短得似乎不可思议！可惜的是，这只在Windows中生效，但似乎……\n\n使用hexo搭建一个属于自己的Blog非常快捷，对于有web基础的同学可以1~2h内完成搭建并熟练使用。\nHexo安装建立一个存放blog的文件夹，然后使用以下指令进行全局安装。（使用cmd并定位到该目录下）\n$ npm install -g hexo-cli\n\n安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。(是文件夹的名称，用于后续工作)\n$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install\n\nHexo基础使用如果有部署网站，所有操作之后需要执行\n$ hexo g$ hexo deploy\n\n上传 建筑\n增加建筑可以在目标文件夹执行下列命令来创造一幢新的 建筑 。\n$ hexo new [layout] &lt;title&gt;\n\n其中 layout 是建筑的类型，有 post 、 page 、 draft\n一般只使用 post 。\n建立后在在source&#x2F;_post中修改markdown即可。\n建筑 创建后有以下配置项，可以参考修改。\n\n\n\n参数\n描述\n默认值\n\n\n\nlayout\n布局\nconfig.default_layout\n\n\ntitle\n标题\n文章的文件名\n\n\ndate\n建立日期\n文件建立日期\n\n\nupdated\n更新日期\n文件更新日期\n\n\ncomments\n开启文章的评论功能\ntrue\n\n\ntags\n标签（不适用于分页）\n\n\n\ncategories\n分类（不适用于分页）\n\n\n\npermalink\n覆盖文章的永久链接，永久链接应该以 / 或 .html 结尾\nnull\n\n\nexcerpt\n纯文本的页面摘要。使用 该插件 来格式化文本\n\n\n\ndisableNunjucks\n启用时禁用 Nunjucks 标签 &#123;&#123; &#125;&#125;&#x2F;&#123;% %&#125; 和 标签插件 的渲染功能\nfalse\n\n\nlang\n设置语言以覆盖 自动检测\n继承自 _config.yml\n\n\n修改建筑直接在source&#x2F;_post中修改markdown即可\n删除建筑直接在source&#x2F;_post中删除markdown即可\n之后输入一次以下命令\n$ hexo clean\n\n\n\nHexo搭建效果展示在搭建有关 建筑 后，需要进行展示\n先生成静态文件（每次更新 建筑 时都需要此步，便于页面部署，类似于vue中的dist）\n$ hexo g\n\n在本地使用服务器展示使用如下指令即可：\n$ hexo server\n\n接着就可以在网址为  http://localhost:4000/  访问到\nHexo配置项Hexo中用户可修改的配置放在 _config.yml 文件中，可根据官网描述修改。\n其中基础使用需要修改的项目有 \n\ntitle、author、language （用户信息）\ntheme （自定义主题）\ndeploy （简易部署）\n\nHexo简易一键部署页面托管可以使用github，完美符合静态Blog的需求。\n在 仓库Repositories 中新建一个 仓库 ，名称为 你的githubID.github.io 点击创建。\n接着在创建的文件夹的子文件夹public中使用git连接该仓库，push所有的文件。\n等待几分钟页面部署，即可在 https:&#x2F;&#x2F;你的githubID.github.io 中访问到。\n使用hexo快速完成git更改为了方便 建筑 搭建修改 需要在目标文件夹中运行以下命令\n$ npm install hexo-deployer-git --save\n\n在配置文件中更改\ndeploy:  type: git  repo: &lt;repository url&gt; #https://github.com/TaskManagerOL/TaskManagerOL.github.io  branch: [branch]  message: [message]\n\n\n\n\n\n\n参数\n描述\n默认\n\n\n\nrepo\n库（Repository）地址\n\n\n\nbranch\n分支名称\ngh-pages (GitHub) coding-pages (Coding.net) master (others)\n\n\nmessage\n自定义提交信息\nSite updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;)\n\n\ntoken\n可选的令牌值，用于认证 repo。用 $ 作为前缀从而从环境变量中读取令牌\n\n\n\n完成配置后每次只需执行\n$ hexo g$ hexo deploy\n\n即可快速上传文件\nHexo主题在上述网站中可以寻找自己喜欢的主题，点击大图可以预览，点击蓝字可以进入该作者的仓库。\n在hexo目录下的themes文件夹下打开git bash，输入以下命令，下载主题:\ngit clone 复制主题的网址\n\n配置_config.yml文件 修改theme 改为主题的名字\n在hexo目录下，打开git bash，输入以下命令，清除缓存，生成静态文件，查看效果\nhexo cleanhexo ghexo s\n\n\n你对这座Blog的一些疑惑在此刻被解答，你对这么庞大华美的Blog原先抱有一丝惊讶，但是现在，你暗自笑了一下。\n路灯先生 还是立在那里。\n\n","categories":["工具使用"],"tags":["工具","速通"]},{"title":"JQuery","url":"/2023/06/24/JQuery/","content":"JQueryjQuery API 中文文档链接\nJavaScript库即library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show。\n简单理解：就是一个JS文件，里面对我们原生的JS代码进行了封装，存放到里面。这样我们可以快速高效的使用封装好的功能。\njQuery的优点\n轻量级。\n跨浏览器兼容\n链式编程、隐式迭代\n对事件、样式、动画支持，大大简化了DOM操作。\n支持插件扩展开发。有着丰富的第三方插件，例如：树形菜单、日期控件、轮播图等。\n免费开源。\n\njQuery的顶级对象$1.$是jQuery的别称，在代码中可以使用jQuery代替它，但一般为了方便都是直接使用。\n2.$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用它包装成jQuery对象，就可以调用jQuery的方法。\njQuery对象和DOM对象DOM对象与jQuery对象之间是可以相互转换的。\n因为原生JS比jQuery更大，原生的一些属性和方法jQuery没有给我们封装，想要使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。\n\nDOM对象转换为jQuery对象\n\n$(‘div’)\n\n\njQuery对象转化为DOM对象（两种方式）\n\n$(‘div’)[index]\t\tindex是索引号\n$(‘div’).get(index)      index是索引号\n\n\n\njQuery选择器jQuery基础选择器原生JS获取元素的方式有很多、很杂，而且兼容情况不一样，因此jQuery给我们做了封装，使获取元素统一标准。\n$(“选择器”)&#x2F;&#x2F;里面选择器直接写CSS选择器即可，但要加引号\njQuery设置样式$(“div”).css(“属性”,”值”)\n隐式迭代（重要）遍历内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代。\n简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。\njQuery筛选选择器用法如$(“li:first”)\n\n:first  \t获取第一个元素\n:last       获取最后一个元素\n:eq(index)      获取到的元素中，选择索引号为2的元素，index从0开始。\n:odd      获取到的元素中，索引号为奇数的元素\n:even      获取到的元素中，索引号为偶数的元素\n\njQuery筛选方法用法如$(“li”).parent()\n\nparent()  查找父级\nchildren(selector)  相当于$(“ul&gt;li”),最近一级（亲儿子）\nfind(selector)   相当于$(“ul li”), 后代选择器\nsiblings(selector)      查找兄弟节点，不包括自己本身\nnextAll([expr])      查找当前元素之后所有的同辈元素\nprevAll([expr])       查找当前元素之前所有的同辈元素\nhasClass(class)       检查当前的元素是否含有某个特定的类，如果有，返回true\neq(index)       相当于$(“li:eq(2)”),index从0开始.\n\n链式编程链式编程是为了节省代码量，看起来更优雅。\njQuery样式操作操作CSS方法jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。\n\n参数只写属性名，则是返回属性值。\n参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号。\n参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号。如$(“div”).css({width:400,height:400})\n\n设置类样式方法\n添加类：$(“div”).addClass(“current”);\n移除类：$(“div”).removeClass(“current”);\n切换类：$(“div”).toggleClass(“current”);\n\n类操作与className区别原生JS中className会覆盖元素原先里面的类名\njQuery里面类操作只是对指定类进行操作，不影响原先的类名。\njQuery效果显示隐藏\n显示语法规范：show([speed],[easing],[fn])\n\n显示参数：\n\n参数都可以省略，无动画直接显示\nspeed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值\neasing：用于指定切换效果，默认是”swing”\nfn：回调函数，在动画完成时执行的函数，每个元素执行一次。\n\n\nshow()\n\nhide()\n\ntoggle()\n\n\n滑动\n滑动语法规范：slideDown([speed],[easing],[fn])\n\n滑动参数：\n\n参数都可以省略，无动画直接显示\nspeed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值\neasing：用于指定切换效果，默认是”swing”\nfn：回调函数，在动画完成时执行的函数，每个元素执行一次。\n\n\nslideDown()\n\nslideUp()\n\nslideToggle()\n\n\n淡入淡出\n淡入淡出语法规范：fadeIn([speed],[easing],[fn])\n\n淡入淡出参数：\n\n参数都可以省略，无动画直接显示\nspeed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值\neasing：用于指定切换效果，默认是”swing”\nfn：回调函数，在动画完成时执行的函数，每个元素执行一次。\n\n\nfadeIn()\n\nfadeOut()\n\nfadeToggle()\n\nfadeTo()\n\n渐进方式调整到指定的不透明度：fadeTo([speed],opacity,[easing],[fn])\nopacity透明度必须写，取值0~1之间。\nspeed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值\neasing：用于指定切换效果，默认是”swing”\nfn：回调函数，在动画完成时执行的函数，每个元素执行一次。\n\n\n\n自定义动画\nanimate(params,[speed],[easing],[fn])\n参数\nparams:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法\nspeed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值\neasing：用于指定切换效果，默认是”swing”\nfn：回调函数，在动画完成时执行的函数，每个元素执行一次。\n\n\n\n事件切换\nhover([over],out);\nover:鼠标移到元素上要触发的函数（相当于mouseenter）\nout:鼠标移出元素要触发的函数（相当于mouseleave）\n\n\n\n动画队列以及停止排队的方法\n动画或效果队列：动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。\n停止排队\nstop()\nstop()方法用于停止动画或效果\n注意：stop()写到动画或者效果的前面，相当于停止结束上一次的动画。\n\n\n\njQuery属性操作设置或获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性，比如元素中的href\n\n获取属性语法：prop(“属性”)\n设置属性语法：prop(“属性”，”属性值”)\n\n设置或获取元素自定义属性值attr()用户自己给元素添加的属性\n\n获取属性语法：attr(“属性”)  &#x2F;&#x2F;类似原生getAttribute()\n设置属性语法：attr(“属性”，”属性值”)\n\njQuery内容文本值主要针对元素的内容还有表单的值操作\n普通元素内容html()（相当于inner HTML）html()—-&gt;获取元素的内容\nhtml(“内容”)—-&gt;设置元素的内容\n普通元素文本内容text()（相当于inner Text）text()—-&gt;获取元素的文本内容\ntext(“内容”)—-&gt;设置元素的文本内容\n表单的值val()（相当于原生value）val()—-&gt;获取表单的值\nval(“内容”)—-&gt;设置表单的值\njQuery元素操作主要是遍历、创建、添加、删除元素操作。\n遍历元素jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作，就要用到遍历。\n\n$(“div”).each(function(index,domEle){xxx;})\neach()方法遍历匹配的每一个元素。主要用DOM处理。\n里面的回调函数有两个参数：index是每一个元素的索引号；domEle是每一个DOM元素对象，不是jQuery对象\n所以要想使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle)\n\n\n\n创建元素\n$(““)\n动态创建了一个\n\n添加元素\n内部添加\nelement.appent(“内容”)  把内容放入匹配元素后面，类似原生appendChild\n\n\n外部添加\nelement.after(“内容”)\nelement.before(“内容”)\n\n\n\n删除元素\nelement.remove()   &#x2F;&#x2F;删除匹配的元素\nelement.empty()    &#x2F;&#x2F;删除匹配的元素集合中所有的子节点\nelement.html(“”)    &#x2F;&#x2F;清空匹配的元素内容\n\njQuery尺寸、位置操作jQuery尺寸\nwidth()&#x2F;height()\t取得匹配元素宽度和高度值 只算width&#x2F;height\n\ninnerWidth()&#x2F;innerHeight()\t取得匹配元素宽度和高度值 包含padding\n\nouterWidth()&#x2F;outerHeight()\t取得匹配元素宽度和高度值 包含padding、border\n\nouterWidth(true)&#x2F;outerHeight(true)\t取得匹配元素宽度和高度值 包含padding、border、margin\n\n以上参数为空，则是获取相应值，返回的是数字型\n\n如果参数为数字，则是修改相应值\n\n参数可以不必写单位\n\n\njQuery位置位置主要有三个：offset()、position()、scrollTop()&#x2F;scrollLeft()\n\noffset()设置或获取元素偏移\n此方法设置或返回被选元素相当于文档的偏移坐标，跟父级没有关系。\n该方法有两个属性left、top。\n可以设置元素的偏移：offset({top:10,left:10})\n\n\nposition()获取元素偏移\nposition()方法用于被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为标准\n\n\nscrollTop()&#x2F;scrollLeft()设置或获取元素被卷去的头部和左侧\nscrollTop()方法设置或返回被选元素被卷去的头部。\n\n\n\njQuery事件单个事件注册\n语法：element.事件(function(){})\n\n单个事件处理事件处理on()绑定事件—-&gt;on()方法在匹配元素上绑定一个或多个事件的事件处理函数。\nelement.on(events,[selector],fn)\n\nevents:一个或多个用空格分隔的事件类型，如”click”或”keydown”\n\nselector:元素的子元素选择器。\n\nfn:回调函数，即绑定在元素上的侦听函数\n\n优势\n\n一：可以绑定多个事件，多个处理事件处理程序。$(“div”).on({mouseover:function(){},mouseout:function(){}})\n二：可以事件委派操作。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。\n三：动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件\n\n\n\noff()方法可以移出通过on()方法添加的事件处理程序。\n如果有的事件只想触发一次，可以使用one()来绑定事件\n自动触发事件trigger()有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发\nelement.trigger(“type”)\njQuery事件对象事件被触发，就会有事件对象的产生。\n阻止默认行为：event.preventDefault() 或者 return false\n阻止冒泡：event.stopPropagation()\njQuery其他方法jQuery对象拷贝如果想要把某个对象拷贝给另一个对象使用，此时可以使用$.extend()方法\n$extend([deep],target,object1,[objectn])\n\ndeep:如果设为true为深拷贝，默认为false浅拷贝\ntarget:要拷贝的目标对象\nobject1:待拷贝到的第一个对象\nobjectn:待拷贝到的第N个对象\n浅拷贝是把拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。\n\njQuery多库共存\n问题概述：jQuery使用$作为标识符，随着jQuery的流行，其他js库也会用其作为标识符，这样一起使用会起冲突。\n\n客观需求：需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。\n\njQuery解决方案：\n\n把里面的$符号统一改为jQuery，例如jQuery(“div”)\njQuery变量规定新的名称：$.noConflict()\n\n\n\njQuery插件jQuery功能比较有限，想要更复杂的特技效果，可以借助jQuery插件完成。\n注意这些插件也是依赖jQuery来完成的，所以必须要先引入jQuery文件，因此页被称为jQuery插件。\n\n常用网站：\n\njQuery插件库\njQuery之家\n\n\njQuery插件使用步骤\n\n引入相关文件。(jQuery文件和插件文件)\n复制相关html、css、js（调用插件）\n\n\n插件演示\n\n瀑布流\n懒加载：页面滑动到可视区域，再加载图片。我们使用jQuery插件库EazyLazyLoad。注意，此时的js引入文件和js调用必须写到DOM元素（图片）后面 \n全屏滚动（明日方舟）（fullpage.js）：github:https://github.com/alvarotrigo/fullPage.js\n\n\nbootstrap JS插件：bootstrap插件也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件。Bootstrap中文文档\n\n\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"Interview&Knowledge about Web-Front","url":"/2023/12/06/Interview-Knowledge-about-Web-Front/","content":"前端未来的展望✨当前PC和Mobile端前端都开发得差不多了，渐渐趋于一个稳态的状态，我们不妨展望一下未来：\n\nChatGPT在短期内很快就兴起了，最为容易看到的就是我去年这个时间节点还在自己手搓代码，但是这一届的学弟学妹已经开始使用GPT进行查找代码错误和提供代码思路了🤕。所以GPTwith前端、也可以推广到AIwith前端是一个大方向，但是前端这个东西似乎不是很适合机器学习，目前能做的好像我知道的就是用于代码优化（指机器学习作用于前端）。\n脑机接口近年来也开始兴起，前端作为人机交互工程师，未来脑机接口热潮的时候一定是一个风口浪尖。\n语音转文字前端也是一个点。\n\n前端人应该拥有的素养❤️\nBlog要经常记录，我打算寒假就让学弟学妹们去制作一个自己的blog，可以使用vercel、4everland自己部署，也可以hexo+github部署……自己决定。Blog内容还是尽量自己手敲（这点我自己也没有做到，自己手敲上去的东西更加属于自己，虽然复制粘贴文档的显得工作量更多🥺）\n积极思考，常常思考自己的代码有没有改进的地方，这个是从韦华贤学长那里学到的，事件点是在我的tasklist有一个函数一眼就需要封装一下，自己很蠢的没看出来，和他沟通之后他说是一个习惯问题，我仔细思考过后觉得这个也是一个前端人应该拥有的素养😈\n拥有好奇心和自趣力——前端-WEB-或者说整个计算机行业都是快速迭代的，需要你跳出工作&amp;其他需求式编程去自己学习自己钻研，这个过程是相当有趣的。\n责任心这个东西就算跳开前端工程师这个tag也是很重要的东西，它是可以伴随你一生的良好品质，不管是平日的生活遇到的东西还是以后自己项目中会遇到的一些事情，你都需要一个很重的责任心去维护一些东西。\n增加学习深度，扩宽学习广度：这个是一个很有意思的问题，在我多方向调研和请教很多人过后，我得到一个结论：在国内大环境，广度重要性远大于深度重要性（至少对于前端且考虑范围取最大）。这过程中我请教了厚华学长、阿韦学长、环节、工具箱学长，各有说辞：\n厚华学长在准备实习，有很多自己整理出来的面经，他得到的结论是，我需要去弄懂很多之前已经学过会用的，但是基层逻辑不懂的东西，确实是这样，他share过来的很多面试题目我基本看了只能答出表层的东西，再问深一点就没办法说出它的底层逻辑了，但是我认为这个是一个很基本的深度（本来就需要去掌握的东西）以至于他不能算是深度。\n第二个就是阿韦，在深度广度这一块的话给的建议是先学透一个，这样基本原理弄清楚之后其他也会好搞很多。\n工具箱学长也是说建议有自己能拿出手的东西，深度。\n但是面向实际开发中，不管是大厂小厂，都需要你有一个很广的技术栈，会了web需要app，甚至后端、操作系统、ui都需要。\n\n\n\n漫谈🎇\n面试相关问题：\n对于前端工程师面试中更加需要注意的是编程范式的问题，作为一个刚刚毕业或者还没有毕业的小东西，当你没有一个非常专业or深度的知识的话，面试官更加有可能考你的是很基础的编程——数据结构等。\n对于后端工程师，需要通透的是数据库有关知识，这里我不是很了解，不多胡诌了。\n如果拥有自己的项目的话，面试官会问项目相关架构。\n更加重要的是，你需要面试的时候自己编写代码，这就需要你拥有相关的能力。\n\n\n面试八股文这一块，我有一个观点，我觉得这个属于一个戏称，其实面试中提到的问题我个人认为还是很有用的，通透原理才能使用。所以我觉得多收集多解决这些问题还是很有趣的，有时候还能遇到一些自己不会的问题。\n当你通过面试进入公司之后技术就不会是最难的东西了，更加难的是团队的协作等。这是一个很有趣的我从一些前端大牛身上拿到的观点。\n多投简历、脸皮要厚，什么想投的都去尝试，过后成或不成都可以促进你的学习——在面试中没有解决的问题可以自己花时间去解决。\n多参与开源项目，可能一开始在开源项目中能做的很少，但是这是一个渐进的过程，后面就可以做的多起来了。\n\n","categories":["随笔"],"tags":["😶‍🌫️"]},{"title":"Java","url":"/2024/01/30/Java/","content":"","categories":["技术栈"],"tags":["笔记","后端"]},{"title":"Locked ROOM","url":"/2023/06/11/Locked%20ROOM/","content":"\n  b42b6612c519e420d423526f6209e55ad95c738451e793bc0d39cf2971750db15896d30d9008a4bf6f0236f404ab2abcf7b868f50e2953165c5b70a3b9ea10757c461d6a8c07cecc15b7d7ae987df3250a0b8d92ab2f097706557b267a7f8b9011c75ee1e5cdd75ce10d9fc81cf85bef4c4bad2118d1fc3ff247b368bd36ac8c2ff723f884457f6ed1e6161631ce9a0a76c23ca63a00b904599f7f556e41d28a95ac0748b1d667de70de62cdf4beaa12724c85865312940efabcb3dcc055eacba217e4cece74425efb7bc53d3b7f7556abe4002b975de062733d62e9893ace3292641f4bfd7d7b60b1b506eec0aa94f36779fa6d6a7ccc7123fc8cb7d3b6bd0c23d1c79083b33e18162717dd422d29f2d87c48ab0ca86a1bc49ef2b68d5e56b43f706aaa6e6e2ff803c87bc7d0a9438041b30e1252dc3d242b9e6951f2e62aba8fb06cc6fbc3a9bd0ff117b7fc8cbb51a4734690a6e3f9544b1826e3b616b5ebfcb78c22accbd1b14a3949ade6e95790cfdf4717534abd3913eb9f6f13e441bc2b5541d414104ea50182a18e4e85d00265e6e2294e2c9b0863a2601be38a557c60da7e0164e87d232eb69294e235ad4c4c718c948df0657d240302f4f9fb19c0669944c39b7a7937944fea526abfad139f6a7f89bb3f980fff8376cca75cef3c34fd20231c0942a26742c2ff8f04f35431c3c4020c4d24842ad6caa629b4833ea50d49b3fdde4b929db280ca455f55e34432a073bed54caaa68424cbc2be265a05b47284e69d4e3db5b860505082d4890e8cfa4fdfc08350876401b8f673b616b530380e354723e7fd7a558d4d7f7cc721d0391cc39a3b5a24e2b7b1136abf27f0aac677a0243e6bb51c4aabfb7adc395bf81cce36690d70ef2744b5943079182574119441053d54aa921835be7bf14a9574b414168c02b12032f8c88767c1abc53b04f051264ac4320629f62b1260d860927befce216d898375ab7958c9741e56f3c9742e346bb89ce5a8d84970488df908c3899a49252724e2e0db1b2c26057ba945657fa168556b82c28be4aa0fea6ca343d32cf395037b0889589a27d7e52de5ff5ec881b6f40a0d655ae7f95a0f76c7f4e088ffbf997830d9ea678bd3cb786ccef8583366c47c2e09f17014c59456370cf3690309b4ffa169da3ecf2ed4a82fd4801b61d4cccacc2ab3599a7118657dd8ba39a83572941856e3df9b3a2757f09f56c5f34cccd8570ba524f814adb5909654df0928e2fcbab21a99ec507306cc19506c1bae4028aea0310c9d770b31337c7e079b5901cb5b34d11b4d5cc7ac5324fcffd6a9bfc6c930eb80ee763f8faa86d8dad0c2eb96919530a33e8b0316c3b14f412fc4ecee7d5f86fe602583a1e94af265ec881920c426fc64a8aab4af1d01ab048bf2422b5a352503fca384c7761c6fec852a22115c1025345786fb9ad00b77507bc4ad1b5bae80d2be7b509a73c96563e5829735f3e43105abe187153ff169e2b3a48bdb71dd028dbbfc2fe25665bf9796c0a50c0acf3b1353c42879a2c6d3f015de85acb7f4f8d2b6277842a224878f473518cd2d4422d16444b2d65a21132b256fcfa24d10a032821d7f8d3dada222ab8947cddbae2ecd4c2f83233ea33ab83474cc0d4d9f9c49786c1558aaf38d4ca2275a9fbfe829c8b1f805a506a40ab2c582e7fab0a870746b8dda23691c91f292af5cc38392f8a84296837d7b34fa71bea21077014b47dc7208249c04844508f8589da20307bcadcfa3b2561429f65fe3963bff507423ba8e1448acc3d69ab59a82489d029ac78cc34a30103a558f1730b37caffc623fc869775870a100d932e1f587c8c8f6868c4fd8449a56968b2dd538f5a65fae8e4fd734ca02f611517e9d62691dbb9edc63916b6420c52af57eb4e9f46a93bab4371af0199810fc931a0a25dec76d8c734604876856e57b018b54c5673674b79beeddd00b37e97ccc6f443340c30d0c0ab835da40393875abe324261940e1aaf36e8fd4aef4048af5c3ef0df62e68801e1b55a1aca8418afcfddf5fa93a92e81df01a61fbb7d22f2ffcc9f11bb0414aae0bd3804465e35820f242ef45f6e4e6b74ce54bef597166622aac5aff3abf1c49e374e9c4772c44ebed28c10d1d3041cb90e583486fdc0f0d4cd793505a0fa1efe20cd3d542ed754f5a96b8c93e884bbb4b64aacb44a15b6b1366539b9a86fecf7d3a1c019e2a915ccebff18188c528b9ba1e9a12bf1e047815713d6a9d3aa4416ef0ecb2\n  \n    \n      \n      \n        右边眼睛字体图标显示时回车插入🔑\n      \n    \n  \n\n","categories":["随笔"],"tags":["😶‍🌫️"]},{"title":"MITT","url":"/2023/11/13/MITT/","content":"在Vue3中为了优化代码会使用全局事件总线bus去在不同组件之间传值。\n首先先安装一下mitt\nnpm install mitt\n\n添加一个bus.js的文件里面放这些\nimport mitt from &#x27;mitt&#x27;export const events = mitt()\n\n在需要使用bus的组件里引入依赖\nimport &#123; events &#125; from &#x27;.../.../bus.js&#x27;\n\n使用方法主要是三种：\n\nemit：想要传出值或函数\nevents.emit(&#x27;functionName&#x27;, postValue)//其中functionName是你绑定的一个函数名，相当于一个标识，可以在不同组件中靠这个来判定来源和目的地，postValue是你要传的值。\n\non：想要接受传入值\nevents.on(&#x27;functionName&#x27;, (val) =&gt; &#123; ... &#125;)//其中functionName是你绑定的一个函数名，相当于一个标识，可以在不同组件中靠这个来判定来源和目的地，val是你上面传出来的postValue，要干什么自己写在...里。\n\noff：想要解绑事件\n//某些情况可能要解绑events.off(&quot;functionName&quot;)\n\n","categories":["技术栈"],"tags":["笔记","前端"]},{"title":"JavaScript","url":"/2023/06/24/JavaScript/","content":"JavaScript初识JS的作用\n表单动态校验（密码强度检测）\n网页特效\n服务端开发\n桌面程序\nAPP\n控制硬件\n游戏开发\n\n浏览器怎么执行JS\n渲染引擎：用于解析HTML和CSS，俗称内核\nJS引擎：也称为JS解释器。用于读取网页中的JS代码，对其处理后运行。\n\n浏览器本身并不会执行JS代码，而是通过内置的JS引擎来执行JS代码，JS引擎执行代码时逐行解释每一句源码，然后由计算机去执行，所以JS语言归为脚本语言，会逐行解释执行。\nJS组成\nJS语法\n页面文档对象模型\n浏览器对象模型\n\nJS的三种书写方式\n行内\n内嵌—-&gt; 像CSS一样写一个script在head位置\n外部—-&gt;在双标签前面写src&#x3D;”……” 而且双标签之间千万千万不能写代码\n\nHTML中推荐使用双引号，JS中推荐使用单引号\nJS注释同c语言\nJS输入输出语句\nalert(msg)\t浏览器弹出警示框\nconsole.log(msg)    浏览器控制台打印输出信息—-&gt;程序员测试用\nprompt(info)    浏览器弹出输入框，用户可以输入—&gt;取到的值是字符串\nconsole.dir（msg）可以打印我们返回的元素对象 更好的查看里面的属性和方法\n\n变量变量的使用声明变量–var 变量名;\n赋值–变量名&#x3D;值;\n数据类型JS时一种弱类型或者说动态的语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会被自动锁定（拜托，超级爽的好嘛 var 可以赋所有东西）\n数据类型的分类\n简单数据类型\n数字 包括整数和小数 还可以写不同进制的 \n如八进制 var num&#x3D; 010；这样 \n十六进制要写一个 0x在前面\nInfinity表示无穷大 前面加一个负号表示无穷小\nisNaN()用于判断是不是非数字 是返回false\n\n\n布尔值\n字符串 任意文本\n转义符同c\n字符串拼接 用+就可以  变量不要写到字符串中 是通过和字符串相连的方式实现的\n\n\n还有undefined（未声明）和Null（空）\n\n\ntypeof 后面接变量 可检测变量类型\n复杂数据类型：通过new关键字创建的对象如Object、Array、Date这些都属于复杂数据类型。\n\n数据类型的转换\n转为字符串型\n.toString()\nString(变量)\n\n\n&#x3D;&#x3D;转为数字型&#x3D;&#x3D;\nparseInt(变量)—-&gt;转为整形（会去掉字母）\nparseFloat(变量)—&gt;转为浮点\nNumber(变量)—-&gt;强制转换为数字\n\n\n转为布尔值型\nBoolean(变量)\n会将空、否定的值都转化为false\n其余的值会转化为true\n\n\n\n\n\nJS基础\n断点设置 在浏览器中f12 点sources再点左边那里可以设置断点\n\n数组创建数组样式为\n\nvar 变量&#x3D;new Array()；——&gt;以创建一个新的数组\nvar 变量&#x3D;[…,…,…];\n\n数组的长度使用“数组名.length”可以访问数组元素的数量（数组长度）\n数组中新增元素可以通过修改length长度以及索引号增加数组元素\n\n修改length长度：比如变量.length&#x3D;数字 ；这样就可以改数组的长度为 某个数字了\n索引号增加数组元素：例如本来长度是5 你在[]里写6 就会扩容啦\n\n正则表达式正则表达式概述正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。\n正则表达式的特点1.灵活性、逻辑性和功能性非常的强。\n2.可以迅速地用极为简单的方式达到字符串的复杂控制\n3.对于刚接触的人来说，比较晦涩难懂。\n4.实际开发中，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式。\n创建正则表达式\nvar name&#x3D;new RegExp(&#x2F;表达式&#x2F;);\nvar name&#x3D;&#x2F;表达式&#x2F;;\n\n测试正则表达式regexObj.test(str)\n1.regexObj是写的正则表达式\n2.str是我们要测试的文本\n3.就是检测str文本是否符合我们写的正则表达式规范\n正则表达式的组成一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合，其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号。\n特殊字符可以参考：MDN\n\n边界符：\n\n^   表示匹配行首的文本（以谁开始）\n$   表示匹配行尾的文本（以谁结束）\n[]   表示有一系列字符可供选择，只要匹配其中一个就可以了。\n[-]表示方括号内部的范围\n[^]表示取反\n|表示或者\n\n\n量词符：\n\n*重复零次或更多次\n+重复一次或更多次\n？重复一次或零次\n{n}重复n次\n{n，}重复n次或更多次\n{n，m}重复n到m次\n\n\n括号总结\n\n大括号 量词符 表示重复次数\n中括号 字符集合。匹配方括号中的任意字符\n小括号 表示优先级\n\n\n预定义类\n\n\\d  匹配0~9之间任一数字\n\\D  匹配0~9外任意字符\n\\w  匹配任意的字母、数字和下划线\n\\W  匹配除所有字母数字、下划线以外的字符\n\\s   匹配空格（包括换行符、制表符、空格符等）\n\\S  匹配非空格的字符\n\n\n\n函数函数的使用样式：function  函数名（）{ 函数体 }；\n或\n&#x3D;&#x3D;样式：var 函数名 &#x3D; function（）{}；&#x3D;&#x3D;\n调用直接输：函数名（）即可\n函数的返回如果函数没有返回值就会返回undefined。\narguments使用arguments是伪数组\n\n不是真正意义上的数组\n具有length的属性—-&gt;argiments.length\n只有函数才有\n它没有真正数组的一些方法\n\nJS作用域就是代码名字在某个范围起作用和效果\n函数内没有赋值的变量也是全局变量\n预解析var 变量&#x3D;值 \n定义和赋值会分开 定义会放在最前面\n且函数定义也会放在前面\n对象调用对象：\n\n输入变量的地方输入 对象名.属性名（.理解为”的“）\n在对象名后面加   [‘属性名’]\n\n什么是对象对象是由属性和方法组成的\n\n属性：事物的特征，在对象中用属性来表示（常用名词）\n方法：事物的行为，在对象中用方法来表示（常用动词）\n\n为什么需要对象保存一个值时，可以使用变量，保存多个值时，可以使用数组。\n但JS中的对象表达结构更清晰，更强大。\n创建对象的三种方式用字面量创建对象就是花括号{}里面包含了表达这个具体事务（对象）的属性和方法\n样式举例：var 对象名&#x3D;{ 属性1：…，方法2：…；}；\n用new Object创建对象样式：var 对象名&#x3D; new Object（）；\n追加方法：直接在下一行写对象名.属性名&#x3D;…\n利用构造函数创建对象\n构造函数创建对象的好处是一次可以创建多个对象\n构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面\n创建构造函数样式：function 构造函数名（）{this.属性&#x3D;值；}\n调用构造函数new 构造函数名（）；\n构造函数首字母要大写\n构造函数不需要return就可以返回结果\n\n遍历对象想要输出对象里面的多个属性\n样式为：for（变量名 in 对象名）\n引用变量自动往里面放所有的属性\n内置对象什么是内置对象\n内置对象就是JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）\n内置对象的最大优点就是帮助我们快速开发\nJS提供了多个内置对象：Math、Data、Array、String等\n想要使用可以去MDN网站查找\n\nWeb APIWeb APIs和JS基础关联性\nJS基础知识基本语法 做不了常用的页面交互效果\nWeb APIs是JS独有的部分 主要学习页面交互功能\n\nAPIAPI是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码。\nWeb API是浏览器提供的一套操作浏览器功能，主要针对浏览器提供的接口\nDOM\n文档对象模型\nDOM就是把文档当作一个对象来看待\nDOM的顶级对象是document\nDOM主要学习的是操作页面元素\nDOM是W3C标准规范\n\n1.对于JS，为了能够使JS操作HTML，JS就有了一套自己的dom编程接口。\n2.对于HTML，dom使得html形成一棵dom树。包括文档、元素、节点。\n什么是DOM文档对象模型（DOM），是一种标准编程接口。W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结果、样式。\nDOM树\n文档：一个页面就是一个文档，DOM中使用document表示\n元素：页面中的所有标签都是元素，DOM中用element表示\n节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中用node表示\n\n&#x3D;&#x3D;DOM把以上内容都看成对象&#x3D;&#x3D;\n获取元素根据ID获取\n样式为：element.getElementById（’id’）\n\n根据标签名获取\n样式为：element.getElementsTagName（’元素’）\n\n得到的是对象的集合\n\n输出要在元素后面加s\n\n\n通过HTML5新增的方法获取\n考虑兼容性不可使用\n样式为：element.getElementsClassName（’元素’）&#x2F;&#x2F;根据类名返回元素对象集合\n样式为：element.querySelector（’选择器’） &#x2F;&#x2F;根据指定选择器返回第一个元素对象—&gt;比如.什么什么就是类选择器\n只能返回第一个元素对象\n返回全部的话：element.querySelectorAll（’选择器’）\n\n\n\n特殊元素获取\n获取body标签\n样式element.body；\n\n\n获取html元素\n样式element.documentElement；\n\n\n\n事件基础事件概述JS使我们有能力创建动态页面，而事件是可以被JS侦测到的行为\n简单理解：触发—响应机制\n事件由三部分组成： 事件源 事件类型 事件处理程序\n\n事件源 事件被触发的对象 如 按钮\nvar btn&#x3D;button.getElementById(‘btn’)\n\n\n事件类型 如何触发 什么事件 比如鼠标点击（onclick） 还是鼠标经过 还是键盘按下\n事件处理程序 通过一个函数赋值的方式完成\nbtn.onclick&#x3D;function( ){…..}\n\n\n\n执行事件的步骤\n获取事件源\n注册事件（绑定事件）\n添加事件处理程序\n\n鼠标事件操作\nonclick鼠标点击左键触发。\nonmouseover鼠标经过触发\nonmouseout鼠标离开触发\nonfocus获得鼠标焦点触发\nonblur失去鼠标焦点触发\nonmousemove鼠标移动触发\nonmouseup鼠标弹起触发\nonmousedown鼠标按下触发\n\n操作元素改变元素内容\nelement.innerText&#x3D;  可以改变元素内容(不识别html标签)\n\nelement.innerHTML&#x3D;  可以改变元素内容(识别html标签)——使用最多\n\n\n样式属性操作\nelement.style&#x3D;行内样式操作\nelement.className&#x3D;类名样式操作\n\n改变元素类名\n在JS中想一下子改很多，而且有多个项目要更改时，可以用更改类名。\n正常是element.style修改的样式，但是你可以先定义一个类名是你要修改后的样式，然后写this.className&#x3D;’该类名’，就可以做到修改了。（会进行覆盖）\n如果想要保留原来的类名，可以用this.className&#x3D;’原来的类名 该类名’    这样。\n\n自定义属性的操作\n获取属性值\nelement.属性   获取属性值\nelement.getAttribute(‘属性’)；\n\n\n区别：\nelement.属性 获取内置属性值（元素本身自带的属性）\nelement.getAttribute(‘属性’)； 主要获得自定义的（标准）我们程序员自定义的属性（没错，属性是可以自定义的）\n\n\n设置属性值\nelement.属性&#x3D;“值”  设置内置属性值。\nelement.setAttribute(‘属性’,’值’)\n\n\n\n节点节点概述一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）这三个基本属性。\n\n元素节点 nodeType 为 1；\n属性节点 nodeType 为 2；\n文本节点 nodeType 为 3（文本节点包含文字、空格、换行等）；\n\n我们在实际开发中，节点操作的主要操作的是元素节点\n为什么要用节点操作呢？\n因为在利用我们节点层次关系获取元素的时候会更简单一些。\n节点层级利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系\n\nelement.parentNode就可以直接代替var …………（得到的是离元素最近的父节点）\nelement.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。而且childNodes返回的是所有子节点 包括元素节点、文本节点等等。\nelement.children返回所有元素子节点，虽然看着很不兼容，但是各个浏览器都是允许使用的。其中对第一个元素子节点和最后一个子节点有特殊的获取方式：（包括元素节点、文本节点等等）\n第一个子节点：element.firstChild即为获取第一个子节点。\n最后的子节点：element.lastChild即为获取最后一个子节点。\n第一个元素子节点：element.firstElementChild即为获取第一个元素子节点。（有兼容性问题IE9+支持）\n最后的元素子节点：element.lastElementChild即为获取最后的元素子节点。（有兼容性问题IE9+支持）\n正常开发的写法都是element.children[number]这样。\n\n\n兄弟节点：\n下一个兄弟节点：element.nextSibling返回当前元素的下一个兄弟节点，找不到则返回NULL\n上一个兄弟节点：element.previousSibling返回当前元素上一个兄弟节点，找不到则返回null\n下一个元素兄弟节点：element.nextElementSibling返回当前元素的下一个元素兄弟节点（有兼容性问题IE9+支持）\n上一个元素兄弟节点：element.previousElementSibling返回当前元素的上一个元素兄弟节点（有兼容性问题IE9+支持）\n\n\n\n节点操作\n创建元素节点：var 节点名字&#x3D;document.creatElement(‘需要创建的节点’) （innerHTML也可以创建节点，但是innerHTML的原理是拼接字符串，creatElement是创建新节点，所以，creatElement会相对快很多。\n添加元素节点：\nelement.appendChild（child）其中element是父级，child是子级  将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素。\nelement.insertBefore（child，指定元素）  将一个节点添加到父节点的指定子节点前面。类似于CSS里面的before伪元素。\n\n\n删除元素节点：element.remove(需要删除的元素节点);（例如某某元素[]）\n克隆元素节点：element.cloneNode(); 复制元素节点，但是复制后需要添加，相当于var name&#x3D;node.cloneNode();   然后再使用添加元素节点的知识进行添加。\n括号为空或为false则为浅拷贝，即只复制节点本身，不copy里面的子节点。\n括号里为ture则为深拷贝，可以复制节点里面的所有东西。\n\n\n\n事件高级注册事件\n注册事件概述：给元素添加事件，称为注册事件或者绑定事件。\n注册事件有两种方式：传统方式和方法监听注册方式。\n传统注册方式：\n利用on开头的事件onclick\n\nbtn.onclick&#x3D;function(){}\n特点注册事件的唯一性\n同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。\n\n\n方法监听注册方式：\nw3c标准 推荐方法\naddEventListener（）它是一个方法\nIE9之前的IE不支持此方法，可使用attachEvent（）代替\n特点：同一个元素，同一个事件可以注册多个监听器。\n按注册顺序依次执行。\n\n\naddEventListener事件监听方式\neventTarget.addEventListener（type，listener[，useCapture]）方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，就会触发执行事件处理函数。\n该方法接收三个参数：\ntype：事件类型字符串，比如click，mouseover，注意这里不要带on\nlistener：事件处理函数，事件发生时，会调用该监听函数。\nuseCapture：可选参数，用于描述事件是冒泡还是捕获，是一个布尔值，默认是false。\n\n\n\n\nattachEvent事件监听方式（IE9前版本支持）\neventTarget.attachEvent(eventNameWithOn,callback)方法将指定的监听器注册到eventTarget上，当该对象触发指定的事件时，指定的回调函数就会被执行。\n该方法接受两个函数：\neventNameWithOn:事件类型字符串，比如onclick，onmouseover这里要带on\ncallback：事件处理函数，当目标触发事件时回调函数被调用。\n\n\n\n\n\n解绑事件\n传统注册方式：eventTarget.onclick&#x3D;null；\n\n方法监听注册方式：\n\neventTargrt.removeEventListener（type，listener[，useCapture]）；\n其中listener要写函数的名称，这也就意味着注册的时候也要用函数的名称。\n\neventTargrt.detachEventListener（type，listener[，useCapture]）；\n此为IE9前适用\n\n\n\n\nDOM事件流事件流描述的是从页面中接收事件的顺序。\n事件发生时会在元素节点之间按照待定的顺序传播，这个传播过程即为DOM事件流。\nDOM事件流分为三个阶段：1.捕获阶段。2.当前目标阶段。3.冒泡阶段。\n\n事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级上传到DOM最顶层节点的过程。\n有些事件是没有冒泡的：例如onblur、onfocus、onmouseenter、onmouseleave\n\n事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收过程。\n\n结合useCapture，若useCapture为true则为事件捕获，false为事件冒泡\n\n\n事件对象div.onclick&#x3D;function(event){}\n1.event就是一个事件对象，写到我们侦听函数的小括号里面，当形参来看。即事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，他有很多的属性和方法。\n2.事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数。\n3.事件对象是我们事件的一系列相关数据的集合，跟事件相关的，比如鼠标点击里面就包含鼠标的相关信息，鼠标坐标之类的，如果是键盘事件里面就包含的键盘事件的信息，比如判断用户按下了哪个键。\n4.这个事件对象我们可以自己命名 比如event、evt、e（你第一次写的空洞骑士界面音乐盒就是e）\n5.事件对象也有兼容性问题 IE678通过window.event\n兼容性写法e&#x3D;e||window.event\n事件对象的常见属性和方法\ne.target   返回触发事件的对象 标准\ne.target返回的是触发事件的对象（元素） this返回的是绑定事件的对象（元素）如绑定ul但触发的li\n\ne.srcElement  返回触发事件的对象 非标准IE6~8使用\n\ne.type 返回事件的类型 比如click mouseover不带on\n\ne.cancelBubble 该属性阻止冒泡 非标准 IE6~8使用\n\ne.stopPropagation 该方法阻止冒泡 标准\n\ne.returnValue 该属性阻止默认事件 非标准IE6~8使用 比如不让链接跳转\n\ne.preventDefault 该方法阻止默认事件 标准 比如不让链接跳转\n\n\n事件委托（代理、委派）事件委托也称为事件代理，在jQuery里面称为事件委派。\n\n事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响每一个子节点（面试时用得到！！！！！！）  \n事件委托的作用：只操作了一次DOM，提高了程序的性能。\n\n常用的鼠标事件常见的鼠标事件\ncontextmenu是鼠标右键的菜单\n\nselectstart是鼠标的选中（拉动的选中）\n\nclick  单击鼠标左键时发生，如果右键也按下则不会发生。当用户的焦点在按钮上并按了 Enter 键时，同样会触发这个事件\n\nmousedown 单击任意一个鼠标按钮时发生\n\nmouseout 鼠标指针位于某个元素上且将要移出元素的边界时发生\n\nmouseover  鼠标指针移出某个元素到另一个元素上时发生\n\nmouseup  松开任意一个鼠标按钮时发生\n\nmousemove   鼠标在某个元素上时持续发生\n\n\n鼠标事件对象\ne.clientX 返回鼠标相对于浏览器窗口可视区的X坐标\ne.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标\ne.pageX 返回鼠标相对于文档页面的X坐标 IE9+支持\ne.pageY 返回鼠标相对于文档页面的Y坐标 IE9+支持\ne.screenX 返回鼠标相对于电脑屏幕的X坐标\ne.screenY 返回鼠标相对于电脑屏幕的Y坐标\n\nmouseenter和mouseover的区别mouseover经过自身盒子会触发，经过子盒子还会触发。\nmouseenter只有经过自身盒子才会触发。（不会冒泡）\n常用的键盘事件常用键盘事件\nonkeyup 某个键盘按键被松开时触发\nonkeydown 某个键盘按键被按下时触发\nonkeypress 某个键盘按键被按下时触发 但是不能识别功能键 如ctrl shift 箭头等\n\n键盘事件对象\nKeyCode 返回键盘按下键的ASCII码值\nkeyup和keydown事件不区分字母大小写，都按照大写来看\nkeypress事件区分字母大小写\n\n\n\nBOM\n浏览器对象模型\n把浏览器当作一个对象来看待\nBOM的顶级对象是window\nBOM学习的是浏览器窗口交互的一些对象\nBOM是浏览器厂商在各自浏览器上定义的，兼容性较差\n\nBOM概述BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象时window。\nBOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。\nBOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C\nBOM的构成window对象是浏览器的顶级对象，它具有双重角色\n1.它是JS访问浏览器窗口的一个接口\n2.他是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。\n在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert、prompt等\nwindow对象的常见事件窗口加载事件\nwindow.onload&#x3D;function(){}\n\n或者\n\nwindow.addEventListener(“load”,function(){});\n\nwindow.onload是窗口（页面）加载事件，当文档内容完全加载会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数。\n\ndocument.addEventListener(‘DOMCotentLoaded’,function(){})\n\nDOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片、flash等。\nIE9以上才支持\n如果页面的图片很多的话，从用户访问到onload触发可能需要较长时间，交互效果就不能实现，必然影响用户体验，此时用DOMCotentLoaded事件比较合适。\n\n\n\n注意：\n\n有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。\nwindow.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。（addEventListener则没有限制）\n\n调整窗口大小事件\nwindow.onresize&#x3D;function(){}\nwindow.addEventListener(“resize”,function(){})\nwindow.onresize是调整窗口大小加载事件，当触发时就调用的处理函数。\n只要窗口大小发生像素变化，就会触发这个事件。\n我们经常利用这个事件完成响应式布局。window.innerWidth为当前屏幕的宽度\n\n\n\n定时器window对象给我们提供了2个非常好用的方法-定时器\nsetTimeout()定时器window.setTimeout(调用函数,[延迟的毫秒数]);  \nsetTimeout()方法用于设置一个定时器，在该定时器在定时器到期后会执行调用函数。\n\nwindow可以省略\n这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式。第三种不推荐。\n延迟的毫秒数省略默认为0，如果写，必须是毫秒。\n因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。\n\n停止setTimeout()定时器window.clearTimeout（timeout ID）\n\nwindow可以省略\n里面的参数就是定时器的名字\n\nsetlnterval()定时器window.setInterval(调用函数,[延迟的毫秒数]);  \nsetlnterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。\n\nwindow可以省略\n这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式。\n延迟的毫秒数省略默认为0，如果写，必须是毫秒。\n因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。\n\n停止setInterval()定时器window.clearInterval（interval ID）\n\nwindow可以省略\n里面的参数就是定时器的名字\n\nthisthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象\n\n全局作用域或者普通函数中this指向全局对象window、\n方法调用中谁调用就指向谁\n\nJS执行机制JS是单线程Javascript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——Javascript是为处理页面中用户的交互以及操作DOM而诞生的。\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n同步和异步为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是JS出现了同步和异步。\n\n同步任务：同步任务都在主线程上执行，形成一个执行栈。\n异步任务：JS的异步是通过回调函数实现的。一般而言，异步事件有以下三种类型：\n普通事件：如click，resize\n资源加载：如load，error\n定时器：如setInterval，setTimeout\n\n\n\n执行机制1.先执行执行栈中的同步任务\n2.异步任务放入任务队列\n3.一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。\nlocation对象location对象概述window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以解析URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。\nURL统一资源定位符（Uniform Resource Locator，URL）是互联网上标准资源的地址。互联网上的每个文件都有唯一的一个URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。\nURL的一般语法格式为：\nprotocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment\n如http://www.itcast.cn/index.html?name=andy&amp;age=18#link\n\nprotocol：通信协议 常用的http，ftp，maito\nhost：主机（域名）\nport：端口号 可选，省略时使用方案的默认端口 如http的默认端口为80\npath：路径 由0或多个&#x2F;符号分割开的字符串，一般用来表示主机上的一个目录或文件地址\nquery：参数 以键值对的形式，通过&amp;符号分开\nfragment：片段 #后内容常见于锚点 链接\n\nlocation对象的属性\nlocation.href：获取或设置整个URL\nlocation.host：返回主机（域名）\nlocation.port：返回端口号 如果未写返回 空字符串\nlocation.pathname：返回路径\nlocation.search：返回参数\nlocation.hash：返回片段 #后面内容\n\nlocation对象的方法\nlocation.assign()：跟href一样，可以转跳页面\nlocation.replace()：替换当前页面，因为不记录历史，所以不能后退页面。\nlocation.reload()：重新加载当前页面，相当于刷新按钮或者F5如果参数为true 强制刷新ctrl+f5\n\nnavigator对象navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送的user-agent头部的值。\n下面前端代码可以判断用户哪个终端打开界面，实现转跳：\nif((navigator.userAgent.match(&#x2F;(phone|pad|pod|iPhone|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|WOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)&#x2F;i))){\nwindow.location.href&#x3D;””; &#x2F;&#x2F;手机\n}else{window.location.href&#x3D;””;&#x2F;&#x2F;电脑\n}\nhistory对象window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL\n\nhistory.back()可以使用后退功能\nhistory.forward()前进功能\nhistory.go(参数)前进后退功能 参数如果是1前进一个页面，如果是-1 后退一个页面。\n\nPC端网页特效元素偏移量offset系列概述offset翻译过来就是偏移量，我们使用offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。\n\n获得元素距离带有定位父元素的位置\n获得元素自身的大小（宽度高度）\n注意：返回的数值都不带单位\n\noffset系列常用属性：\n\nelement.offsetParent：返回作为该元素带有定位的父级元素 如果父级都没有定位则返回body\nelement.offsetTop：返回元素相对带有定位父元素上边框的偏移\nelement.offsetLeft：返回元素相对带有定位父元素左边框的偏移\nelement.offsetWidth：返回自身包括padding、边框、内容区的宽度，返回值不带单位\nelement.offsetHeight：返回自身包括padding、边框、内容区的高度，返回值不带单位\n\noffset和style区别offset\n\noffset可以得到任意样式表中的样式值\noffset系列获得的数值是没有单位的\noffsetWidth包含padding+border+width、\noffsetWidth等属性是只读属性，只能获取不能赋值\n所以，我们想要获取元素的大小位置，用offset更为合适。\n\nstyle\n\nstyle只能得到行内样式表中的样式值\nstyle.width获得的是带有单位的字符串\nstyle.width获得不包括padding和border的值\nstyle.width是可读写属性，可以获取也可以赋值\n所以，我们想要给元素更改值，则需要用style改变\n\n元素可视区client系列概述client即为客户端，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。\n系列属性\nelement.clientTop\t返回元素上边框的大小\nelement.clientLeft\t返回元素左边框的大小\nelement.clientWidth  返回自身包括padding、内容区的宽度、不含边框、返回数值不带单位\nelement.clientHeight  返回自身包括padding、内容区的高度、不含边框、返回数值不带单位\n\n立即执行函数(function(){})()\t或\t(function(){}())\n主要作用：创建一个独立的作用域。\n最后的小括号可以视为调用函数\n元素scroll系列属性概述scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。\n属性\nelement.scrollTop\t返回被卷去的上侧距离，返回数值不带单位。\n\nelement.scrollLeft     返回被卷去的左侧距离，返回数值不带单位。\n\nelement.scrollWidth   返回自身实际的宽度，不含边框，返回数值不带单位。\n\nelement.scrollHeight    返回自身实际的高度，不含边框，返回数值不带单位。\n\n\n三大系列总结\noffset系列 经常用于获得元素位置\nclient系列  经常用于获取元素大小\nscroll系列   经常用于获取滚动距离\n注意页面滚动过的距离通过window.pageXoffset获得\n\n动画函数封装动画函数原理1.获得盒子当前位置\n2.让盒子在当前位置加上一个移动距离。\n缓动动画公式（目标值-现在的位置）&#x2F;10\n但是呢会出现小数就要用Math.ceil()往上取整。（注意负数就要向下取整Math.floor()）\n数据可视化数据可视化主要是借助图形化手段，清晰有效地传达与沟通信息。\n数据可视化的场景\n通用报表\n移动端图表\n大屏可视化\n图编辑&amp;图分析\n地理可视化\n\n项目目的市场需求：应对现在数据可视化的趋势，越来越多企业需要在很多场景（营销数据，生产数据，用户数据）下使用，可视化图表来展示体现数据，让数据更加直观。\n项目技术\nHTML5+CSS3布局\n\nCSS3动画、渐变\n\njQuery库+原生Javascript\n\nflex布局和rem适配方案\n\n图片边框border-image\n\nES6模板字符\n\nECharts可视化库等\n\n\nEChartsECharts是一个使用Javascript实现的开源可视化库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器，底层依赖矢量图形库ZRender，直观、交互丰富，可高度个性化定制的数据可视化图表。\nECharts使用五步曲步骤1.下载并引入echarts.js文件——图表依赖这个js库\nvar name&#x3D;echarts.init（document.queryselector(“div”))\n步骤2.准备一个具备大小的DOM容器——生成的图表会放入这个容器\n步骤3.初始化echarts实例对象——实例化echarts对象\n步骤4.指定配置项和数据——根据具体需求修改配置选项\n步骤5：将配置项设置给echarts实例对象——让echarts对象根据修改好的配置生效\n适配方案flexible.js——检测浏览器宽度，修改html文字大小。\nrem单位——页面元素根据rem适配大小配合cssrem插件\nflex布局\n边框图片这个是css3的\n相当于你空洞骑士里面的那个花边\n边框图片语法\nborder-image-source——用于边框图片的路径\nborder-image-slice——图片边框向内偏移（裁剪的尺寸，不加单位）\nborder-image-width——图片边框的宽度（不是边框的宽度是边框图片的宽度）加单位\nborder-image-repeat——图片是否平铺、铺满、拉伸。\n\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"TailwindCSS","url":"/2023/06/29/TailwindCSS/","content":"Tailwindcss介绍Tailwindcss是一种简单好用的css框架，我们在项目中经常遇见只需要赋一次样式的div。\n要么在div上写class后再到css部分去修改样式，这样会相当麻烦（前端人想要6块屏幕呜呜呜），需要上下滑动或者分屏什么什么的。\n要么就在div中使用style去进行修改，但是这样会有两个问题：一个是div中的style不可以配合vscode的插件进行一个自动补全，需要自己去记。另一个是很长很繁杂。\nTailwindcss就可以解决这样的问题，灵活、没有运行时的负担。\n配置很简单，配置和学习使用半小时可以完成。\nTailwindcss快速入门Framework Guides - TailwindCSS中文文档 | TailwindCSS中文网\n此处点击选择进入相应的前端框架（我使用的Vite，然后呢进去有vue和react，一开始我没看见用的react配置，然后就没成。）\n然后文档写得很详细了，缺点是他的中文文档似乎没有完全中文化，需要自己进行一个翻译。\n大概使用就是\n&lt;h1 class=&quot;text-3xl font-bold underline&quot;&gt;Home&lt;/h1&gt;\n\n这样子使用，class里是配置。\n具体什么配置怎么用也写得很清楚了，不会可以在官网查看。\n","categories":["工具使用"],"tags":["前端","工具","速通"]},{"title":"TypeScript","url":"/2024/01/30/TypeScript/","content":"TypeScript前言：很久之前就想着学Typescript了，但是一直在嘴上说没有时间学，说是没有但实际上学习这个也不会花费太久时间，只要肯挤时间并强制去完成就肯定可以完成。\nTypeScript 中文手册 \nTS其实就是JS Plus，笔记中只写我觉得和JS不一样的很多的地方详细需要自己参考文档。\nTypeScript相比JS的优势\n更早(写代码的同时)发现错误，减少找Bug、改Bug时间，提升开发效率。\n程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。\n强大的类型系统提升了代码的可维护性，使得重构代码更加容易。\n支持最新的ECMAScript语法，优先体验最新的语法，让你走在前端技术的最前沿。\nTS类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。除此之外，Vue 3源码使用TS重写、Angular默认支持TS、React与TS完美配合，TypeScript已成为大中型前端项目的首先编程语言。\n\n安装TypeScript有两种主要的方式来获取TypeScript工具：\n\n通过npm（Node.js包管理器）\n安装Visual Studio的TypeScript插件\n\nVisual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。\n针对使用npm的用户：\nnpm install -g typescript\n\nTS中的高级功能类型注解TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望greeter函数接收一个字符串参数。 然后尝试把greeter的调用改成传入一个数组：\nfunction greeter(person: string) &#123;    return &quot;Hello, &quot; + person;&#125;let user = [0, 1, 2]; document.body.innerHTML = greeter(user);\n\n重新编译，你会看到产生了一个错误。\nerror TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;.\n\n类似地，尝试删除greeter调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。\n接口让我们开发这个示例应用。这里我们使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用implements语句。\ninterface Person &#123;    firstName: string;    lastName: string;&#125;function greeter(person: Person) &#123;    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;&#125;let user = &#123; firstName: &quot;Jane&quot;, lastName: &quot;User&quot; &#125;;document.body.innerHTML = greeter(user);\n\n因为我对type对象不是很了解（看完这些文章之后感觉到tasklist有些语句需要规范化了orz），这里也补充一下type&amp;interface的知识：\n类型别名 type 和 接口 interface 区别与联系\n\n不同点：\n\n类型别名type用来给一个类型起个新名字，接口interface是命名数据结构（例如对象）的另一种方式\n\ntype可以用来表示基本类型、对象类型、联合类型、元组和交集；interface仅限于描述对象类型\n\ninterface 定义重名了会合并属性，type 会报错\n\ninterface 可以 extends， type 是不允许 extends ，但是 type 缺可以通过交叉类型 实现 interface 的 extend 行为，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 与 interface 类型 交叉\n\n\n\n相同点：\n\n都可以描述 Object和Function\n\ninterface 和 type 都可以继承。\n\n\n\n\n类最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。\n让我们创建一个Student类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。\n还要注意的是，在构造函数的参数上使用public等同于创建了同名的成员变量。\nclass Student &#123;    fullName: string;    constructor(public firstName: string, public middleInitial: string, public lastName: string) &#123;        this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName;    &#125;&#125;interface Person &#123;    firstName: string;    lastName: string;&#125;function greeter(person : Person) &#123;    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;&#125;let user = new Student(&quot;Jane&quot;, &quot;M.&quot;, &quot;User&quot;);document.body.innerHTML = greeter(user);\n\n基础类型枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;\n\n默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从1开始编号：\nenum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;\n\n或者，全部都采用手动赋值：\nenum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green;\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\nenum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];alert(colorName);  // 显示&#x27;Green&#x27;因为上面代码里它的值是2\n\n任意值有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量\nlet list: any[] = [1, true, &quot;free&quot;];\n\nNevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。\n下面是一些返回never类型的函数：\n// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123;    throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123;    return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123;    while (true) &#123;    &#125;&#125;\n\n类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n类型断言有两种形式。 其一是“尖括号”语法：\nlet someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;\n\n另一个为as语法：\nlet someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length;\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。\n变量声明let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的，let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。\n因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替var。\n作用域规则对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：\nfunction f(shouldInitialize: boolean) &#123;    if (shouldInitialize) &#123;        var x = 10;    &#125;    return x;&#125;f(true);  // returns &#x27;10&#x27;f(false); // returns &#x27;undefined&#x27;\n\n有些读者可能要多看几遍这个例子。 变量x是定义在*if语句里面，但是我们却可以在语句的外面访问它。 这是因为var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为var作用域或函数作用域*。 函数参数也使用函数作用域。\n变量获取怪异之处快速的猜一下下面的代码会返回什么：\nfor (var i = 0; i &lt; 10; i++) &#123;    setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125;\n\n介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n好吧，看一下结果：\n10101010101010101010\n\n很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n0123456789\n\n还记得我们上面讲的变量获取吗？\n\n每当g被调用时，它都可以访问到f里的a变量。\n\n让我们花点时间考虑在这个上下文里的情况。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出10！\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：\nfor (var i = 0; i &lt; 10; i++) &#123;    // capture the current state of &#x27;i&#x27;    // by invoking a function with its current value    (function(i) &#123;        setTimeout(function() &#123; console.log(i); &#125;, 100 * i);    &#125;)(i);&#125;\n\n这种奇怪的形式我们已经司空见惯了。 参数i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。\nlet声明块作用域当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。\n重定义及屏蔽我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。\nfunction f(x) &#123;    var x;    var x;    if (true) &#123;        var x;    &#125;&#125;\n\n在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，let声明就不会这么宽松了。\nlet x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x`\n\n并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。\nfunction f(x) &#123;    let x = 100; // error: interferes with parameter declaration&#125;function g() &#123;    let x = 100;    var x = 100; // error: can&#x27;t have both declarations of &#x27;x&#x27;&#125;\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\nfunction f(condition, x) &#123;    if (condition) &#123;        let x = 100;        return x;    &#125;    return x;&#125;f(false, 0); // returns 0f(true, 0);  // returns 100\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用let重写之前的sumMatrix函数。\nfunction sumMatrix(matrix: number[][]) &#123;    let sum = 0;    for (let i = 0; i &lt; matrix.length; i++) &#123;        var currentRow = matrix[i];        for (let i = 0; i &lt; currentRow.length; i++) &#123;            sum += currentRow[i];        &#125;    &#125;    return sum;&#125;\n\n这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\nlet和const用哪个现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用const也可以让我们更容易的推测数据的流动。\n另一方面，用户很喜欢let的简洁性。 这个手册大部分地方都使用了let。\n解构数组最简单的解构莫过于数组的解构赋值了：\nlet input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2\n\n这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：\nfirst = input[0];second = input[1];\n\n解构作用于已声明的变量会更好：\n// swap variables[first, second] = [second, first];\n\n作用于函数参数：\nfunction f([first, second]: [number, number]) &#123;    console.log(first);    console.log(second);&#125;f(input);\n\n你可以在数组里使用...语法创建剩余变量：\nlet [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]\n\n当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：\nlet [first] = [1, 2, 3, 4];console.log(first); // outputs 1\n\n或其它元素：\nlet [, second, , fourth] = [1, 2, 3, 4];\n\n对象解构你也可以解构对象：\nlet o = &#123;    a: &quot;foo&quot;,    b: 12,    c: &quot;bar&quot;&#125;;let &#123; a, b &#125; = o;\n\n这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。\n就像数组解构，你可以用没有声明的赋值：\n(&#123; a, b &#125; = &#123; a: &quot;baz&quot;, b: 101 &#125;);\n\n注意，我们需要用括号将它括起来，因为Javascript通常会将以 &#123; 起始的语句解析为一个块。\n你可以在对象里使用...语法创建剩余变量：\nlet &#123; a, ...passthrough &#125; = o;let total = passthrough.b + passthrough.c.length;\n\n属性重命名你也可以给属性以不同的名字：\nlet &#123; a: newName1, b: newName2 &#125; = o;\n\n这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1“。 方向是从左到右，好像你写成了以下样子：\nlet newName1 = o.a;let newName2 = o.b;\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\nlet &#123;a, b&#125;: &#123;a: string, b: number&#125; = o;\n\n默认值默认值可以让你在属性为 undefined 时使用缺省值：\nfunction keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;    let &#123; a, b = 1001 &#125; = wholeObject;&#125;\n\n现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。\n函数声明解构也能用于函数声明。 看以下简单的情况：\ntype C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123;    // ...&#125;\n\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\nfunction f(&#123; a, b &#125; = &#123; a: &quot;&quot;, b: 0 &#125;): void &#123;    // ...&#125;f(); // ok, default to &#123; a: &quot;&quot;, b: 0 &#125;\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\nfunction f(&#123; a, b = 0 &#125; = &#123; a: &quot;&quot; &#125;): void &#123;    // ...&#125;f(&#123; a: &quot;yes&quot; &#125;); // ok, default b = 0f(); // ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0f(&#123;&#125;); // error, &#x27;a&#x27; is required if you supply an argument\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n展开展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\nlet first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];\n\n这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了first和second的一份浅拷贝。 它们不会被展开操作所改变。\n你还可以展开对象：\nlet defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;\n\nsearch的值为&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\nlet defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; food: &quot;rich&quot;, ...defaults &#125;;\n\n那么，defaults里的food属性会重写food: &quot;rich&quot;，在这里这并不是我们想要的结果。\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：\nclass C &#123;  p = 12;  m() &#123;  &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error!\n\n","categories":["技术栈"],"tags":["笔记","前端"]},{"title":"VUE","url":"/2023/06/24/VUE/","content":"&#x3D;&#x3D;更多是直接看文档&#x3D;&#x3D;\nWebpack前端工程化（本来记录这个没什么意义，但是很符合我，就记下来了）\n实际的前端开发：\n\n模块化（js的模块化，css模块化，资源的模块化）\n组件化（复用现有的UI结构、样式、行为）\n规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理）\n自动化（自动化构建、自动部署、自动化测试）\n\n而不是一开始所以为的缺什么组件或API直接去拿\n概念webpack是前端项目工程化的具体解决方案\n它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端Js的兼容性、性能优化等强大功能\n&#x3D;&#x3D;P3待完成&#x3D;&#x3D;\nVue2.0vue简介Vue是一套用于构建用户界面的前端框架。\nVue框架的特性，主要体现在如下两个方面：\n数据驱动视图在使用了vue的界面中，vue会监听数据的变化，从而自动重新渲染页面的结构。即当页面数据发生变化时，页面会自动重新渲染。\n双向数据绑定在填写表单时，双向数据绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中。开发者不需要再手动操作来获取表单元素的最新值。\nVue的基本使用\n导入Vue.js的script脚本文件\n在页面中声明一个将要被Vue控制的DOM区域\n创建vm实例对象\n\nVue的指令和过滤器&#x3D;&#x3D;过滤器只能在Vue2.x使用&#x3D;&#x3D;\n指令指令时Vue为开发者提供的模板语法，用于辅助者渲染界面的基本结构\nVue中的指令按照不同的用途可以分为如下6大类：\n\n内容渲染指令\n\nv-text           覆盖原有的指令\n双括号                插值\nv-html           渲染含有标签的文本\n\n\n属性绑定指令\n\n如果需要为元素的属性动态绑定属性值，则需要用到v-bind属性绑定指令。可以简写成冒号：\n\n\n事件绑定指令\n\nv-on用于绑定事件，简写@，事件修饰符可以快速完成methods中定义的某些函数\n常见的事件修饰符有：.stop阻止冒泡，.prevent阻止默认事件，.capture添加事件侦听器时使用事件捕获模式，.self只当事件在该元素本身触发时回调，.once事件只触发一次\n\n\n双向绑定指令\n\nv-model\n\n\n条件渲染指令\n\nv-if&#x2F;v-show\n\n\n列表渲染指令\n\n\n过滤器过滤器是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式 和 v-bind 属性绑定\n和 el data methods 同级，filters 为过滤器，本质上还是一个函数，过滤器中，必须要有一个返回值\n芝士私有过滤器\n全局过滤器可以让任何一个vue实例使用\n怎么定义呢？\nVue.filter(‘过滤器名称’,(str)&#x3D;&gt;{balabalabala})\n侦听器和 el data methods 同级，watch 为侦听器 可以随时观察数据变化 定义时用data中的数据定义 表示的是“如果改变就”\n如果是data中的对象的对象 那定义时就是 单引号 对象.对象 单引号 这样\n计算属性计算属性指的时通过一系列运算之后，最终得到一个属性值。\n这个动态计算出来的属性值可以被模板结构或methods方法使用\n和 el data methods 同级，computed 为计算属性\nAxios方法类似于Ajax 多了一个params用于传参 和data一样 data用不了就用params\n这个的话 我有点不理解 好像用到了 es6 的语法 \n我干脆抄一段现成的代码下来吧 以后对着改 \ndocument.querySelector(“#btnPOST”).addEventListener(‘click’,&#x3D;&#x3D;async&#x3D;&#x3D; fucntion(){const { data: res } &#x3D; &#x3D;&#x3D;await&#x3D;&#x3D; axios.post(“URL”,{ JSON })console.log(res)}) \n生命周期\n生命周期又名生命周期回调函数、生命周期函数、生命周期钩子\n\n它是Vue在关键时刻帮我们调用的一些特殊名称的函数\n\n生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\n\n生命周期函数中的this指向是vm 或 组件实例对象\n\n挂载流程new一个vue \n然后初始化生命周期和事件\n\nbeforeCreate: 但此时数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法\n\n然后初始化数据监测和数据代理\n\ncreated: 这个时候就可以通过vm访问到data中的数据、methods中的方法\n\n然后Vue开始解析你的模板 \n\n就是你.vue文件中的script，但此时页面还不能显示解析好的内容\n\n\n会判断有无el，无就看$amount()\n会判断有无template(和直接挂载不同 这个会直接把目标标签也给杀死)，无就不管\n\n\nbeforeMount: 此时页面显示的是未经Vue编译的DOM结构\n此时所有对DOM的操作，最终都不奏效\n\n然后Vue 将内存中 虚拟的DOM转化为 真实的DOM 插入页面\n\nmounted: 此时页面中显示的是经过Vue编译的DOM\n对DOM的操作均有效（尽可能避免）。至此初始化过程结束，一般在此开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作\n\n更新流程\n此时Vue处于Mounted 挂载中的状态 \n\n当页面数据更新\n\nbeforeUpdata: 此时：数据是新的，但页面是旧的，即：页面尚未和数据保持同步。\n\n根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，即：完成了Model &#x3D;&gt; View的更新\n\nupdated: 此时：数据是新的，页面也是新的，即：页面和数据保持同步\n\n销毁流程当遇见.$destory()时\n\nbeforeDestory: 此时vm中的所有的：data、methods、指令等等，都处于可用状态，即将执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾工作。\n\n然后移出所有的侦听器、子组件、事件监听器\n单页面应用程序单页面应用程序 简称 SPA，顾名思义，指的是一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能与交互都在这唯一的一个页面内完成。\nVUE组件巧妙了解组件的优点：\n传统方法编写应用\n\n依赖关系混乱、不好维护\n代码复用率不高\n\n\n比如你写的一些footer啊之类的 之前的操作就是新建一个页面就复制粘贴HTML 再对应的引用CSS文件和JS文件\n这样就比较混乱 不好管理  而Vue就是为了解决这个的 它是提供一个框架 把做项目所需要用到的都给我们搭建出来\n\nvue组件的三个组成部分每个.vue组件都由 3 部分组成，分别是：\n\ntemplate -&gt; 组件的模板结构\nscript -&gt; 组件的JavaScript\nstyle -&gt; 组件的样式\n\n组件的父子关系\n组件在被封装好之后，彼此之间是相互独立的，不存在父子关系。\n在使用组件时，根据彼此的嵌套关系，形成了父子关系、兄弟关系。\n\n使用组件的三个步骤\n使用 import 语法导入需要的组件\n使用 components 节点注册\n通过 components 注册的是 私有子组件，即在 组件A 的 components 节点下，注册了 组件F 。则 组件F 只能用于 组件A 不能用于 组件C\n\n\n以 标签形式 使用刚才的注册的组件\n\n注册全局组件在vue项目的 main.js 入口文件中，通过 Vue.component()方法 \n组件的propsprops 是组件的自定义属性，在封装通用组件的时候，合理的使用 props 可以极大的提高组件的复用性\nVUE-CLI(脚手架)cli &#x3D; command + line + interface.\nvue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程\n使用vue cerate 项目的名称\nvue中src目录的构成\nassets 文件夹：存放项目用到的静态资源文件，例如css样式表、图片资源\ncomponents 文件夹：程序员封装的、可复用的组件\nmain.js 是项目的入口文件。整个项目的运行，要先执行main.js\n\nvue项目的运行流程在工程化的项目中，vue要做的事情非常单纯：通过main.js 把 App.vue 渲染到 index.html 的指定区域中\nrender函数在 import vue from ‘vue’ 时，我们会引用到不完整的、残缺的vue文件 （当然vue.js是完整的）\n缺什么呢 缺的就是 模板解析器 （作用就是 把你的东西渲染到主页面上） 这时候就需要render函数来帮忙\n修改默认配置在 vue.config.js 里面是可以写对脚手架的默认修改的，具体可以阅读文档\n插件在 main.js 同目录下创建，本质是 对象 ，需要使用 install 安装\n使用 Vue.use( 插件名 )\n组件化编码流程（通用）实现静态组件抽取组件，使用组件实现静态页面效果\n全局事件总线实现实现任意组件之间的通信\n安装全局事件总线\n new Vue(&#123;beforeCreate()&#123;\tVue.prototype.$bus = this&#125;&#125;)\n\n使用全局事件总线\n$bus.$emit 传参$bus.$on 接收\n\n\n\n插槽Vuexvuex是专门在Vue中实现集中式状态管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理，也是一种组件间通信的方式，且适用于任意组件间通信\n当多个组件依赖于同一状态，来自不同组件的行为需要变更同一状态时我们启用Vuex\n路由一个路由就是一组映射关系\nkey 为路径，value 可能是 function 或 component \n路由分类\n后端路由：\n\nvalue 是 function ，用于处理客户端提交的请求。\n\n服务器接收到一个请求时\n\n\n\n前端路由：\n\nvalue 是 component，用于展示页面。\n当浏览器的路径发生改变时，对应的组件就会显示。\n\n\n\n路由的基本使用引用 vue-router 组件并新建一个router文件夹用于存放index.js 写路由器\n创建并暴露一个路由器\nexport default new Vue Router(&#123;\troutes:[\t\t&#123;\t\t\tpath:&#x27;/路径&#x27;,\t\t\tcomponent:组件\t\t&#125;,\t\t&#123;\t\t\t//嵌套路由的话\t\t\tpath:&#x27;/路径&#x27;,\t\t\tcomponent:组件,\t\t\tchildren:[\t\t\t&#123;\t\t\t\tpath:&#x27;路径&#x27;,\t\t\t\tcomponent:组件\t\t\t&#125;\t\t\t]\t\t&#125;\t]&#125;)\n\n并在点击切换的 a标签 处改为 router-link 并将 href 改为 to&#x3D;”&#x2F;路径” 这样的写法\nVue3.0setup函数Vue3中一个新的配置项，值为一个函数。\nsetup 是所有Composition API（组合API）\n组件中使用的 数据 方法 皆需要配置在 setup 中\nsetup若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。\nsetup尽量不要与Vue2.x配置混用\nref函数传参的时候 如\nlet name = ref(&#x27;张三&#x27;)let job = ref(&#123;\ttype:&#x27;123&#x27;,\tepyt:&quot;321&quot;&#125;)\n\n这个时候就需要用到ref函数 \nreactive函数定义一个对象类型的响应式数据（基本类型不用，用ref函数）\n语法 const 代理对象 = reactive(源对象) 接收一个对象（或数组），返回一个代理对象（Proxy对象）\nreactive定义的响应式数据是“深层次”的\n","categories":["技术栈"],"tags":["笔记","迁移","前端"]},{"title":"Vue.Config","url":"/2023/11/13/Vue.Config/","content":"每次新建项目都得配置不少东西，在这里标记一下防止遗忘。\nVite框架项目创建npm create vite@latestnpm installnpm run dev//(别忘记在package.json中&quot;scripts&quot;对象中&quot;dev&quot;后面把&quot;vite&quot;改成&quot;vite --open&quot;)\n\nVue Router路由安装npm install vue-router@4//安装后别忘记在src下新建一个router子文件夹和index.js、routes.js子文件\n\nindex.js（直接复制粘贴即可）// 导入router所需的方法import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;// 导入路由页面的配置import routes from &#x27;./routes.js&#x27;// 路由参数配置const router = createRouter(&#123;    // 使用hash(createWebHashHistory)模式，(createWebHistory是HTML5历史模式，支持SEO)    history: createWebHistory(),    routes: routes,&#125;)// 全局前置守卫，这里可以加入用户登录判断router.beforeEach((to, from, next) =&gt; &#123;    // 继续前进 next()    // 返回 false 以取消导航    next()&#125;)// 全局后置钩子，这里可以加入改变页面标题等操作router.afterEach((to, from) =&gt; &#123;    // const _title = to.meta.title    // if (_title) &#123;    //     window.document.title = _title    // &#125;&#125;)// 导出默认值export default router\n\nroutes.js（直接复制粘贴即可）const routes = [    &#123;        path: &#x27;/&#x27;,        name: &#x27;HOME&#x27;,        component: () =&gt; import(&#x27;&#x27;)    &#125;]export default routes\n\n//最后就是别忘记在main.js里添加引入依赖import router from &#x27;./router/index.js&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;)//.use(router)\n\n","categories":["技术栈"],"tags":["前端"]},{"title":"Postman","url":"/2023/06/24/Postman/","content":"接口接口简介接口：就是软件提供给外部的一种服务。用作数据传输。 在硬件方面USB、投影机被称为接口，在软件方面统称API，如微信的支付和提现。（统称鉴权码，有token、key、appkey）\n内部接口：开发人员自己开发的对自身系统提供的接口\n外部接口：开发系统调用外部的，微信、支付宝，其它的接口\n接口测试的本质：就是测试接口能否正常的交互数据，权限控制以及异常场景。\n软件为什么需要接口因为接口能够让内部的数据被外部进行修改\n为什么要做接口测试\n现在很多系统都是前后端分离，开发的进度不一样，需要把一开始开发出来的接口进行测试\n基于安全考虑，前端有验证很容易绕过，直接请求接口\n测试推崇的是测试左移，即尽早测试。\n\n接口测试的简介和分类接口测试就是测试系统组件接口之间的一种测试\n分类：\n\n测试外部接口：测试被测系统和外部系统之间的接口（只需要测试正例即可）\n测试内部接口：\n内部接口只提供给内部系统使用。（预算系统，承保系统）（只需要测试正例即可）\n内部接口提供给外部系统使用（测试必须非常全面）\n\n\n\n接口测试的流程以及用例的设计\n拿到接口api文档（通过抓包工具获取），熟悉接口业务，接口地址，鉴权方式，入参，码\n编写接口用例以及评审\n使用接口测试工具Postman实现接口测试\nPostman-+Newman+Jenkins实现持续集成，并且输出测试报告并且发送邮件，并且输出测试报告并且发送邮件\n\n接口返回数据和JSON详解\njson格式：三组数据\n{error_code:0,msg:”0”,data:[]}\nerror_code:错误码\nmsg:对错误码的中文说明\ndata：真正的返回的数据\n\n\njsonj就是一种数据类型，整形，小数，字符串\nJSON由两组数据组成\nMAP对象，键值对\n数组\n\n\n\nPostman界面介绍\nHome主页\nworkspaces 工作空间\nCollections 项目集合\nApiS api文档\nEnvironments 全局变量\nMock Server 虚拟服务器\nMonitors 监听器\nHistory 历史记录\n\n\n\n常见的请求头Accept常用，它的作用是：客户端接收的数据格式；\n比方说你的参数值填写的是application&#x2F;json，就说明浏览器所接收的数据是json类型的数据，当你加了Accept请求头之后，你会发现你得到的数据和你没有加Accept请求头的数据是完全不一样的。如果你没有加Accept这个请求头，你得到的数据可能就是一个简单的网页。Accept它可以影响你返回的数据。\nX-Requested-With它的作用是：异步请求；\n如果对开发有一定的了解的话，前端里面有这样一个技术Ajax异步请求。现在很多的功能都会用到这个异步请求，比如说登录。\n简单的举个列子：如果现在你想去上海，只有一条路的话，你只能走唯一的一条路。那么如果有两条路或者多条路，可以坐飞机，高铁，汽车等等。那么它们就相当于异步，也就是说你可以通过飞机到上海，也可以坐高铁到上海，这样通俗的理解异步请求。\n异步请求的特点：无刷新。就是说登录的时候是需要进行页面跳转的，而异步请求它不需要跳转也可以做到这样的请求。\nUser-Aget它的作用是：发送请求的客户端的类型；\n比如说我们可以通过postman去发送请求类型，也可通过浏览器去发送请求等等，那么有的接口你通过非浏览器去请求它是无法通过的\nContent-type它的作用是：请求的报文格式；\nCookieCookie信息；\n有的接口需要登录之后才会生成Cookie信息，必须要保持登录的状态。这种情况我们就需要对Cookie信息进行管理。\nPostman执行接口测试请求页签\nParams：get请求传参\nauthorization：鉴权\nheaders：请求头\nBody：\npost  请求传参\nnone 没有参数\nform-data：既可以传键值对参数也可以传文件\nx-www-from-urlencoded：只能够传键值对参数\nraw：json，text，xml，html，javascript\nbinary：把文件以二进制的方式传参\n\n\npre-request-script：请求之前的脚本\ntests：请求之后的断言\ncookies：用于管理cookie信息\n\n响应页签\nBody：接口返回的数据\nPretty：以Json、html、XML…不同格式查看返回的数据\nRaw：以文本的方式查看返回的数据\nPreView：以网页的方式查看返回的数据\n\n\nCookies：响应的cookies信息\nHeaders：响应头\nTest Results：断言的结果\n200是状态码 Ok是状态信息 681MS是响应的时间  343B是响应的字节数\n\n环境变量和全局变量可以在Environments那里设置不同情况的环境\n比如开发环境、测试环境、生成环境\n并且使用来使用你的环境\n比如：https:&#x2F;&#x2F;&#x2F;路径\n然后再在右上角选择你需要的环境即可\n环境变量：环境变量就是全局变量\n全局变量：全局变量就是能够在任何接口里面访问的变量\n接口关联\njson提取器实现接口关联\n在请求页签：Tests中使用var 变量名&#x3D;JSON.parse(responseBody)，json提取器将得到数据提取成json格式，这样可以设置一个全局变量，然后使用\n\n\n使用正则表达式提取器实现接口关联\n在请求页签：Tests中使用var 变量名&#x3D;responseBody.match(new RegExp(‘复制Raw并把Value改为(*?)’))，这样可以设置一个全局变量，然后使用（记得是变量名[1]）\n\n\n\npostman内置动态参数以及自定义的动态参数\n          生成当前时间的时间戳\n          生成0-1000之间的随机数\n                   生成速记GUID字符串\n\n","categories":["工具使用"],"tags":["迁移","前端","工具"]},{"title":"Canvas","url":"/2023/07/21/Canvas/","content":"canvas画布使用——CSS进阶​\t\t在大一的时候学的一些高数、线性代数都可以用于canvas画布，所以还是很重要的，能好好学就好好学。\n​\t\t文章参考：在canvas上绘制3d图形 - 简书 (jianshu.com)(写得真的很好，少见的好文章)\n简单绘制三维图形​\t\t因为canvas是一个二维的东西，所以我们想要画出三维的图形就要考虑把这个三维图形给投影到二维上，进而给造成一种三维的错觉。所以首先需要学习的是如何表示三维坐标轴上的任意一个点。通过文章中的推导我们可以看到：\n​\t\t从空间内的任意点A(xA，yA，zA)观察空间内的任一点G(xG，yG，zG)，它在xy平面内的投影H的坐标为：\n​\t\t $x &#x3D; ((xG-xA)*zA)&#x2F;(zA-zG) ;  y &#x3D; ((yG-yA)*zA)&#x2F;(zA-zG)$\n三维图形 的旋转​\t\t对于一个图形，如果要对其进行y轴的旋转（从观察点更为明显且符合逻辑），则从y轴向下俯视xz平面可以使用一个极坐标的逻辑从而确定我们变换之后的坐标点。​\t\t主要就是确定每个点（控制旋转的是角度）\n\n​\t\t这个时候假定D点与x轴的夹角是α，圆的半径为R，将D点绕着y轴旋转β旋转至D’点，这个时候D’与x轴夹角为α+β，此时D’的x坐标为cos(α+β)*R，D’的z坐标为sin(α+β)*R\n​\tD’的x坐标:\n​\t\t$cos(α+β)R&#x3D;Rcosαcosβ-Rsinα*sinβ$\nD’的z坐标sin(α+β)R&#x3D;Rsinαcosβ+Rcosαsinβ而Rsinα就是旋转之前D点的z坐标，Rcosα就是旋转之前D点的x坐标，D’的x坐标为xcosβ-zsinβD’的z坐标为zcosβ+xsinβ将结论代入到我们的立方体的8个顶点ABCDEFGH中对于任一点D(xD，yD，zD)，其绕y轴旋转β角的时候，它的三维坐标变为(xDcosβ-zDsinβ，yD，zDcosβ+xD*sinβ)\n正弦曲线阵（含代码）​\t\t博客中写的是vue2的，我自己用的是vue3，所以以下是我已经写好的正弦曲线阵代码。\n&lt;canvas ref=&quot;wave&quot; :width=&quot;canvasWidth&quot; :height=&quot;canvasHeight&quot;&gt;&lt;/canvas&gt;\n\n//绘制正弦波浪canvasimport &#123; ref, watch &#125; from &#x27;vue&#x27;; const wave = ref(&#x27;&#x27;)const canvasWidth = ref(1920)const canvasHeight = ref(800)//构建一个结构体 方便后期绘制多条正弦曲线class Line &#123;    constructor (a, b, c, d, z, start, end, gap) &#123;        this.a = a        this.b = b        this.c = c        this.d = d  //以上四个控制正弦函数振幅周期之类的        this.z = z  //三维坐标        this.start = start //绘画开始点        this.end = end  //绘画结束点        this.gap = gap //间距        this.pointList = []        this.computePointList()    &#125;    computePointList () &#123;        this.pointList = []        for (let i = this.start; i &lt;= this.end; i = i + this.gap) &#123;            let x = i            let y = this.a * Math.sin((this.b * x + this.c) / 180 * Math.PI) + this.d   // 即y = A sin(ωx + φ) + B            let offset = i //偏移量用来让他运动            this.pointList.push(&#123;                x,                y,                z: this.z,                originX: x,                offset            &#125;)        &#125;    &#125;&#125;const lineList = [    new Line(20, 2, 0, 0, -390, -300, 300, 10),    new Line(20, 2, 0, 0, -360, -300, 300, 10),    new Line(20, 2, 0, 0, -330, -300, 300, 10),    new Line(20, 2, 0, 0, -300, -300, 300, 10),    new Line(20, 2, 0, 0, -270, -300, 300, 10),    new Line(20, 2, 0, 0, -240, -300, 300, 10),    new Line(20, 2, 0, 0, -210, -300, 300, 10),    new Line(20, 2, 0, 0, -180, -300, 300, 10),    new Line(20, 2, 0, 0, -150, -300, 300, 10),    new Line(20, 2, 0, 0, -120, -300, 300, 10),    new Line(20, 2, 0, 0, -90, -300, 300, 10),    new Line(20, 2, 0, 0, -60, -300, 300, 10),    new Line(20, 2, 0, 0, -30, -300, 300, 10),    new Line(20, 2, 0, 0, 0, -300, 300, 10),    new Line(20, 2, 0, 0, 30, -300, 300, 10),    new Line(20, 2, 0, 0, 60, -300, 300, 10),    new Line(20, 2, 0, 0, 90, -300, 300, 10),    new Line(20, 2, 0, 0, 120, -300, 300, 10),    new Line(20, 2, 0, 0, 150, -300, 300, 10),    new Line(20, 2, 0, 0, 180, -300, 300, 10),    new Line(20, 2, 0, 0, 210, -300, 300, 10),    new Line(20, 2, 0, 0, 240, -300, 300, 10),    new Line(20, 2, 0, 0, 270, -300, 300, 10),    new Line(20, 2, 0, 0, 300, -300, 300, 10),    ]//整个类的列表出来const draw = (visual) =&gt; &#123; //这是个绘制正弦点的函数    const context = wave.value.getContext(&quot;2d&quot;);    context.clearRect(0, 0, canvasWidth.value, canvasHeight.value) //清空像素    lineList.forEach(line =&gt; &#123;        line.pointList.forEach(item =&gt; &#123;            const pointSize = 1.5 * visual.z / (visual.z - item.z) //整个近大远小            context.beginPath()            context.arc(item.canvasX  + canvasWidth.value / 2, item.canvasY  + canvasHeight.value / 2, pointSize, 0, 2 * Math.PI) //arc(x, y, radius, startAngle, endAngle, counterclockwise);            context.closePath()            context.fill()        &#125;)    &#125;)&#125;const updatePointList = (rotationAngleSpeed, visual) =&gt; &#123; //这是个更新点的位置而使正弦函数移动的函数    lineList.forEach(line =&gt; &#123;        line.pointList.forEach(item =&gt; &#123;            let x = item.x            let z = item.z            item.x = x * Math.cos(rotationAngleSpeed / 180 * Math.PI) - z * Math.sin(rotationAngleSpeed / 180 * Math.PI)             item.z = z * Math.cos(rotationAngleSpeed / 180 * Math.PI) + x * Math.sin(rotationAngleSpeed / 180 * Math.PI)             item.y = line.a * Math.sin((line.b * item.originX + line.c + item.offset) / 180 * Math.PI) + line.d //绕y轴旋转所以y比较特别            item.canvasX = (item.x - visual.x) * visual.z / (visual.z - z)            item.canvasY = (item.y - visual.y) * visual.z / (visual.z - z)            &#125;)    &#125;)&#125;const animationFrame = (visual) =&gt; &#123; //正弦函数动画    window.requestAnimationFrame(() =&gt; &#123;        lineList.forEach((line,index) =&gt; &#123;            line.pointList.forEach(item =&gt; &#123;            line.c = item.offset + index * 30 //index控制偏移量更美观            item.offset = item.offset + 1            &#125;)            updatePointList(.003,visual)        &#125;)        draw(visual)        animationFrame(visual)    &#125;)&#125;//监听canvas标签创建、因为JS比标签创建更快，所以需要监听。watch(wave, (newValue, oldValue) =&gt; &#123;    const visual = &#123; //观察点设置        x: 0,        y: -70,        z: 500    &#125;    draw(visual);    animationFrame(visual)&#125;)\n\n","categories":["技术栈"],"tags":["前端"]}]