

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/fluid.png">
  <link rel="icon" href="/Blog/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="TaskManagerOL">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试问题集合">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview">
<meta property="og:url" content="https://taskmanagerol.github.io/Blog/2024/08/31/Interview/index.html">
<meta property="og:site_name" content="Don&#39;t Fall Asleep Now.">
<meta property="og:description" content="面试问题集合">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-31T16:17:29.000Z">
<meta property="article:modified_time" content="2025-06-28T09:36:18.161Z">
<meta property="article:author" content="TaskManagerOL">
<meta property="article:tag" content="😶‍🌫️">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Interview - Don&#39;t Fall Asleep Now.</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/Blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/Blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"taskmanagerol.github.io","root":"/Blog/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/Blog/atom.xml" title="Don't Fall Asleep Now." type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Don&#39;t Fall Asleep Now.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Blog/img/bg/bg-one.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Interview"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-31 16:17" pubdate>
          2024年8月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          265 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Interview</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2025-06-28T09:36:18+00:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h1><h2 id="简历准备"><a href="#简历准备" class="headerlink" title="简历准备"></a>简历准备</h2><p>Boss是不能先发送简历附件的，要填写线上简历+打招呼内容。（但是可以把简历转成图片发出去说是）</p>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>主要围绕在讲项目实习的经历，讲一些稍微有技术亮点且你会的东西。</p>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><p>我接下来分点且尽可能简明介绍。</p>
<p>操作系统是什么：他是一个管家，用来管理计算机的软硬件资源。</p>
<p>操作系统的核心功能：</p>
<ul>
<li>处理器(CPU)管理：操作系统合理安排任务的执行顺序，让CPU能够高效地处理各种任务，避免冲突。</li>
<li>内存管理：程序运行的时候需要操作系统分配合理的内存空间，也会回收内存。</li>
<li>设备管理：管理外部设备。</li>
<li>文件系统管理：操作系统提供了文件系统来存储和读取文件。</li>
</ul>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>举个例子吧：</p>
<p>有一个商场，商场里有很多店，有麦当劳，有书店。但是商场里的店有限，因为一个店要占很大的位置。有一天书店跳闸了，但是麦当劳还有电做麦旋风。第二天书店被抢劫了，但是麦当劳还是能做麦旋风。</p>
<p>上面这个例子中，店铺就是进程，他是资源分配的单位。店铺要占很大位置对应资源消耗大的特点，书店跳闸麦当劳不受影响对应隔离性的特点，抢劫对应安全性的特点。</p>
<p>接着举例子：</p>
<p>有一天，麦当劳收到一个麦旋风的订单，专送外卖员已经准备好了，但是麦旋风还没有做出来。我就吃不到麦旋风！！！</p>
<p>这里的制作麦旋风、送外卖就是线程，他是程序的具体执行。从上面例子可以看出，线程之间是相互影响的。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层协议与TCP-IP四层协议"><a href="#OSI七层协议与TCP-IP四层协议" class="headerlink" title="OSI七层协议与TCP&#x2F;IP四层协议"></a>OSI七层协议与TCP&#x2F;IP四层协议</h3><h4 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h4><p>OSI是开放系统互连参考模型，只是一个很常用的参考。</p>
<p>OSI有应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<p>物理层：负责实际运输数据的物理媒介，确保数据信号能够在物理介质（如电线、光纤等）上传输。</p>
<p>数据链路层：将物理层接收到的原始信号转换为数据帧，并进行错误检测和纠正，确保数据在相邻节点之间可靠地传输，同时利用 MAC 地址来标识不同的设备。</p>
<p>网络层：通过 IP 地址来标识不同的网络和设备，选择合适的路径将数据包从源节点发送到目标节点，并进行路由选择和寻址。</p>
<p>传输层：将数据分割成合适大小的段，并为每个段添加源端口和目的端口信息，以确保数据能够准确地发送到目标设备上的正确应用程序。同时，它还负责对数据进行错误检测和重传，保证端到端的可靠通信。</p>
<p>会话层：负责建立、维护和管理通信双方之间的会话连接。它允许不同的应用程序之间进行对话，并确保会话的正常进行和有序结束。</p>
<p>表示层：对数据进行加密、解密、压缩和解压缩等操作，确保数据在传输过程中的安全性和高效性，并将数据转换为适合应用程序使用的格式。</p>
<p>应用层：为用户和应用程序提供各种网络服务和接口，如电子邮件、文件传输、网页浏览等。它是用户与网络进行交互的最直接的一层。</p>
<p>有点麻烦，举个例子吧：</p>
<p>你网购了一个墩墩鸡抱枕，客服**(应用层)<strong>收到你的你的订单，对产品进行打包</strong>(表示层)<strong>，客服和快递员沟通</strong>(会话层)<strong>要寄出你的墩墩鸡，快递驿站对收到的好多包裹进行打包贴标签</strong>(传输层)<strong>，确保不会弄混，接着通过当地的转运站寄出</strong>(网络层)<strong>，当地转运站到下一个转运站要走系统规划好的路</strong>(数据链路层)<strong>，都确定好之后你的货车开始发车</strong>(物理层)**。</p>
<h4 id="TCP-IP四层协议"><a href="#TCP-IP四层协议" class="headerlink" title="TCP&#x2F;IP四层协议"></a>TCP&#x2F;IP四层协议</h4><p>四层协议是七层协议的简化。</p>
<p>其中：</p>
<p><strong>应用层</strong> + <strong>表达层</strong> + <strong>会话层</strong> &#x3D; <strong>应用层</strong></p>
<p>应用层常见的协议有：HTTP、FTP、SMTP</p>
<p><strong>传输层</strong> &#x3D; <strong>传输层</strong></p>
<p>传输层常见的协议有：TCP、UDP</p>
<p><strong>网络层</strong> &#x3D; <strong>网络层</strong></p>
<p><strong>数据链路层</strong> + <strong>物理层</strong> &#x3D; <strong>链路层</strong></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4><p>HTTP是超文本传输协议，是一个用于传输文本的协议，但是他不安全，容易被截取。</p>
<p>这个时候在HTTP加装一个SSL协议用于提供数据安全和完整性，SSL采用非对称加密算法，SSL会让服务器返回一个安全证书，证书内包含公钥，一并发给浏览器，浏览器对每次返回的数据进行公钥加密，服务器拿到数据包后进行私钥解密。</p>
<h4 id="HTTP内容"><a href="#HTTP内容" class="headerlink" title="HTTP内容"></a>HTTP内容</h4><p>HTTP 请求的内容包括请求行、请求头和请求体。</p>
<ul>
<li><code>请求行</code>：用于说明请求类型、要访问的资源以及使用的 HTTP 协议版本。</li>
<li><code>请求头</code>：包含一些发送请求时的附加信息，例如<code>Host</code>、<code>Accept-Encoding</code>、<code>Content-Type</code></li>
<li><code>请求体</code>：包含客户端发送给服务器的数据。</li>
</ul>
<p>HTTP 响应的内容包括响应行、响应头和响应体。</p>
<ul>
<li><code>响应行</code>：HTTP&#x2F;版本号+状态码</li>
<li><code>响应头</code>：包含一些返回数据的附加信息，比如<code>Date</code>、<code>Connection</code>、<code>Content-Type</code></li>
<li><code>响应体</code>：包含服务器返回的数据。</li>
</ul>
<h4 id="HTTP版本"><a href="#HTTP版本" class="headerlink" title="HTTP版本"></a>HTTP版本</h4><ul>
<li><code>HTTP/0.9</code>：1991年发布，只支持GET方法，没有版本号、请求头、响应头、状态码。</li>
<li><code>HTTP/1.0</code>：1996年发布<ul>
<li>添加POST方法等</li>
<li>添加版本号、请求头、响应头、状态码</li>
<li>连接不能复用，效率低。</li>
</ul>
</li>
<li><code>HTTP/1.1</code>：1997年发布<ul>
<li><strong>持久连接</strong> ：默认情况下，TCP 连接在一次请求 &#x2F; 响应后不会立即关闭，可以被多个请求 &#x2F; 响应复用，减少了建立和关闭连接的开销。</li>
<li><strong>管道化</strong> ：客户端可以在同一个连接上发送多个请求，而不用等待每个请求的响应返回，提高了效率，但服务器端仍需按顺序处理这些请求。</li>
<li><strong>主机头字段</strong> ：支持虚拟主机，通过 Host 请求头字段来区分不同的域名，使得在同一个 IP 地址上可以部署多个网站。</li>
</ul>
</li>
<li><code>HTTP/2</code>：2015年发布<ul>
<li><strong>二进制协议</strong> ：对数据传输进行了优化，将原本的文本形式改为二进制形式，减少了解析的开销。</li>
<li><strong>多路复用</strong> ：允许多个请求和响应可以同时在一个连接上交错传输，避免了 HTTP&#x2F;1.1 中的队头阻塞问题，大大提高了传输效率。</li>
<li><strong>头部压缩</strong> ：采用 HPACK 压缩算法对请求和响应的头部进行压缩，减少了头部信息所占用的网络带宽。</li>
<li><strong>服务器推送</strong> ：服务器可以主动推送一些客户端可能需要的资源到客户端，而无需客户端逐一请求，可以提前获取资源，优化了性能。</li>
</ul>
</li>
<li><code>HTTP/3</code>：2022年发布<ul>
<li><strong>基于 UDP 协议</strong> ：克服了 TCP 协议的一些限制，如慢启动、队列阻塞等，能够更快地建立连接并传输数据，适合实时性要求较高的场景。</li>
<li><strong>使用 QUIC 协议</strong> ：在 UDP 的基础上提供了像 TCP 一样的可靠性保证，同时具备低延迟、连接迁移等特性。即使客户端的网络环境发生变化（如从 Wi-Fi 切换到移动数据），连接也不会中断。</li>
<li><strong>进一步优化性能</strong> ：在 HTTP&#x2F;2 的基础上继续优化，如改进了头部压缩算法，进一步提高了传输效率。</li>
</ul>
</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p><code>1xx</code>：表示请求已被接受，需要继续处理。</p>
<p><code>2xx</code>：表示请求已成功被服务器接收、理解、并接受。</p>
<p><code>3xx</code>：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p><code>4xx</code>：表示客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
<p><code>5xx</code>：表示服务器无法完成明显有效的请求。</p>
<h4 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h4><p>一般来说使用GET是不带参数的，如果要带上参数的话，使用<code>URL 查询参数</code>来实现。如果要带上参数，常见的场景是搜索栏。因为GET带有的参数是显露在url中的，所以POST会相较于GET更加安全。他们本质上都是TCP连接，没有什么差别。</p>
<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><p>UDP，用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，他不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务，传输途中出现丢包，UDP 也不负责重发。当包的到达顺序出现乱序时，UDP没有纠正的功能。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。好处是快！很快！非常快！</p>
<p>TCP，传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送。TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。但是TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信。</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</p>
<ul>
<li><p>第一次握手：客户端发送网络包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的</p>
</li>
<li><p>第二次握手：服务端发包，客户端收到了。</p>
<p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</p>
</li>
<li><p>第三次握手：客户端发包，服务端收到了。</p>
<p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</li>
</ul>
<h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>DNS（Domain Name System，域名系统）协议是一种用于将域名转换为IP地址的网络协议。将易记的域名（如<code>example.com</code>）转换为计算机用于通信的IP地址（如<code>192.168.1.1</code>），方便用户记忆和访问网站。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅。</p>
<p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是用于解决不同问题的方案，所以如果掌握设计模式，可以在遇到不同问题的时候，拿出对应的解决方案。</p>
<h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>MVC是一种分层架构模式，广泛应用于前端和后端开发中，用于将应用程序的逻辑、数据和用户界面分离，以实现更好的代码组织和可维护性。</p>
<p>优点：可维护可复用，便于调试。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>模块模式是一种在 JavaScript 中实现代码封装和模块化的技术，常用于避免全局变量污染和实现私有化。它通过闭包来创建私有变量和方法，并提供一个公共接口以便外部访问模块的功能。模块模式的核心是将代码封装在一个独立的作用域中，同时允许外部访问模块的公共部分。</p>
<p>优点：封装性好、可维护性高。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，创建对象的过程被抽象出来，使得我们在创建对象时不需要指定具体的类，而是通过一个共同的接口或者抽象类来实现。这种模式主要关注对象的创建逻辑，将对象的创建过程封装起来，使得客户端可以在不指定具体类的情况下创建对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义产品接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Product&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Product</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ConcreteProductA&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Product</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ConcreteProductB&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createProduct</span>(<span class="hljs-params">type</span>) &#123;<br>    <span class="hljs-keyword">let</span> product;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductA</span>();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductB</span>();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>:<br>        product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> productA = <span class="hljs-title class_">SimpleFactory</span>.<span class="hljs-title function_">createProduct</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(productA.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出：ConcreteProductA</span><br><br><span class="hljs-keyword">const</span> productB = <span class="hljs-title class_">SimpleFactory</span>.<span class="hljs-title function_">createProduct</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(productB.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出：ConcreteProductB</span><br></code></pre></td></tr></table></figure>

<p>优点是封装性好，扩展性高，复用性也好；缺点是需要添加新的产品对象的时候需要修改工厂类的代码。</p>
<p>常见的实例：<code>写UI库的时候，创建不同类型的 UI 组件</code> <code>创建不同类型的对象实例</code></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一种常见的设计模式，确保一个类只有一个实例，并提供一个全局访问点，这个唯一的实例共享给所有需要使用它的组件。</p>
<p>在需要全局共享状态或资源的场景中。它确保一个类只有一个实例，并提供一个全局访问点。大部分场景还是很有用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span> = [];<br>    <span class="hljs-title class_">Logger</span>.<span class="hljs-property">instance</span> = <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">log</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span>.<span class="hljs-title function_">push</span>(&#123; message, <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>() &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>  &#125;<br><br>  <span class="hljs-title function_">getLogs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">logs</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用单例</span><br><span class="hljs-keyword">const</span> logger1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>logger1.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Application started&#x27;</span>);<br><br><span class="hljs-keyword">const</span> logger2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>logger2.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;User logged in&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(logger2.<span class="hljs-title function_">getLogs</span>());<br><span class="hljs-comment">// 输出：[&#123; message: &#x27;Application started&#x27;, timestamp: ... &#125;, &#123; message: &#x27;User logged in&#x27;, timestamp: ... &#125;]</span><br></code></pre></td></tr></table></figure>

<p>可见优点是：资源消耗低，状态一致；缺点是：单例对象被赋予太多了职责，代码可能难以维护、测试。</p>
<p>常见的实例：<code>全局配置管理器</code> <code>日志记录器</code></p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者&#x2F;发布订阅模式是一种行为设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象（主题）的状态发生改变时，其所有依赖者（观察者）都会收到通知并自动更新。</p>
<p>关键点就是在于要声明一个函数数组，每次有需要的时候进行forEach执行里面的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);<br>    &#125;<br><br>    <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">indexOf</span>(observer);<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> &#123;<br>            observer.<span class="hljs-title function_">update</span>(data);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;update() must be implemented.&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Observer</span> &#123;<br>    <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Observer received data: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>        <span class="hljs-comment">// 执行具体的操作</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br><span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br><span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>();<br><br>subject.<span class="hljs-title function_">addObserver</span>(observer1);<br>subject.<span class="hljs-title function_">addObserver</span>(observer2);<br><br>subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;Hello, Observers!&#x27;</span>); <span class="hljs-comment">// 输出：Observer received data: Hello, Observers!</span><br></code></pre></td></tr></table></figure>

<p>常见的实例：<code>任务管理应用</code></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式是一种行为设计模式，它允许在运行时选择算法或行为。它将各种算法封装成独立的类（称为策略类），这些策略类具有相同的接口。客户端可以根据需要选择不同的策略来实现特定的行为，而无需修改原有代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义策略接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortStrategy</span> &#123;<br>  <span class="hljs-title function_">sort</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;sort() must be implemented.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体策略类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSortStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SortStrategy</span> &#123;<br>  <span class="hljs-title function_">sort</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = [...data];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>          [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]];<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSortStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SortStrategy</span> &#123;<br>  <span class="hljs-title function_">sort</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = [...data];<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> pivot = arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];<br>    <span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; pivot);<br>    <span class="hljs-keyword">const</span> middle = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === pivot);<br>    <span class="hljs-keyword">const</span> right = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; pivot);<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sort</span>(left), ...middle, ...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sort</span>(right)];<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSortStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SortStrategy</span> &#123;<br>  <span class="hljs-title function_">sort</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = [...data];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> minIndex = i;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>          minIndex = j;<br>        &#125;<br>      &#125;<br>      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义上下文类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortContext</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortStrategy</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">setSortStrategy</span>(<span class="hljs-params">strategy</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortStrategy</span> = strategy;<br>  &#125;<br><br>  <span class="hljs-title function_">sortData</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortStrategy</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortStrategy</span>.<span class="hljs-title function_">sort</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SortContext</span>();<br><span class="hljs-keyword">const</span> data = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>];<br><br>context.<span class="hljs-title function_">setSortStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BubbleSortStrategy</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;冒泡排序:&#x27;</span>, context.<span class="hljs-title function_">sortData</span>(data));<br><br>context.<span class="hljs-title function_">setSortStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QuickSortStrategy</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;快速排序:&#x27;</span>, context.<span class="hljs-title function_">sortData</span>(data));<br><br>context.<span class="hljs-title function_">setSortStrategy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionSortStrategy</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;选择排序:&#x27;</span>, context.<span class="hljs-title function_">sortData</span>(data));<br></code></pre></td></tr></table></figure>

<p>优点：低耦合、易于拓展、灵活多变。缺点：系统复杂性可能增加。</p>
<p>常见的实例：<code>全局配置管理器</code> <code>日志记录器</code></p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式是一种结构型设计模式，它允许在运行时动态地给对象添加额外的功能或责任。这种模式提供了一种灵活的替代方案，替代了传统的继承方式来扩展对象功能。装饰者模式的核心思想是将每个功能封装在独立的装饰者类中，这些装饰者类包装了被装饰的组件，并在需要时添加新的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">content</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>  &#125;<br><br>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicTextEditor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TextEditor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">content</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(content);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 装饰者类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditorDecorator</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">editor</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span> = editor;<br>  &#125;<br><br>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span>.<span class="hljs-title function_">display</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体装饰者：加粗</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TextEditorDecorator</span> &#123;<br>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;b&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.editor.display()&#125;</span>&lt;/b&gt;`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体装饰者：斜体</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ItalicDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TextEditorDecorator</span> &#123;<br>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;i&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.editor.display()&#125;</span>&lt;/i&gt;`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体装饰者：下划线</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnderlineDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">TextEditorDecorator</span> &#123;<br>  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;u&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.editor.display()&#125;</span>&lt;/u&gt;`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> basicEditor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicTextEditor</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);<br><span class="hljs-keyword">const</span> boldEditor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoldDecorator</span>(basicEditor);<br><span class="hljs-keyword">const</span> italicEditor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItalicDecorator</span>(boldEditor);<br><span class="hljs-keyword">const</span> underlineEditor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlineDecorator</span>(italicEditor);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(underlineEditor.<span class="hljs-title function_">display</span>());<br><span class="hljs-comment">// 输出：&lt;u&gt;&lt;i&gt;&lt;b&gt;Hello, World!&lt;/b&gt;&lt;/i&gt;&lt;/u&gt;</span><br></code></pre></td></tr></table></figure>

<p>优点：可以自由组合自由扩展；缺点：调试繁琐</p>
<p>常见的实例：<code>动态添加按钮功能</code> <code>文字样式功能编辑</code></p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式是一种行为设计模式，它将请求封装为对象，从而允许你参数化客户端、排队或记录请求，并支持可撤销的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义命令接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;execute() must be implemented.&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;undo() must be implemented.&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义接收者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-title function_">actionA</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行操作 A&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">actionB</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行操作 B&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体命令</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommandA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Command</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">receiver</span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span> = receiver;<br>    &#125;<br><br>    <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span>.<span class="hljs-title function_">actionA</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;撤销操作 A&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommandB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Command</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">receiver</span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span> = receiver;<br>    &#125;<br><br>    <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span>.<span class="hljs-title function_">actionB</span>();<br>    &#125;<br><br>    <span class="hljs-title function_">undo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;撤销操作 B&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义调用者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">executeCommand</span>(<span class="hljs-params">command</span>) &#123;<br>        command.<span class="hljs-title function_">execute</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(command);<br>    &#125;<br><br>    <span class="hljs-title function_">undoLastCommand</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">const</span> command = <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">pop</span>();<br>            command.<span class="hljs-title function_">undo</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> receiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();<br><span class="hljs-keyword">const</span> invoker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br><br><span class="hljs-keyword">const</span> commandA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommandA</span>(receiver);<br><span class="hljs-keyword">const</span> commandB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommandB</span>(receiver);<br><br>invoker.<span class="hljs-title function_">executeCommand</span>(commandA);<br>invoker.<span class="hljs-title function_">executeCommand</span>(commandB);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;撤销最后一条命令&#x27;</span>);<br>invoker.<span class="hljs-title function_">undoLastCommand</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;撤销前一条命令&#x27;</span>);<br>invoker.<span class="hljs-title function_">undoLastCommand</span>();<br></code></pre></td></tr></table></figure>

<p>优点：支持命令的保存；</p>
<p>常见的实例：<code>撤销操作</code> <code>宏命令</code> <code>日志记录</code></p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式是一种结构型设计模式，它允许你将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得用户可以以统一的方式处理单个对象和组合对象，而无需关心其具体类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义组件接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;add() must be implemented.&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;remove() must be implemented.&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">display</span>(<span class="hljs-params">indent</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;display() must be implemented.&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义叶子节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;叶子节点不能添加子节点&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;叶子节点不能移除子节点&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">display</span>(<span class="hljs-params">indent</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;indent&#125;</span><span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义组合节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(child);<br>    &#125;<br><br>    <span class="hljs-title function_">remove</span>(<span class="hljs-params">child</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">indexOf</span>(child);<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">display</span>(<span class="hljs-params">indent</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;indent&#125;</span><span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>        <span class="hljs-keyword">const</span> newIndent = indent + <span class="hljs-string">&#x27;  &#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>            child.<span class="hljs-title function_">display</span>(newIndent);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&#x27;根目录&#x27;</span>);<br><span class="hljs-keyword">const</span> folder1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&#x27;文件夹1&#x27;</span>);<br><span class="hljs-keyword">const</span> folder2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&#x27;文件夹2&#x27;</span>);<br><span class="hljs-keyword">const</span> file1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&#x27;文件1.txt&#x27;</span>);<br><span class="hljs-keyword">const</span> file2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&#x27;文件2.txt&#x27;</span>);<br><span class="hljs-keyword">const</span> file3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&#x27;文件3.txt&#x27;</span>);<br><br>root.<span class="hljs-title function_">add</span>(folder1);<br>root.<span class="hljs-title function_">add</span>(folder2);<br>folder1.<span class="hljs-title function_">add</span>(file1);<br>folder1.<span class="hljs-title function_">add</span>(file2);<br>folder2.<span class="hljs-title function_">add</span>(file3);<br><br>root.<span class="hljs-title function_">display</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>优点：树形表示比较清晰，递归操作。</p>
<p>缺点：系统比较复杂。</p>
<p>常见的实例：<code>菜单系统</code></p>
<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS3硬件加速"><a href="#CSS3硬件加速" class="headerlink" title="CSS3硬件加速"></a>CSS3硬件加速</h3><p>原理是用GPU来处理特定的CSS操作，GPU 是专门为处理图形和数学密集型任务（如矩阵计算、透明度混合）而设计的，在处理像素操作上比 CPU 高效得多。</p>
<p>渲染页面的性能瓶颈在页面的重排和重绘上。</p>
<p>CSS3硬件加速的核心在于<strong>创建一个独立的合成层</strong>，当对元素应用特定的 CSS 属性时（如：fixed定位、translate3d、opacity加过渡、filter blur、canvas、video、iframe），浏览器会识别该元素需要特殊处理，并将其 <strong>提升（Promote）</strong> 为一个独立的合成层，此时GPU只需要对这个合成层进行操作即可实现加速。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="VUE3项目目录结构"><a href="#VUE3项目目录结构" class="headerlink" title="VUE3项目目录结构"></a>VUE3项目目录结构</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">| node_modules					</span><span class="hljs-literal">--</span><span class="hljs-comment">项目依赖</span><br><span class="hljs-comment">| public      					</span><span class="hljs-literal">--</span><span class="hljs-comment">公共文件夹</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| favicon</span><span class="hljs-string">.</span><span class="hljs-comment">ico				</span><span class="hljs-literal">--</span><span class="hljs-comment">网站图标</span><br><span class="hljs-comment">| src         	    			</span><span class="hljs-literal">--</span><span class="hljs-comment">源文件目录</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| assets					</span>    <span class="hljs-literal">--</span><span class="hljs-comment">静态文件</span><br><span class="hljs-comment">	</span><span class="hljs-literal">---</span><span class="hljs-comment">| utils				</span>    <span class="hljs-literal">--</span><span class="hljs-comment">工具类JS</span><br><span class="hljs-comment">	</span><span class="hljs-literal">---</span><span class="hljs-comment">| api				</span>    <span class="hljs-literal">--</span><span class="hljs-comment">接口类JS</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| components					</span><span class="hljs-literal">--</span><span class="hljs-comment">组件</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| router						</span><span class="hljs-literal">--</span><span class="hljs-comment">路由配置</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| store						</span><span class="hljs-literal">--</span><span class="hljs-comment">状态管理器</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| views						</span><span class="hljs-literal">--</span><span class="hljs-comment">视图文件，与路由结构对应</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| App</span><span class="hljs-string">.</span><span class="hljs-comment">vue					</span><span class="hljs-literal">--</span><span class="hljs-comment">根组件</span><br><span class="hljs-literal">---</span><span class="hljs-comment">| main</span><span class="hljs-string">.</span><span class="hljs-comment">js 					</span><span class="hljs-literal">--</span><span class="hljs-comment">入口文件</span><br><span class="hljs-comment">| index</span><span class="hljs-string">.</span><span class="hljs-comment">html					</span><span class="hljs-literal">--</span><span class="hljs-comment">入口html</span><br><span class="hljs-comment">| package</span><span class="hljs-string">.</span><span class="hljs-comment">json					</span><span class="hljs-literal">--</span><span class="hljs-comment">命令配置及依赖管理</span><br><span class="hljs-comment">| package</span><span class="hljs-literal">-</span><span class="hljs-comment">lock</span><span class="hljs-string">.</span><span class="hljs-comment">json				</span><span class="hljs-literal">--</span><span class="hljs-comment">依赖版本及更完整的依赖树</span><br><span class="hljs-comment">| README</span><span class="hljs-string">.</span><span class="hljs-comment">md						</span><span class="hljs-literal">--</span><span class="hljs-comment">说明文件</span><br><span class="hljs-comment">| vue</span><span class="hljs-string">.</span><span class="hljs-comment">config</span><span class="hljs-string">.</span><span class="hljs-comment">json 				</span> <span class="hljs-literal">--</span><span class="hljs-comment">代理、打包等配置文件</span><br></code></pre></td></tr></table></figure>

<hr>
<blockquote>
<p><strong>public和assets区别：</strong></p>
<p>​	同样用于存放静态文件的文件夹。由于vue-cli、vite等工具打包时，public下的文件会原封不动的添加到dist中，而assets下的文件会被合并压缩。</p>
<p>​	两者的区别是public下一般用于放有更新需求的第三方插件、图片且需要使用绝对路径来引用(否则会warning)，而assets下适合用于存放项目中所必须的图标、JS文件只支持相对路径。<a target="_blank" rel="noopener" href="https://vitejs.cn/vite3-cn/guide/assets.html#importing-asset-as-url">相关文档</a></p>
</blockquote>
<hr>
<blockquote>
<p><strong>有了package.json为什么还需要package-lock.json：</strong></p>
<p>​	前者声明依赖的种类而后者决定实际安装的版本，使用<code>npm install</code>时就是根据package-lock.json进行安装。</p>
</blockquote>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM是啥意思捏。展开就是Model-View-ViewModel。我这里分别介绍一下：</p>
<p>Model表示应用的数据存储、检索、操作。</p>
<p>View负责显示用户的页面。</p>
<p>ViewModel作为Model与View之间的桥梁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- 视图（View）层：展示用户界面并处理用户交互 --&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;&#123;&#123; counter &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;incrementCounter&quot;&gt;点击增加计数器&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br><br>// 模型（Model）层：存储和管理数据<br>const counter = ref(0);<br><br>// 视图模型（ViewModel）层：处理数据和业务逻辑<br>const incrementCounter = () =&gt; &#123;<br>  counter.value++;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h3 id="v-show-v-if"><a href="#v-show-v-if" class="headerlink" title="v-show &amp; v-if"></a>v-show &amp; v-if</h3><p>都是控制页面的显示，但是前者是控制CSS中的display属性，而后者是直接将其删除或者添加。<br>这就意味着前者会在初始渲染的时候有更高的消耗，但是后者在切换的时候会有更高的消耗。<br>同时还意味着前者会触发<code>transition</code>后者不会触发（在没有另外编写钩子函数的情况下）</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初</td>
<td>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建</td>
<td>组件初始化完毕，各种数据可以使用，常用于异步数据获取</td>
</tr>
<tr>
<td>beforeMount</td>
<td>组件挂载之前</td>
<td>未执行渲染、更新，dom未创建</td>
</tr>
<tr>
<td>mounted</td>
<td>组件挂载到实例上去之后</td>
<td>初始化结束，dom已创建，可用于获取访问数据和dom元素</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据发生变化，更新之前</td>
<td>更新前，可用于获取更新前各种状态</td>
</tr>
<tr>
<td>updated</td>
<td>组件数据更新之后</td>
<td>更新后，所有状态已是最新</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>组件实例销毁之前</td>
<td>销毁前，可用于一些定时器或订阅的取消</td>
</tr>
<tr>
<td>destroyed</td>
<td>组件实例销毁之后</td>
<td>组件已销毁，作用同上</td>
</tr>
<tr>
<td>activated</td>
<td>keep-alive 缓存的组件激活时</td>
<td></td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 缓存的组件停用时调用</td>
<td></td>
</tr>
<tr>
<td>errorCaptured</td>
<td>捕获一个来自子孙组件的错误时被调用</td>
<td></td>
</tr>
</tbody></table>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><p>React的生命周期包含三个阶段：创建、更新、卸载。</p>
<h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><p>React16中引入的核心重写，核心在于将<strong>原本庞大、同步不可中断的渲染任务拆分成一系列小的、可中断、可恢复的工作单元</strong>，并赋予它们不同的<strong>优先级</strong>，让浏览器能够在执行这些工作单元的间隙去处理更高优先级的事件（如用户输入、动画），从而保持应用的流畅响应。</p>
<p>解决的问题大致有三个：<strong>同步递归不可中断</strong>、<strong>阻塞主线程</strong>、<strong>丢帧卡顿</strong></p>
<ul>
<li><p><strong>Fiber 节点：</strong>Fiber结构不再仅仅依赖树形的虚拟 DOM 数据结构。它引入了 <strong><code>Fiber</code></strong> 这个<strong>新的数据结构</strong>来表示一个工作单元。每个 React 元素（组件实例、DOM 节点等）对应一个 Fiber 节点。它包含了该组件&#x2F;节点所需的所有信息（类型、props、state、关联的 DOM 节点、子节点、兄弟节点、父节点等）。</p>
</li>
<li><p><strong>增量渲染（时间切片）：</strong></p>
<ul>
<li>React 将整个渲染&#x2F;更新过程分解成多个以 <strong>Fiber 节点为单位的工作单元</strong>。 </li>
<li>React 不再一次性完成整个树的 diff 和更新。它一次处理一个（或一小批）Fiber 节点。 </li>
<li>在处理完一个 Fiber 节点后，React 会检查当前帧<strong>剩余的时间</strong>（使用类似 <code>requestIdleCallback</code> 的机制，但 React 实现了自己更强大的 <code>Scheduler</code> 调度器）。 </li>
<li>如果当前帧时间快用完了（或者有更高优先级的任务到达），React 会<strong>暂停</strong>当前渲染工作，将控制权交还给浏览器，让浏览器去处理用户交互、动画绘制等高优先级任务。</li>
<li>当浏览器空闲时（下一帧或者更晚），React 会<strong>恢复</strong>渲染工作，从上次暂停的 Fiber 节点继续处理后续节点。</li>
</ul>
</li>
<li><p><strong>优先级调度：</strong></p>
<ul>
<li>React 为不同的更新来源赋予了不同的优先级（例如，用户输入 &gt; 交互动画 &gt; 数据加载 &gt; 后台任务）。</li>
<li>如果一个低优先级的渲染任务正在进行中（例如渲染一个大型列表），此时用户触发了高优先级更新（例如输入框输入）。React 可以<strong>中断</strong>正在进行的低优先级渲染。优先去处理高优先级的更新（例如快速响应输入，更新输入框状态和 UI）。等处理完高优先级更新后，再回过头来继续处理、重新开始或者丢弃之前的低优先级渲染。</li>
</ul>
</li>
<li><p><strong>双缓存（Fiber 树）：</strong></p>
<ul>
<li>屏幕上当前显示内容对应的 Fiber 树称为 <code>current</code> 树。</li>
<li>当开始一次新的渲染（更新）时，React 会基于 <code>current</code> 树克隆（或新建）一棵新的 Fiber 树，称为 <code>workInProgress</code> (WIP) 树。所有的更新工作（diff, 副作用标记）都在这棵 WIP 树上进行。</li>
<li>当 WIP 树完整地构建完成（所有工作单元都处理完），并且所有的副作用（DOM 更新）都计算好后，React 会**一次性将 WIP 树的根节点指针指向 <code>current</code>**。这个切换操作非常快，保证了 UI 更新的原子性，避免出现“半成品”状态。</li>
<li>切换后，之前的 WIP 树就变成了新的 <code>current</code> 树，而之前的 <code>current</code> 树则成为下一次更新的基准（或可以被回收）。</li>
</ul>
</li>
<li><p><strong>渲染阶段与提交阶段：</strong></p>
<ul>
<li><strong>Render Phase (协调&#x2F;渲染阶段):</strong><ul>
<li>此阶段是<strong>可中断、可重启、可做优先级调度</strong>的。</li>
<li>主要工作：遍历 Fiber 树，进行 diff 比较，找出需要更新的地方。</li>
<li><strong>不执行任何实际的 DOM 操作！</strong> 只是计算哪些节点需要更新（增、删、改），并将这些信息标记（<code>effectTag</code>）在对应的 Fiber 节点上（例如 <code>Placement</code>, <code>Update</code>, <code>Deletion</code>）。同时收集需要执行的副作用（<code>useEffect</code>, <code>useLayoutEffect</code> 等）到一个链表中。</li>
<li>因为不操作 DOM，即使被中断重启，也不会导致 UI 不一致。</li>
</ul>
</li>
<li><strong>Commit Phase (提交阶段):</strong><ul>
<li>此阶段是<strong>同步、不可中断</strong>的。</li>
<li>主要工作：遍历在 Render Phase 收集到的副作用链表，<strong>同步地执行所有 DOM 更新和生命周期方法&#x2F;Effect Hook</strong></li>
<li>必须一次性完成，以确保 UI 从旧状态一致地切换到新状态。如果在这个阶段中断，用户会看到不一致的 UI。</li>
<li>完成后，新的 WIP 树正式成为 <code>current</code> 树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JSX模式"><a href="#JSX模式" class="headerlink" title="JSX模式"></a>JSX模式</h3><p>React使用JSX模式，有什么好处呢？</p>
<ul>
<li><strong>利好静态检查工具</strong>：不需要做多余的业务逻辑处理，可以直接在JSX返回的组件函数头处进行类型判断。</li>
<li><strong>可以采用动态写法</strong>：不需要多余的学习（比如v-for），可以直接采用JS的写法对页面逻辑进行处理。</li>
</ul>
<h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="ECMA-262标准化语言规范"><a href="#ECMA-262标准化语言规范" class="headerlink" title="ECMA-262标准化语言规范"></a>ECMA-262标准化语言规范</h3><blockquote>
<h3 id="ECMAScript和Javascript的区别"><a href="#ECMAScript和Javascript的区别" class="headerlink" title="ECMAScript和Javascript的区别:"></a>ECMAScript和Javascript的区别:</h3><p>​	ECMAScript是JavaScript的核心语言规范，而JavaScript则是基于这些规范的具体实现，包含了更多的功能和API，以便在浏览器和其他环境中运行。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs markdown">ES1（1997年）<br><span class="hljs-bullet">+</span> 基于Netscape的JavaScript 1.1。<br><br>ES2（1998年）<br><span class="hljs-bullet">+</span> 与ISO/IEC 16262标准保持一致。<br><br>ES3（1999年）：<br><span class="hljs-bullet">+</span> 正则表达式：引入了正则表达式支持。<br><span class="hljs-bullet">+</span> 更好的字符串处理：增加了新的字符串方法。<br><span class="hljs-bullet">+</span> 控制语句：添加了try/catch异常处理。<br><span class="hljs-bullet">+</span> 其他改进：包括更严格的错误定义和数字格式化。<br><br>ES5（2009年）：<br><span class="hljs-bullet">+</span> 严格模式：提供了更严格的错误检查。<br><span class="hljs-bullet">+</span> JSON支持：内置了对JSON的支持。<br><span class="hljs-bullet">+</span> Array方法：如forEach、map、filter等。<br><span class="hljs-bullet">+</span> Object方法：如Object.keys、Object.defineProperty等。<br><br>ES6（2015年）：<br><span class="hljs-bullet">+</span> 箭头函数：简化了函数表达式。<br><span class="hljs-bullet">+</span> let和const：引入了块级作用域变量。<br><span class="hljs-bullet">+</span> 模板字符串：支持多行字符串<span class="hljs-code">` `</span> 和内嵌表达式$&#123; &#125;。<br><span class="hljs-bullet">+</span> 类和模块：引入了类和模块系统。<br><span class="hljs-bullet">+</span> Promise：用于处理异步操作。<br><br>ES7（2016年）：数组includes方法、指数运算简化<br><span class="hljs-bullet">+</span> Array.prototype.includes()：检查数组中是否包含某个元素。<br><span class="hljs-bullet">+</span> 指数运算符：简化指数运算为双星号。<br><br>ES8（2017年）：简化异步、对象方法优化、字符串填充方法<br><span class="hljs-bullet">+</span> Async/Await：简化异步代码。<br><span class="hljs-bullet">+</span> Object.values() 和 Object.entries()：返回对象的值和键值对数组。<br><span class="hljs-bullet">+</span> String padding：字符串填充方法。<br><br>ES9（2018年）：<br><span class="hljs-bullet">+</span> 异步迭代器：支持异步数据流处理。<br><span class="hljs-bullet">+</span> Rest/Spread属性：（...）扩展对象的解构赋值和扩展运算符。<br><br>ES10（2019年）数组/对象/字符串处理方法增加<br><span class="hljs-bullet">+</span> Array.prototype.flat() 和 Array.prototype.flatMap()：数组扁平化方法。<br><span class="hljs-bullet">+</span> Object.fromEntries()：将键值对列表转换为对象。<br><span class="hljs-bullet">+</span> String.prototype.trimStart() 和 String.prototype.trimEnd()：去除字符串开头和结尾的空白字符。<br><br>ES11（2020年）：BigInt、空值合并、动态导入模块、可选链<br><span class="hljs-bullet">+</span> BigInt：支持任意精度的整数。<br><span class="hljs-bullet">+</span> 动态导入：按需加载模块。<br><span class="hljs-bullet">+</span> 空值合并运算符（??）：处理null或undefined。<br><span class="hljs-bullet">+</span> 可选链运算符（?.）：简化深层嵌套对象属性的访问。<br><br>ES12（2021年）：逻辑赋值运算、字符串匹配方法<br><span class="hljs-bullet">+</span> 逻辑赋值运算符（&amp;&amp;=、||=、??=）：结合逻辑运算和赋值操作。<br><span class="hljs-bullet">+</span> String.prototype.replaceAll()：替换字符串中所有匹配的子串。<br><span class="hljs-bullet">+</span> Promise.any()：返回第一个成功的Promise。<br><br>ES13（2022年）顶层await、类字段声明初始化<br><span class="hljs-bullet">+</span> 顶层await：在模块顶层使用await。<br><span class="hljs-bullet">+</span> 类字段声明：简化类中字段的声明和初始化。<br><br>ES14（2023年）数组方法优化<br><span class="hljs-bullet">+</span> Array.prototype.toSorted()：返回排序后的数组副本。<br><span class="hljs-bullet">+</span> Array.prototype.toReversed()：返回反转后的数组副本。<br><span class="hljs-bullet">+</span> Array.prototype.toSpliced()：返回删除或替换元素后的数组副本。<br><br>ES15（2024年）symbol描述、匹配字符串索引<br><span class="hljs-bullet">+</span> RegExp Match Indices：提供匹配子字符串的索引。<br><span class="hljs-bullet">+</span> Symbol.prototype.description：返回Symbol的描述。<br></code></pre></td></tr></table></figure>

<h3 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h3><p>ESM是将 javascript 程序拆分成多个单独模块，并能按需导入的标准。</p>
<p>我们先来看道题吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-keyword">import</span> &#123; value &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./c.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A:&#x27;</span>, value);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-keyword">import</span> &#123; counter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; increment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./c.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B:&#x27;</span>, counter);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B setTimeout:&#x27;</span>, counter);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">increment</span>();<br><br><span class="hljs-comment">//c.js</span><br><span class="hljs-keyword">import</span> &#123; counter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;initial&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; value &#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    counter++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C increment:&#x27;</span>, counter);<br>&#125;<br><br><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./b.js&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>执行<code>main.js</code>会发生什么呢？</p>
<p>首先我们要搞明白一些概念，模块化的引入是分初始化和执行的，初始化的时候会运行全部代码，初始化之后就可以执行了，执行只返回需要的export。还有如果两个模块相互引入，会先执行循环中第一个引入的，完成初始化后再向下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//答案如下：</span><br><span class="hljs-comment">//C</span><br><span class="hljs-comment">//A:initial</span><br><span class="hljs-comment">//B:0</span><br><span class="hljs-comment">//C increment:1</span><br><span class="hljs-comment">//B setTimeout:1 </span><br></code></pre></td></tr></table></figure>

<p>运行<code>main.js</code>，首先就要引入<code>a.js</code>，这时候就运行<code>a.js</code>，结果他一开头又引入了<code>c.js</code>，这时候就运行<code>c.js</code>，结果发现进循环了。那这个时候就先初始化循环中第一个引用的，也就是<code>c.js</code>，输出<code>C</code>。然后返回到<code>a.js</code>，这时候<code>c.js</code>已经被部分初始化，那么就可以得到value，输出<code>A:initial</code>，<code>a.js</code>完全初始化了，这时候会把<code>c.js</code>剩下的<code>counter</code>也赋值。接下来回到<code>main.js</code>，引入<code>b.js</code>，<code>b.js</code>引入<code>a.js</code>和<code>c.js</code>都已经初始化完毕了，可以直接拿到值，按照事件循环<code>setTimeout</code>进宏队列，然后先执行log然后执行increment，同步队列完成执行就执行宏队列（详见事件循环）。</p>
<h3 id="for-in和for-of"><a href="#for-in和for-of" class="headerlink" title="for in和for of"></a>for in和for of</h3><p>for in用于循环一个对象的可枚举属性，可以用来遍历对象的键，数组的索引等。</p>
<p>for of用于循环一个可迭代对象的值。</p>
<blockquote>
<p>对象不能直接用for of遍历，因为他不是一个可迭代对象，可以用Object.values转化为数组再用for..of循环，或者用Object.entries将对象转化为可迭代对象再用for..of循环</p>
</blockquote>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别</h3><p>在使用<code>==</code>时会默认使用隐式转换改变数据类型，<code>===</code>的时候不会。</p>
<p>null和undefined只能彼此相等，其他情况均不相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">//false </span><br></code></pre></td></tr></table></figure>

<h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><blockquote>
<p>不说废话，出个实战题目：写一个函数，每调用一次输出的数字比上一次加一。</p>
</blockquote>
<p>闭包的翻译好啊，原来的含义是：在封<strong>闭</strong>的作用域中，<strong>包</strong>含另一个作用域。</p>
<p>当我们创建一个函数A中再<strong>创建</strong>一个函数B的时候，B中可以使用在A初始化的数据——这就是闭包。</p>
<p>也就是说，闭包可以让你在一个内层函数中访问到其外层函数的作用域。</p>
<p>而且呢，还可以在外部函数执行完毕之后，仍然访问这些变量，这个就很牛了。</p>
<p>闭包一般拿来干啥呢？</p>
<h4 id="延长变量生命周期"><a href="#延长变量生命周期" class="headerlink" title="延长变量生命周期"></a>延长变量生命周期</h4><p>这个就是我刚刚问的例子了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//例子1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        num++<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">newCounter</span>() <span class="hljs-comment">/* 输出1 */</span><br><span class="hljs-title function_">newCounter</span>() <span class="hljs-comment">/* 输出2 */</span><br><br><span class="hljs-comment">//例子2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">width</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">height</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> width * height<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> getTenWidthArea = <span class="hljs-title function_">getArea</span>(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span><br><span class="hljs-keyword">const</span> area1 = <span class="hljs-title function_">getTenWidthArea</span>(<span class="hljs-number">20</span>)<br><span class="hljs-comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span><br><span class="hljs-keyword">const</span> getTwentyWidthArea = <span class="hljs-title function_">getArea</span>(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure>

<h4 id="创建私有变量"><a href="#创建私有变量" class="headerlink" title="创建私有变量"></a>创建私有变量</h4><p>立即调用函数表达式：一种编程模式，定义一个函数后立刻执行他。格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 函数体</span><br>&#125;)(<span class="hljs-comment">/* 传入的值 */</span>);<br><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 函数体</span><br>&#125;(<span class="hljs-comment">/* 传入的值 */</span>));<br><br>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 函数体</span><br>&#125;)(<span class="hljs-comment">/* 传入的值 */</span>);<br></code></pre></td></tr></table></figure>

<p>私有方法&#x2F;变量：面向对象编程的概念，指只能在定义它的类或者对象内部访问的方法。目的是封装代码逻辑（防止从外部直接调用或修改），提高代码安全性。就好像你要点火才能运行汽车，点火是公用方法，而里面的齿轮动是私有方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span> <span class="hljs-comment">//私有变量</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-comment">//私有方法</span><br>        <span class="hljs-keyword">return</span> num+<span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-comment">//公有方法</span><br>        <span class="hljs-attr">value</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> num<br>        &#125;,<br>        <span class="hljs-attr">add</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>()<br>        &#125;<br>    &#125;<br>&#125;)()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">value</span>()); <span class="hljs-comment">/* 输出0 */</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">add</span>()); <span class="hljs-comment">/* 输出2 */</span><br></code></pre></td></tr></table></figure>

<h3 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h3><p>作用域决定了代码区块中变量及其他资源的可见性，一般将作用域分为<code>全局作用域</code>、<code>函数作用域</code>、<code>块级作用域</code>，作用域在变量被创建好的时候就确定了，不会随着执行的时候改变。</p>
<p>作用域链是指你需要调用变量的时候，会先从局部作用域寻找，一直往上直到全局作用域。</p>
<p>全局作用域：不在任何函数或者大括号中声明的变量，可以在程序的任何位置访问。</p>
<p>函数作用域：也叫局部作用域，是在函数内部声明的，不能在函数之外访问（除了闭包）</p>
<p>块级作用域：ES6中引入了<code>let</code>&amp;<code>const</code>，这两者只能在大括号内访问，大括号外不可以访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> globalValue = <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">var</span> functionValue = <span class="hljs-string">&quot;2&quot;</span><br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)<br>&#123;<br> <span class="hljs-keyword">let</span> blockValue = <span class="hljs-string">&quot;3&quot;</span><br>	<span class="hljs-title function_">log</span>(blockValue)<span class="hljs-comment">//&quot;3&quot;</span><br>&#125;<br><br><span class="hljs-title function_">log</span>(globalValue)<span class="hljs-comment">//&quot;1&quot;</span><br><span class="hljs-title function_">log</span>(functionValue)<span class="hljs-comment">// 报错</span><br><span class="hljs-title function_">log</span>(blockValue)<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure>

<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code>是函数的一个运行时自动生成的内部对象，只能在函数内使用，指向最后调用它的对象。</p>
<h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>优先级：new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<ul>
<li>默认绑定：全局对象会默认绑定，如果严格模式下，<code>this</code>会绑定到undefined。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jenny&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">person</span>());  <span class="hljs-comment">//Jenny,调用函数的对象</span><br></code></pre></td></tr></table></figure>

<ul>
<li>隐式绑定：函数作为对象的某个方法调用，<code>this</code>就指向这个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>:&#123;<br>        <span class="hljs-attr">a</span>:<span class="hljs-number">7</span>,<br>        <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">//undefined</span><br>        &#125;<br>    &#125;<br>&#125;<br>o.<span class="hljs-property">b</span>.<span class="hljs-title function_">fn</span>();<span class="hljs-comment">//7</span><br><span class="hljs-keyword">var</span> j = o.<span class="hljs-property">b</span>.<span class="hljs-property">fn</span>;<br><span class="hljs-title function_">j</span>();<span class="hljs-comment">//this指向window</span><br></code></pre></td></tr></table></figure>

<ul>
<li>new绑定：如果用<code>new</code>构造函数生成一个实例对象，<code>this</code>指向此对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>　<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>();<br>obj.<span class="hljs-property">x</span> <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//new过程遇到return一个对象，此时this指向为返回的对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)  <br>&#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;  <br>    <span class="hljs-keyword">return</span> &#123;&#125;;  <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">//undefined</span><br><span class="hljs-comment">//如果返回一个简单类型的时候，则this指向实例对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)  <br>&#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">//xxx</span><br><span class="hljs-comment">//注意的是null虽然也是对象，但是此时new仍然指向实例对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)  <br>&#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">//xxx</span><br></code></pre></td></tr></table></figure>

<p>显示修改：<code>apply</code> <code>call</code> <code>bind</code>这些方法作用是改变函数的调用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>　<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>obj.<span class="hljs-property">m</span> = test;<br>obj.<span class="hljs-property">m</span>.<span class="hljs-title function_">apply</span>(obj) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>箭头函数的<code>this</code>在代码书写编译时就已经绑定，会捕获其定义时的词法作用域中的 <code>this</code></p>
<h3 id="apply-call-bind"><a href="#apply-call-bind" class="headerlink" title="apply&amp;call&amp;bind"></a>apply&amp;call&amp;bind</h3><p>都是改变this的指向的方法，位于<code>Function</code>构造函数的<code>prototype</code>属性上，用法都是<code>Fn1.apply(Fn2,...args)</code>,其中Fn1&amp;Fn2均为构造函数，但是也有些许不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">apply</span>(thisArg, argsArray)<br><span class="hljs-title function_">call</span>(thisArg, arg1, arg2,<span class="hljs-comment">/* …, */</span> argN)<br><span class="hljs-title function_">bind</span>(thisArg, arg1, arg2,<span class="hljs-comment">/* …, */</span> argN)<br></code></pre></td></tr></table></figure>

<p>apply作用于args接收数组同时给构造函数中传入数组，call的args接收的是值，这两个方法都返回Fn1执行后的返回值。<br>bind在函数接收方面和call一样，但是他会返回被绑定的函数Fn1，而且不执行Fn1</p>
<p>怎么记忆呢：apply的开头是a 记成array；call和bind都是四个字符 接受一样的；bind有绑定的有意思，就是先绑定不用。</p>
<h3 id="事件与事件模型"><a href="#事件与事件模型" class="headerlink" title="事件与事件模型"></a>事件与事件模型</h3><p>JS中的事件，其实就是浏览器中发生的一种交互操作。</p>
<p>事件流经历三个阶段：事件捕获阶段(capture phase)、处于目标阶段(target phase)、事件冒泡阶段(bubbling phase)</p>
<p>事件冒泡是一种从下往上的传播方式，由处于目标阶段的触发节点逐渐向上传播到最上的节点也就是DOM中最高的父节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;clickMe&#x27;</span>);<br><br>button.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1.Button&#x27;</span>);<br>&#125;;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2.body&#x27;</span>);<br>&#125;;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3.document&#x27;</span>);<br>&#125;;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4.window&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">//1.button</span><br><span class="hljs-comment">//2.body</span><br><span class="hljs-comment">//3.document</span><br><span class="hljs-comment">//4.window</span><br></code></pre></td></tr></table></figure>

<p>事件模型可以分为三种：原始事件模型（DOM 0级）、标准事件模型（DOM 2级）、IE事件模型。</p>
<p>一般使用原始事件模型和标准事件模型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">//原始事件模型<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleClick()&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//标准事件模型</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick, useCapture);<br></code></pre></td></tr></table></figure>

<p>区别是原始事件模型简单，但有局限，不支持事件捕获和多个事件处理器；标准事件模型提供更多灵活性和控制。</p>
<h3 id="typeof与instanceof"><a href="#typeof与instanceof" class="headerlink" title="typeof与instanceof"></a>typeof与instanceof</h3><p><code>typeof</code>操作符返回一个字符串，用于表示未经计算的操作数的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span> <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// &#x27;boolean&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>() <span class="hljs-comment">// &#x27;symbol&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span> <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> <span class="hljs-comment">// &#x27;function&#x27;</span><br></code></pre></td></tr></table></figure>

<p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上，返回布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义构建函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">let</span> benz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br>benz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>)<br>car <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xxx&#x27;</span><br>str <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>手写instanceof：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-params">left,right</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">&#x27;object&#x27;</span>||<span class="hljs-keyword">typeof</span> left === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//防止不是使用构造函数创建的实例</span><br>        <span class="hljs-keyword">if</span>(proto === right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素。</p>
<p>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件，如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，这时候就可以事件委托，把点击事件绑定在父级元素<code>ul</code>上面，然后执行事件的时候再去匹配目标元素。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JS运行时需要执行同步和异步的任务，而事件循环是管理异步任务执行的核心机制。</p>
<blockquote>
<p>栈与队列：栈结构遵循后进先出，队列结构遵循先进先出。</p>
</blockquote>
<p>对于同步任务，JS调用栈；而对于异步任务，JS执行任务队列。</p>
<p>异步任务中包含着微任务和宏任务，接下来我们做一些简单的介绍。</p>
<p><strong>宏任务</strong>在事件循环中的每一轮按照顺序进行，而<strong>微任务</strong>则是在当前宏任务执行完毕后，下一个宏任务开始前立即执行。</p>
<blockquote>
<p>当前宏任务是指微任务被包裹的那个宏任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>))<br>&#125;)<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<blockquote>
<p>宏任务常见API：<code>setTimeout/setInterval</code>、<code>I/O 操作(比如文件的读写&amp;网络的请求)</code>、<code>DOM 事件(点击/滚动事件等)</code>，另外值得一提的是，主线程也是一个宏任务！</p>
<p>微任务常见API：<code>Promise.then/catch/finally</code>、<code>process.nextTick(Node环境)</code>、<code>queueMicrotask手动添加微任务</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>))<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);<br>    &#125;);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>))<br><span class="hljs-comment">//1 6 2 3 5 4</span><br></code></pre></td></tr></table></figure>

<p>以上例子可以理解为：</p>
<p>先进入主线程遇到一个log语句，是同步任务，压入栈中并执行输出1然后弹出。然后遇到一个宏任务setTimeout，压入任务队列，又遇到一个宏任务setTimeout，再压入任务队列，遇到一个微任务压入微任务的任务队列。然后执行微任务队列输出6。</p>
<p>第一个循环结束。</p>
<p>读取宏任务队列，读到第一个setTimeout，开始执行其内部语句，遇到同步任务，压入栈中并执行输出2然后弹出。遇到一个微任务压入微任务的任务队列。遇到一个宏任务setTimeout，压入任务队列，然后执行微任务队列输出3。</p>
<p>第二个循环结束。</p>
<p>读取宏任务队列，读到第二个setTimeout，开始执行其内部语句，遇到同步任务，压入栈中并执行输出5然后弹出。</p>
<p>第三个循环结束。</p>
<p>读取宏任务队列，读到第三个setTimeout，开始执行其内部语句，遇到同步任务，压入栈中并执行输出4然后弹出。</p>
<blockquote>
<p>同步任务不是栈结构吗，为什么不是从下到上输出呢？</p>
<p>是这样的，栈结构的后进先出的出是指函数被执行完后就出栈。我们举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;In function a&#x27;</span>);<br>  <span class="hljs-title function_">b</span>();  <span class="hljs-comment">// 调用函数 b</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Back to function a&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;In function b&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">a</span>();  <span class="hljs-comment">// 调用函数 a</span><br><span class="hljs-comment">//In function a</span><br><span class="hljs-comment">//In function b</span><br><span class="hljs-comment">//Back to function a</span><br></code></pre></td></tr></table></figure>

<p>这个例子中a先进栈，然后执行调用b的时候b进栈，然后执行，b执行完了b出栈，这时候栈顶又变成了a，继续执行a，a出栈。（栈结构可以通过执行栈和函数调用上下文、返回地址记录执行b后应该返回到哪里，而不会重新执行a）</p>
</blockquote>
<h3 id="事件捕获与事件冒泡"><a href="#事件捕获与事件冒泡" class="headerlink" title="事件捕获与事件冒泡"></a>事件捕获与事件冒泡</h3><p>事件捕获和事件冒泡是DOM（文档对象模型）中事件传播的两个阶段，它们描述了事件在DOM树中的传递过程。当用户与网页上的元素交互时（例如点击一个按钮），事件会按照一定的顺序在DOM树中传播。这个传播过程通常分为三个阶段：<strong>捕获阶段</strong>、<strong>目标阶段</strong> 和 <strong>冒泡阶段</strong>。</p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获是从最顶层的节点（通常是<code>document</code>对象）开始，逐级向下传递到目标元素的过程。</p>
<p>当一个事件发生时，浏览器会首先检查是否有任何祖先元素（离目标元素较远的祖先）为该事件设置了事件监听器。如果有，这些监听器会在捕获阶段被触发。</p>
<p>事件捕获允许我们在事件到达目标元素之前，对事件进行处理。</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件冒泡是从目标元素开始，逐级向上传递到最顶层节点的过程。在事件冒泡阶段，事件会从目标元素开始，沿着DOM树向上传播到其父元素、祖父元素，直到<code>document</code>对象。</p>
<p>事件冒泡允许我们在父元素上监听子元素的事件，而无需在每个子元素上单独设置事件监听器。这在处理大量子元素的事件时非常高效，例如列表项的点击事件。</p>
<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p><code>async</code>和<code>await</code>是es8的语法糖，作用是让异步代码看起来更像是同步代码，从而提高代码可读性。<br><code>async</code>可以将一个函数标记为异步函数，异步函数返回一个<code>Promise</code>对象。值得一提的是，这个异步函数本身不是异步的。<br><code>await</code>用于暂停异步函数的执行，等待一个<code>Promise</code>解析完成。只能在<code>async</code>关键字中使用。</p>
<blockquote>
<p>在传统的代码中，异步操作会让代码有很多层嵌套，这样会非常难以维护。（这被称为回调地狱）<code>Promise</code>对象可以链式调用，从一定程度上解决了这个问题，但是如果很多异步任务的话，很多的<code>then</code>还是会让代码变得冗长。这个时候<code>async</code>语法糖就有用了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Data fetched successfully!&quot;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data, callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">`Processed: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">displayData</span>(<span class="hljs-params">data, callback</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">`Displaying: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-comment">// 回调地狱示例</span><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: &quot;Data fetched successfully!&quot;</span><br><br>  <span class="hljs-title function_">processData</span>(result, <span class="hljs-function">(<span class="hljs-params">err, processedResult</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processedResult); <span class="hljs-comment">// 输出: &quot;Processed: Data fetched successfully!&quot;</span><br><br>    <span class="hljs-title function_">displayData</span>(processedResult, <span class="hljs-function">(<span class="hljs-params">err, displayedResult</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(displayedResult); <span class="hljs-comment">// 输出: &quot;Displaying: Processed: Data fetched successfully!&quot;</span><br>    &#125;);<br><br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// Promise 链式调用示例</span><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: &quot;Data fetched successfully!&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">processData</span>(result);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">processedResult</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processedResult); <span class="hljs-comment">// 输出: &quot;Processed: Data fetched successfully!&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">displayData</span>(processedResult);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">displayedResult</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(displayedResult); <span class="hljs-comment">// 输出: &quot;Displaying: Processed: Data fetched successfully!&quot;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>  &#125;);<br><span class="hljs-comment">// 使用 async/await 示例</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: &quot;Data fetched successfully!&quot;</span><br>    <br><br>    <span class="hljs-keyword">const</span> processedResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">processData</span>(result);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processedResult); <span class="hljs-comment">// 输出: &quot;Processed: Data fetched successfully!&quot;</span><br>    <br>    <span class="hljs-keyword">const</span> displayedResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">displayData</span>(processedResult);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(displayedResult); <span class="hljs-comment">// 输出: &quot;Displaying: Processed: Data fetched successfully!&quot;</span><br><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>  &#125;<br>&#125;<br><span class="hljs-title function_">run</span>();<br></code></pre></td></tr></table></figure>

<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>防抖<code>debounce</code>和节流<code>throttle</code>是两种常见的优化技术，用于处理高频触发的事件。<br>如果一个按钮同时有单双击事件，我们就会发现需要用到防抖。</p>
<p>防抖的核心思想是：在最后一次触发事件后等待一定时间才执行函数，如果在等待时间内再次触发函数则重新等待。</p>
<p>节流的核心思想是在规定时间间隔内，函数最多只执行一次，无论事件触发了多少次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 使用 apply 或 call 绑定 this</span><br>    &#125;, delay);<br>  &#125;;<br>&#125;<br><span class="hljs-comment">//节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">if</span> (now - lastTime &gt;= delay) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      lastTime = now;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><p>影响的原因就三点：<strong>服务器本身处理数据的能力</strong>，<strong>程序自设的请求超时</strong>，<strong>网络波动</strong>。解决方案是<strong>分片上传</strong>。</p>
<h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><p>前端有个文件（zip或者视频）要传到后端，咋做呢？</p>
<p>首先我们进行思考，一整个传过去肯定不现实，中间断了就得重传，那么我们把他拆分成好几个块异步并发上传不就好了。但是拆成块就有个问题，多个上传任务（单用户多文件&#x2F;多用户）那不是会乱掉，所以我们需要和服务端确认这个文件的唯一标识。</p>
<ol>
<li>第一步：初始化文件，使用<code>new FileReader()</code>创建一个对象，传文件名（大小等）给后端，后端返回唯一标识。</li>
</ol>
<blockquote>
<p>如果服务端已经有了完全上传好的文件（通过唯一标识判断），可以不用再上传，直接前端显示完成，这个过程称为秒传</p>
</blockquote>
<ol start="2">
<li>第二步：文件转化为Base64编码，按照数量或者大小进行分片</li>
</ol>
<blockquote>
<p>如果文件比较小或服务器需要控制并发量就按照数量切分；如果文件比较大或者网络带宽有限的时候就按照大小来切分（因为如果文件很大，切分之后还是很大，那就没啥用）；还有，不是分片分得越小越好，分片分得小说明需要高并发和多次网络请求。</p>
</blockquote>
<ol start="3">
<li>异步并发，带上唯一标识和此片的索引上传</li>
</ol>
<blockquote>
<p>如果某一片上传失败，后端可以返回错误信息，前端可以写一个重传机制，重新上传现在没有上传的分片 </p>
</blockquote>
<ol start="4">
<li>验证完整性：按照唯一标识和索引进行拼接</li>
</ol>
<blockquote>
<p>如果上传过程中关闭网页了，可以使用断点续传技术，前端在初始化的时候发现有这个任务的前半截，那就返回索引，继续上传。</p>
</blockquote>
<hr>
<blockquote>
<p>怎么才能不影响主线程工作上传文件？</p>
<p>可以使用Web Worker，<code>new Worker(&#39;js程序&#39;)</code>然后再用<code>postMessage()</code>去给他发送消息。</p>
<p>Web Worker可以允许网页在后台执行一些耗时的操作，而不会阻塞主线程，他允许开发者在JS主线程之外单开一个线程。</p>
</blockquote>
<h3 id="SSG、SSR、CRG"><a href="#SSG、SSR、CRG" class="headerlink" title="SSG、SSR、CRG"></a>SSG、SSR、CRG</h3><p>首先我们来了解一下页面渲染的全流程：</p>
<p>首先对你输入的URL进行<code>URL解析</code>，看看是一个合法的地址还是一个关键词。如果是合法地址，进行<code>DNS解析</code>，好现在确认好服务器地址了，我们就进行<code>TCP连接</code>，三次握手连接好了之后，发送<code>http请求</code>。</p>
<p>服务器收到请求之后对请求进行处理 &gt; 返回资源 &gt; <strong>解析HTML文件 &gt; 解析CSS文件 &gt; 执行JS文件 &gt; 构建渲染树（DOM和CSSOM结合） &gt; 布局 &gt; 绘制 &gt; 事件循环处理交互和页面更新</strong></p>
<p>好了我们再来说上面三个是啥。</p>
<h4 id="SSG"><a href="#SSG" class="headerlink" title="SSG"></a>SSG</h4><p>SSG是静态站点生成的意思，像我们一开始学习前端的时候直接写的三剑客（不加以其他东西）就属于静态站点，常见的还有博客之类的，这些都属于SSG，优点是服务器返回的资源不会再进行更改。</p>
<h4 id="CRG"><a href="#CRG" class="headerlink" title="CRG"></a>CRG</h4><p>CRG是客户端渲染的意思，我们可以看到页面渲染中会解析HTML文件、JS文件，之后构建渲染树，使用CRG的时候会先返回一个基础的HTML，只包含结构和对JS的引用，等到JS下载解析好之后会更新DOM树。这种方法比较常见，一般用于交互性强的应用，比如单页应用等。</p>
<blockquote>
<p>单页应用是一种现代的Web应用架构，会使用路由在单个HTML页面中动态的更新内容。我们常见的网站基本都是单页应用。</p>
</blockquote>
<h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><p>SSR是服务端渲染的意思，前面我们提到使用CRG的时候会先返回一个基础的HTML，只包含结构和JS的引用。而对于SSR来说，服务器会返回一个带有完整数据的HTML，后续就不会需要更新一轮DOM树了。因为他是完整的数据，且省了一轮DOM更新，所以首屏加载快，SEO友好（容易爬取内容），如下是一个SSR实现的简易代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 模拟数据获取函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;SSR 页面&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;这是服务器端渲染的内容&#x27;</span> &#125;;<br>&#125;<br><br><span class="hljs-comment">// 页面模板</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderTemplate</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">      &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;<span class="hljs-subst">$&#123;data.title&#125;</span>&lt;/title&gt;</span><br><span class="hljs-string">      &lt;/head&gt;</span><br><span class="hljs-string">      &lt;body&gt;</span><br><span class="hljs-string">        &lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">$&#123;data.content&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">        &lt;script&gt;</span><br><span class="hljs-string">          // 客户端代码（可选）</span><br><span class="hljs-string">          console.log(&#x27;页面已通过 SSR 渲染&#x27;);</span><br><span class="hljs-string">        &lt;/script&gt;</span><br><span class="hljs-string">      &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">  `</span>;<br>&#125;<br><br><span class="hljs-comment">// SSR 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/ssr&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取数据</span><br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetchData</span>();<br>  <span class="hljs-comment">// 渲染页面</span><br>  <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderTemplate</span>(data);<br>  <span class="hljs-comment">// 返回 HTML 给客户端</span><br>  res.<span class="hljs-title function_">send</span>(html);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动：http://localhost:3000/ssr&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="Web中常见的攻击方式有哪些"><a href="#Web中常见的攻击方式有哪些" class="headerlink" title="Web中常见的攻击方式有哪些"></a>Web中常见的攻击方式有哪些</h3><p>常见的一些攻击方式包括<code>XSS</code>、<code>CSRF</code>、<code>SQL注入</code></p>
<ul>
<li><p><code>XSS</code>(跨脚本攻击)：浏览器无法区分input输入框中的是正常的用户输入还是代码，这就会造成一些特殊的输入被当作代码执行。</p>
<p>解决方法：正则限制、转义字符等…</p>
</li>
<li><p><code>CSRF</code>(跨站请求伪造)：用户在访问a网站后，被诱导点击攻击网站，攻击网站向a网站发送请求，默认携带a的登录凭证，然后a就会以为用户在执行操作。</p>
<p>解决方法：双Token认证，同源检测…</p>
</li>
<li><p><code>SQL注入</code>：将恶意的sql查询或添加语句添加到应用的输入参数中，入侵和破坏数据库。</p>
<p>解决方法：正则限制、转义字符等…</p>
</li>
<li><p><code>ddos攻击</code>：向莫表服务器发送大量无意义的数据包，挤占网络带宽。</p>
<p>解决方法：对同IP限制请求速率等</p>
</li>
</ul>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h2 id="JavaScript-Prototype"><a href="#JavaScript-Prototype" class="headerlink" title="JavaScript - Prototype"></a>JavaScript - Prototype</h2><p>我特别将原型这个部分分了出来，因为我觉得有些概念理解需要渐进的，上面的比较分散，而这一章则是有顺序的，你可以从上往下读，我会带你逐渐了解这些复杂的概念。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>我们先从一切的源头开始看起，什么是构造函数？</p>
<p>首先构造函数是一个函数，那他肯定是形如<code>function fn ()&#123;&#125;</code>这样的。</p>
<p>第二，它是用于构造东西的，构造函数通常返回一个对象。我们使用<code>new</code>关键字来让构造函数创建对象，至于<code>new</code>到底干了什么，我们稍晚些再说。</p>
<p>我们常见的数据类型比如<code>Array</code> <code>String</code> 他们本身就是一个构造函数。当然我们也可以自己制造一个构造函数。</p>
<blockquote>
<p>字符串对象和普通字符串是不一样的，普通字符串的性能更优。</p>
</blockquote>
<p>构造函数到底是拿来干什么的，一言蔽之就是用来创建包含相同属性、方法的对象实例的。</p>
<blockquote>
<p>后面会用到<code>instanceof</code>，你如果没见过就理解为：如果是由这个构造函数构造出来的就为true 否则为false(当然这个是不准确的说法，只是为了理解)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">10</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;use&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> cup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cup</span>(<span class="hljs-string">&#x27;kitty&#x27;</span>)<br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cup <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cup</span>,cup.<span class="hljs-property">size</span>,arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)<span class="hljs-comment">//true 10 true</span><br>cup.<span class="hljs-title function_">use</span>()<span class="hljs-comment">//use</span><br></code></pre></td></tr></table></figure>

<p>关键的东西来了：</p>
<p>构造函数有一个<code>prototype</code>属性，指向一个对象，这个对象上的方法和属性会被所有用这个构造函数创建的实例共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cup</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Cup</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = <span class="hljs-number">1</span><br><span class="hljs-title class_">Cup</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fn</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> cup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cup</span>()<br><span class="hljs-keyword">const</span> bottle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cup</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cup.<span class="hljs-property">value</span>,bottle.<span class="hljs-property">value</span>)<span class="hljs-comment">//1 1</span><br>cup.<span class="hljs-title function_">fn</span>()<span class="hljs-comment">//fn</span><br>cup.<span class="hljs-property">value</span> = <span class="hljs-number">3</span><br><span class="hljs-title class_">Cup</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = <span class="hljs-number">2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cup.<span class="hljs-property">value</span>,bottle.<span class="hljs-property">value</span>)<span class="hljs-comment">//3 2</span><br></code></pre></td></tr></table></figure>

<h3 id="静态方法与实例方法"><a href="#静态方法与实例方法" class="headerlink" title="静态方法与实例方法"></a>静态方法与实例方法</h3><blockquote>
<p>我们总是能看见一些方法是形如<code>Array.isArray(obj)</code>，另一些方法是形如<code>obj.splice()</code>，有啥区别呢？</p>
</blockquote>
<p>前者是静态方法，定义在<code>Array</code><strong>类</strong>上，不依赖于实例的状态，不需要创建实例。</p>
<p>后者是实例方法，定义在类的原型链上，用来处理类的实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">test</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">//创建实例方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1&#x27;</span>);<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Array</span>, <span class="hljs-string">&#x27;test&#x27;</span>, &#123;<span class="hljs-comment">//创建静态方法——可配置版</span><br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//可写</span><br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//可配置</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">//不可枚举</span><br>&#125;)<br><span class="hljs-comment">//或者</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<span class="hljs-comment">//创建静态方法——快速不可配置版</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br><br><span class="hljs-keyword">const</span> testArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br>testArr.<span class="hljs-title function_">test</span>()<span class="hljs-comment">//test1</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;test2&#x27;</span>)<span class="hljs-comment">//test2</span><br></code></pre></td></tr></table></figure>

<h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><p>好的，接下来我们来讲讲<code>new</code>到底干了啥玩意。</p>
<p>首先我们之前提到构造函数返回的一般是一个新创建的对象，但是也有特殊情况，若构造函数返回一个普通对象，那么new不再返回新构造的对象，而是返回这个普通对象。</p>
<p>有点绕对吧，来看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Special</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">a</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">f1</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Normal</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-keyword">const</span> special = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Special</span>()<br><span class="hljs-keyword">const</span> normal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Normal</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(special,normal)<span class="hljs-comment">//&#123;a:0,f1:function()&#123;console.log(1)&#125;&#125;  Normal</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(special <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Special</span>,normal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Normal</span>)<span class="hljs-comment">//false true</span><br></code></pre></td></tr></table></figure>

<p>我们使用<code>new</code>将一个给定的构造函数创建一个实例对象。<code>new</code>做了如下事情：</p>
<ul>
<li><p>创建一个新的对象</p>
</li>
<li><p>将对象指向构造函数</p>
<blockquote>
<p>所有对象都有一个<code>__proto__</code>专门用来指向构造函数，用于实现构造函数的属性和方法的继承</p>
</blockquote>
</li>
<li><p>将构造函数的this指向对象</p>
<blockquote>
<p>使用<code>apply</code>函数实现换绑，同时调用Fun拿到一个返回值</p>
</blockquote>
</li>
</ul>
<p>可以写成下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">Fun,...args</span>)&#123;<span class="hljs-comment">//args用于接收构造函数的参数</span><br>	<span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    obj.<span class="hljs-property">_proto_</span> = <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Fun</span>.<span class="hljs-title function_">apply</span>(obj,args)<br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>?<span class="hljs-attr">result</span>:obj;<span class="hljs-comment">//用来处理特殊情况,如果返回普通函数就返回</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>很好你已经学会什么是构造函数，构造函数的结构，如何用构造函数创建一个实例对象了，接下来学点难的。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象中的一个概念，继承可以让子类具有父类的各种属性和方法，不需要再编写相同的代码，并且在子类别继承父类别的同时，可以重新定义某些属性、方法，获得不同的功能。</p>
<p>属性和方法有不同的继承方式（原因下面会解释）：</p>
<p>构造函数继承（继承属性）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;P&#x27;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Children</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;C&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Children</span>()<br><span class="hljs-keyword">const</span> test2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test,test2);<span class="hljs-comment">//Children &#123;name: &#x27;P&#x27;, value: &#x27;C&#x27;&#125; Parent &#123;name: &#x27;P&#x27;&#125;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>不知道你会不会好奇<code>call</code>改变了<code>this</code>的指向，为什么还能获取到<code>Parent</code>的<code>name</code>，因为<code>call</code>只是临时改变了<code>Parent</code>的上下文，不改变他的定义。</p>
</blockquote>
<p>原型链继承（继承方法） </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//写法一 每一个new Child，创建出来的每一个实例改变父类属性时都会影响到父类。</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-comment">//写法二 创建原型链继承的现代方法</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br></code></pre></td></tr></table></figure>

<p>对于写法一：</p>
<p>如果 <code>Parent </code>的构造函数中有依赖于 <code>this</code>的逻辑，可能会导致意外行为。</p>
<p>当构造函数的 <code>prototype </code>和实例自身的属性有同名属性时，实例对象会优先访问自身的属性，而不是原型链上的属性。这是因为<code>JavaScript</code>的属性查找机制会先在实例对象上查找，如果找不到才会沿着原型链向上查找。（这也是为什么属性和方法要分开继承）</p>
<p>所以，当使用<code>Child.prototype = new Parent()</code>时，Parent的属性会被存入到Child的prototype中，但是如果Child构造函数自身拥有同名属性时，Child构造出来的实例会优先继承Child中的属性，但是Parent在构造原型链的时候已经被调用一次，这就有可能导致一些问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Parent 构造函数被调用&quot;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Child 构造函数被调用&quot;</span>);<br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<span class="hljs-comment">//Parent 构造函数被调用</span><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">count</span>); <span class="hljs-comment">// 输出 0</span><br><span class="hljs-comment">//这里只是调用了一个log如果里面写入一些抽象逻辑，就会出bug。</span><br></code></pre></td></tr></table></figure>

<p>对于写法二：</p>
<p>首先构造函数的<code>prototype</code>中除了拥有继承的属性、方法之外还拥有一个特殊的属性<code>constructor</code>，这个函数用于指向其本身。这个属性的键为<code>constructor</code>，值为构造函数本身。</p>
<p><code>Child.prototype = Object.create(Parent.prototype)</code>目的是创建一个和Parent一模一样的构造函数Child。</p>
<p>以上这一步做到了复制构造函数的原型对象，但是我们把constructor也给复制过来了，这时候就要改一下指向，将constructor指向构造函数本身，这么做的目的是为了防止后续的指向性问题。</p>
<h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h3><p>浅拷贝指创建新的数据，如果属性是基本类型，则为其字面量；如果属性为引用类型，拷贝的就是内存地址。即浅拷贝出来的对象还是指向同一个内存地址。</p>
<blockquote>
<p>eg.<code>slice()</code>、<code>concat()</code></p>
</blockquote>
<p>深拷贝则是开一个新的栈，基本类型的值也是拷贝字面量；但是如果是引用类型，值相同但是会有不同的内存地址。即深拷贝出来的对象不指向同一个内存地址。</p>
<blockquote>
<p>eg.<code>JSON.stringify()</code>、<code>structuredClone()</code></p>
<p><code>structuredClone()</code>在Node17后支持，而且相较于传统的<code>stringify</code>而言，此函数可以保留对象的类型和结构，传统方法无法处理特殊的对象。</p>
</blockquote>
<p>简而言之：浅拷贝只复制其字面量不改变新值的内存地址（还是指向旧的值），深拷贝则会改变赋予一个新的内存地址。因为浅拷贝只会复制其字面量而不更改地址，当对新值进行修改时，旧的值也会被修改。但是由于基本数据类型是存在栈中的，而对象是存在堆中的。所以深拷贝是对于对象而言的。</p>
<blockquote>
<p>堆和栈的区别：栈<code>Stack</code>是一种后进先出的数据结构，栈中的内存由编译器自动分配和释放，不需要程序员手动管理。堆<code>Heap</code>是一种动态内存分配的区域，堆中的内存需要程序员手动分配。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//深拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// &#123;name: &quot;A&quot;&#125;</span><br><br><span class="hljs-comment">//浅拷贝</span><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = obj1;<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;B&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>手写深拷贝：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj,hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>)&#123;<span class="hljs-comment">//用weakmap是因为垃圾回收策略，避免内存泄漏</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>||obj === <span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> obj<span class="hljs-comment">//不是对象直接返回即可，深拷贝是对于对象而言的</span><br>    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>    <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<span class="hljs-comment">//日期、正则对象可以使用他们内置的拷贝构造函数</span><br>    <span class="hljs-keyword">if</span>(hash.<span class="hljs-title function_">has</span>(obj))<span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)<span class="hljs-comment">//有了就返回</span><br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//拿某个对象的原型对象构造出来的对象</span><br>    hash.<span class="hljs-title function_">set</span>(obj, cloneObj);<span class="hljs-comment">//加到hash中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<span class="hljs-comment">//一层一层向下找</span><br>        <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<span class="hljs-comment">//如果不是继承的就进if</span><br>            cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<span class="hljs-comment">//递归拿到不是继承的属性的键</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么是<code>new obj.constructor()</code>而不是<code>new obj.__proto__.constructor()</code>？</p>
<p>其实都可以，每一个对象都有<code>constructor</code>和<code>__proto__</code>，前者指向这个对象的构造函数，后者指向这个对象的构造函数的<code>prototype</code></p>
</blockquote>
<h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><p>JS中 每一个对象都有一个原型对象，当访问一个对象的属性的时候，JS不仅会在对象上寻找，还会搜索该对象的原型，以及该对象原型的原型（这叫做原型链）直到匹配或者到达原型链的末尾。</p>
<blockquote>
<p>什么是对象的属性：对象的属性是用来描述对象状态或者特征的，属性可以包含各种各样的数据，可以是基本数据也可以是函数、对象等，每个属性都有一个键值对。</p>
</blockquote>
<p>也就是说，这些属性和方法是定义实例对象的构造函数的<code>prototype</code>而非实例本身。</p>
<blockquote>
<p>我们将构造函数的<code>prototype</code>称为实例对象的原型。</p>
</blockquote>
<p>实例通过<code>__proto__</code>属性上溯原型链，每个原型都有<code>prototype</code>，而<code>prototype</code>又有<code>constructor</code>属性来指向该原型（<code>constructor</code>主要就是用于指向确认该原型）</p>
<p>现代通过<code>Object.getPrototypeOf()</code>来溯源，这种方法更加直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;<br>    A.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;b&#x27;</span><br>&#125;<br><br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = B;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params"></span>) &#123;<br>    B.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = <span class="hljs-string">&#x27;c&#x27;</span><br>&#125;<br><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = C;<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(c), c.<span class="hljs-property">__proto__</span>);<span class="hljs-comment">//B B</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(c)),c.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>);<span class="hljs-comment">//A A</span><br></code></pre></td></tr></table></figure>

<h2 id="JavaScript-Type"><a href="#JavaScript-Type" class="headerlink" title="JavaScript - Type"></a>JavaScript - Type</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型有六种。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Number</span><br> <span class="hljs-keyword">let</span> intNum = <span class="hljs-number">1</span>,octNum = <span class="hljs-number">001</span>,hexNum = <span class="hljs-number">0x1</span> <span class="hljs-comment">//整数，常见十进制、八进制、十六进制</span><br><span class="hljs-keyword">let</span> floatNum = <span class="hljs-number">0.1</span>,eNum = <span class="hljs-number">1.11e7</span><span class="hljs-comment">//可以表示科学计数法e后面是幂</span><br> <span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>) <span class="hljs-comment">//返回NaN 意思是本来返回数值的操作失败</span><br><span class="hljs-comment">//另外NaN===NaN 返回false</span><br></code></pre></td></tr></table></figure>

<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Undefined</span><br> <span class="hljs-keyword">let</span> message,<span class="hljs-title function_">log</span>(message)<span class="hljs-comment">//返回undefined，变量声明过但未被初始化。</span><br></code></pre></td></tr></table></figure>

<hr>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//String</span><br> <span class="hljs-keyword">let</span> <span class="hljs-title class_">AStr</span> = <span class="hljs-string">&quot;1&quot;</span>,aStr = <span class="hljs-string">&#x27;1&#x27;</span>,someStr = <span class="hljs-string">`1`</span><span class="hljs-comment">//字符串一旦被创建，值就不可以再被改变，如果执行改变的操作，会先销毁再创建。</span><br></code></pre></td></tr></table></figure>

<hr>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Null</span><br> <span class="hljs-keyword">let</span> nullOne = <span class="hljs-literal">null</span>,<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> nullOne)<span class="hljs-comment">//null是一个空对象指针，输出为Object，如果变量要保存对象，但是当时又没有对象可以保存，就用null填充。</span><br><span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span>==<span class="hljs-literal">undefined</span>)<span class="hljs-comment">//undefined是由null派生来的，返回为真</span><br></code></pre></td></tr></table></figure>

<hr>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Boolean</span><br> <span class="hljs-comment">//对于非空字符串、数值、对象、N/A 转为布尔值为true</span><br><span class="hljs-comment">//对于&quot;&quot;、0、NaN、null、undefined 转为布尔值为false</span><br></code></pre></td></tr></table></figure>

<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Symbol</span><br> <span class="hljs-keyword">let</span> aSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>),bSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>),<span class="hljs-title function_">log</span>(aSymbol==bSymbol)<span class="hljs-comment">//返回false，symbol是原始值，symbol实例是唯一且不可变的，symbol的作用是确保对象属性使用唯一标识符。</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型统称为<code>object</code>，包括<code>object</code> <code>array</code> <code>function</code> <code>Date</code> <code>RegExp</code> <code>Map</code> <code>Set</code> </p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Object对象</span><br> <span class="hljs-keyword">let</span> man = &#123; <span class="hljs-comment">// 属性名可以是字符串或者数值</span><br>	<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zero&quot;</span>,<br> 	<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">1</span>,<br> 	<span class="hljs-number">1</span>:<span class="hljs-literal">true</span><br> &#125;<br></code></pre></td></tr></table></figure>

<hr>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Array</span><br> <span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">2</span>, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;] <span class="hljs-comment">//JS数组是动态大小的，每个槽位可以存储任意类型数据的。</span><br></code></pre></td></tr></table></figure>

<hr>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Function</span><br> <span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2</span>) =&gt; &#123;<br> <span class="hljs-keyword">return</span> num1 + num2;<br> &#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p> 基本数据类型和引用数据类型存储在内存中的位置不同：</p>
<ul>
<li>基本数据类型存储在栈中</li>
<li>引用类型的对象存储于堆中</li>
</ul>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// 赋值操作</span><br>b = <span class="hljs-number">20</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 10值</span><br><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">var</span> obj2 = obj1;<span class="hljs-comment">//这个操作让obj1和2的引用地址相同了。</span><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>JS为了处理大整数，提供了一个原生的数据类型<code>BigInt</code>。</p>
<p>下面是创建的两个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bigInt1 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123456789123456789</span>)<span class="hljs-comment">//用BigInt包裹</span><br><span class="hljs-keyword">let</span> bigInt2 = <span class="hljs-number">1234567981324697n</span> <span class="hljs-comment">//在末尾加n</span><br></code></pre></td></tr></table></figure>

<p><code>BigInt</code>类型只能和同类型做运算。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><h4 id="迭代器生成方式及使用方式"><a href="#迭代器生成方式及使用方式" class="headerlink" title="迭代器生成方式及使用方式"></a>迭代器生成方式及使用方式</h4><p>某些方法会返回一个迭代器，如<code>arr.entries()</code>返回一个带有全部键值对的迭代器，使用<code>next()</code>方法返回迭代器结果对象。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br><span class="hljs-keyword">const</span> iterator1 = array1.<span class="hljs-title function_">entries</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator1.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-comment">// Expected output: Array [0, &quot;a&quot;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator1.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);<br><span class="hljs-comment">// Expected output: Array [1, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure>

<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="数组长度与空槽"><a href="#数组长度与空槽" class="headerlink" title="数组长度与空槽"></a>数组长度与空槽</h4><p><code>arr.length</code>可以输出数组长度，甚至可以更改<code>arr.length</code>去改变数组长度，如果用此法扩展数组长度，没有被赋值的地方会产生<code>空槽</code>，<code>空槽</code>无法输出，对于不同数组方法，<code>空槽</code>也有不同的行为。</p>
<p>如<code>forEach</code>等迭代方法根本不会访问空槽。而其他的拼接复制方法如<code>concat</code>则会保留空槽。一些较新的方法会视其为undefined 如<code>splice()</code>拼接数组，<code>join()</code>等。</p>
<hr>
<h4 id="常用的数组方法"><a href="#常用的数组方法" class="headerlink" title="常用的数组方法"></a>常用的数组方法</h4><ul>
<li><code>every()/some()</code>-对数组内所有元素执行括号内函数，全部通过&#x2F;有一个通过返回布尔值。</li>
<li><code>fill(target,start,end)</code>-对数组内指定索引覆盖target值，超出范围不会扩展数组。</li>
<li><code>find()/findLast()</code>-返回括号内函数符合条件的第一个&#x2F;最后一个值，否则返回undefined。</li>
<li><code>findIndex()/findLastIndex()</code>-返回括号内函数符合条件的第一个&#x2F;最后一个索引，否则返回undefined。</li>
<li><code>indexOf()/lastIndexOf()</code>-返回括号内值符合条件的第一个值&#x2F;最后一个值的索引，否则返回-1。</li>
<li><code>flat()</code>-扁平化数组，括号内为深度，ES10新语法</li>
<li><code>includes()</code>-判断数组是否包含一个值，返回布尔值，ES7新语法</li>
<li><code>join()</code>-将一个数组更改为其各元素以括号内字符串连接的字符串，默认使用逗号，如目标数组不是纯数组，报错。</li>
<li><code>pop()/push()</code>-移除&#x2F;添加数组末尾一个元素并返回该值，如果push的是一个数组则会在末尾添加数组，push自身会导致循环引用。</li>
<li><code>shift()/unshift()</code>-移除&#x2F;添加数组第一个元素并返回该值</li>
<li><code>reverse()/toReversed()</code>-转置原数组改变原数组&#x2F;转置原数组不改变原数组，<code>toReversed()</code>ES14新语法</li>
<li><code>slice(start,end)</code>-浅拷贝一个由start开始end结束的数组，不改变原数组。</li>
<li><code>sort()/toSorted()</code>-对数组按照元素第一个字符的ascii码排序改变原数组&#x2F;不改变原数组</li>
<li><code>splice(start,num,value...)/toSpliced()</code>-删除由start开始的num个数值，并在start索引下添加value值，改变原数组&#x2F;不改变原数组。</li>
</ul>
<hr>
<blockquote>
<p><strong>forEach、filter、map、reduce的区别:</strong></p>
<p>三者都是ES5的新特性，均用于数组。</p>
<p><code>forEach</code>遍历数组全部元素并对数组进行操作，不返回新数组，return用于跳出循环，返回undefined。</p>
<p><code>filter</code>遍历数组全部元素并使用判断语句返回新数组，return值为假的时候过滤。</p>
<p><code>map</code>遍历数组全部元素并操作数组产生新数组，不改变原数组。</p>
<p><code>reduce((accumulator, currentValue)=&gt;...,initialValue)</code>-遍历数组，若initialValue设置则为初始accumulator值，若没设置则currentValue为数组第一个值，不可处理数组对象。</p>
</blockquote>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//设分别执行三种函数</span><br><span class="hljs-keyword">let</span> arr = [<br>&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>&#125;,<br>&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小华&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">11</span>&#125;,<br>&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">15</span>&#125;,<br>&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小黄&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">17</span>&#125;,<br>]<br><br><span class="hljs-keyword">let</span> forEachBack = arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>item.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;学生&quot;</span>+item.<span class="hljs-property">name</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(forEachBack)<span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//name前都加上学生</span><br><br><span class="hljs-keyword">let</span> filterBack = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> item.<span class="hljs-property">age</span>&gt;<span class="hljs-number">10</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterBack)<span class="hljs-comment">//包含有name属性的，每一项age大于10的新数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//arr不变</span><br><br><span class="hljs-keyword">let</span> filterBack = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> item.<span class="hljs-property">age</span>&gt;<span class="hljs-number">10</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterBack)<span class="hljs-comment">//包含有name属性的，每一项age大于10的新数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//arr不变</span><br><br><span class="hljs-keyword">let</span> mapBack = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> item.<span class="hljs-property">age</span> + <span class="hljs-number">1</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapBack)<span class="hljs-comment">//不包含有name属性的，每一项age加1的新一维数组：[15,12,16,18]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//arr不变</span><br><br><span class="hljs-keyword">let</span> initialValue = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> reduceBack = mapBack.<span class="hljs-title function_">reduce</span>(<br><span class="hljs-function">(<span class="hljs-params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue,<br>initialValue<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reduceBack)<span class="hljs-comment">//60 = -1 + 15 + 12 + 16 +18</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//arr不变</span><br></code></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><code>String()</code>作为函数调用时，返回字面量原始值。<code>String()</code>作为构造函数（使用<code>new</code>）被调用时，会创建一个String对象，该对象不是原始类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">// a === &quot;Hello world&quot; 为 false</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">// b === &quot;Hello world&quot; 为 true</span><br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// 为 true</span><br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// 为 false</span><br><span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="常用的字符串方法"><a href="#常用的字符串方法" class="headerlink" title="常用的字符串方法"></a>常用的字符串方法</h4><ul>
<li><code>concat(value,str)</code>-以value值拼接两个字符串。</li>
<li><code>endsWith(value,index)/endsWith()</code>-查找字符串是否以value结尾&#x2F;开头，index为查找的末尾索引+1，返回布尔值。</li>
<li><code>includes(value)</code>-查找value值，返回布尔值。</li>
<li><code>indexOf(searchString, position)/lastIndexOf()</code>-查找第一次&#x2F;最后一次出现searchString的索引，position为查找开始的索引，默认为0。</li>
<li><code>match()/search()</code>-匹配正则表达式，返回匹配的字符的数组&#x2F;索引。</li>
<li><code>replace(value,origin)/replaceAll()</code>-匹配字符串value替换origin，返回替换后的字符串。</li>
<li><code>slice(start,end)</code>-提取字符串的一部分返回新字符串，不改变原字符串。</li>
<li><code>split(rule)</code>-按照rule模式将字符串分割成一个数组，返回该数组。</li>
<li><code>toLowerCase()/toUpperCase()</code>-全部换成小写&#x2F;大写</li>
<li><code>trim()</code>-从字符串两端移除空白字符，返回新字符，不修改原来的字符。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map对象保存键值对，并且可以记住键的原始插入顺序，任何值都可以作为键或者值。比较适合多次查找的情况。</p>
<blockquote>
<p> <strong>Object和Map的区别：</strong></p>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">Map</th>
<th align="center">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="center">键的类型</td>
<td align="center">Map的键可以是任何值</td>
<td align="center">Object的键必须为字符串或者Symbol</td>
</tr>
<tr>
<td align="center">键的顺序</td>
<td align="center">Map的对象按照插入的顺序迭代</td>
<td align="center">Object的排序就很混乱，ES6之后按照属性创建顺序迭代</td>
</tr>
<tr>
<td align="center">迭代</td>
<td align="center">可迭代对象，可以使用for of</td>
<td align="center">不可迭代，默认只能用for in</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">在涉及频繁添加和删除键值对的场景中表现更好。</td>
<td align="center">在涉及频繁添加和删除键值对的场景中表现更好。</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<h4 id="常用的map方法"><a href="#常用的map方法" class="headerlink" title="常用的map方法"></a>常用的map方法</h4><ul>
<li><code>clear()</code>-清除所有元素</li>
<li><code>delete()</code>-删除指定键的值</li>
<li><code>forEach()</code>-对每一个键&#x2F;值进行一次操作</li>
<li><code>get()</code>-获取指定键的值，一般并对其进行后续处理。</li>
<li><code>has()</code>-检查指定键是否存在，返回布尔值。</li>
<li><code>keys()/values()</code>-返回一个迭代器对象，该对象包含了此map中每个元素的键&#x2F;值</li>
<li><code>set()</code>-向map中添加一个指定的键值对。</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>表示对异步操作的完成或者失败及其结果。</p>
<h4 id="常用的Promise方法"><a href="#常用的Promise方法" class="headerlink" title="常用的Promise方法"></a>常用的Promise方法</h4><ul>
<li><code>all()</code>-同时执行所有的异步任务，如果有一个执行失败，那么失败。（用于异步并发上传文件）</li>
<li><code>allSettled()</code>-同时测试执行所有的异步任务，返回一个描述promise状态的数组。</li>
<li><code>race()</code>-只要有一个promise完成，无论成功与否返回结果。</li>
<li><code>any()</code>-只要有一个promise成功，返回成功结果，否则等待所有失败返回错误。</li>
<li><code>resolve()</code>-将promise对象以成功标志返回。</li>
<li><code>then()</code>-promise对象以成功标志返回时，执行then中的语句</li>
<li><code>reject()</code>-将promise对象以失败标志返回。</li>
<li><code>catch()</code>-promise对象以失败标志返回时，执行catch中的语句</li>
<li><code>finally()</code>-promise对象最终一定执行此代码块中的语句</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找返回值的时候有两个移动目标就是双指针，可以用二重遍历暴力循环。</p>
<p>这里用的是Map存值+一轮循环+Map查找。</p>
<blockquote>
<p>map的set两个参数是值和键，容易搞反。</p>
</blockquote>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> saver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">let</span> result = []<br>    nums.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> ret = saver.<span class="hljs-title function_">get</span>(target-item)<br>        <span class="hljs-keyword">if</span>(ret!==<span class="hljs-literal">undefined</span>&amp;&amp;index!==ret)&#123;<br>            result = [index,ret]<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        saver.<span class="hljs-title function_">set</span>(item,index)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="柯里化调用"><a href="#柯里化调用" class="headerlink" title="柯里化调用"></a>柯里化调用</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>写一个sum函数支持<code>sum(a,b)</code> <code>sum(a)(b)</code> 两种调用方式。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用闭包的特性，如果接收两个参数则直接相加，如果执行两次则第一次返回一个函数。</p>
<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (b !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">return</span> a+b<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">b</span>) &#123;<br>            <span class="hljs-keyword">return</span> a+b<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="带并发限制的异步调用器"><a href="#带并发限制的异步调用器" class="headerlink" title="带并发限制的异步调用器"></a>带并发限制的异步调用器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">timer</span> = (<span class="hljs-params">time</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, time);<br>&#125;)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">limit</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span> = limit<br>    &#125;<br><br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">Task</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>i)).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Task</span>))<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> task = <span class="hljs-title class_">Task</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">add</span>(task)<br>            task.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">delete</span>(task)<br>            &#125;)<br>            <span class="hljs-keyword">return</span> task<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> schedule = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scheduler</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params">name,time</span>) =&gt; &#123;<br>    schedule.<span class="hljs-title function_">add</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">timer</span>(time)).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name))<br>&#125;<br><br><span class="hljs-title function_">addTask</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">500</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">300</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">400</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Promise.race是同时执行里面的内容，但是只返回先完成的那一个。</p>
</blockquote>
<h2 id="Promiser"><a href="#Promiser" class="headerlink" title="Promiser"></a>Promiser</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncAdd</span>(<span class="hljs-params">a, b, callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">callback</span>(a + b);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br> <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promisify</span> = (<span class="hljs-params">fn</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">fn</span>(...args, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(result);<br>        &#125;);<br>      &#125;);<br>    &#125;;<br>  &#125;;<br> <br> <span class="hljs-comment">// 将 asyncAdd 转换为 Promise 风格的函数</span><br> <span class="hljs-keyword">const</span> addPromise = <span class="hljs-title function_">promisify</span>(asyncAdd);<br> <br> <span class="hljs-comment">// 使用转换后的函数</span><br><span class="hljs-title function_">addPromise</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res&#x27;</span>, data);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>将一个普通函数promise化。</p>
<h1 id="实际面试环节"><a href="#实际面试环节" class="headerlink" title="实际面试环节"></a>实际面试环节</h1><p>这里只记录一些我录音了或者有意义的面试。</p>
<h2 id="2024-10-15海康威视"><a href="#2024-10-15海康威视" class="headerlink" title="2024.10.15海康威视"></a>2024.10.15海康威视</h2><ul>
<li><p>你的上一段实习有什么亮点&#x2F;难点？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原答：需要对给过来的一些数据进行处理。<br><br>修正：当时作为初学者接到的任务都不是很难，主要遇到的困难有使用Element Plus样式穿刺、组件间传值这些问题。<br></code></pre></td></tr></table></figure>
</li>
<li><p>JS中常用的数据结构类型有哪些？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原答：7种，number，undefined，string，null，boolean，symbol，其他的类型统称object，object可能包含对象、数组、函数之类的。<br><br>修正：JS中有六种基本的数据类型，分别是number、string、boolean还有undefined、null和symbol。除此之外还有一个复杂数据类型object，它包含了对象、数组和函数等，这些对象可以用来构建更复杂的数据结构，例如链表、树等。<br></code></pre></td></tr></table></figure>
</li>
<li><p>JS怎么处理大整形类型？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原答：一般是用bigint，对数据转化成大整形类型之后如果需要加加减减的话就要加n，比如加一就是加一n<br><br>修正：在JS中处理大整数，可以使用BigInt类型，它允许你安全地表示和操作超出Number类型安全范围的大整数。使用BigInt时，只需要在数值后面加上n或者用BigInt()函数来创建。进行算数运算时，必须所有操作数都是BigInt类型，BigInt与Number不兼容。<br></code></pre></td></tr></table></figure>
</li>
<li><p>JS的Map和对象有什么区别？</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原答：Map和对象的一些方法属性可能不同，比如has、get之类的。<br><br>修正：首先Map的键可以是任意类型的，对象的键在访问的时候总是被当作字符串处理。迭代顺序不同，对象是按照属性创建时间迭代，Map是按照添加到map的顺序迭代。对象没有内置方法取得键值，Map有keys，values之类的。数据规模小时使用对象，数据规模大时使用map，因为map是为了快速查找而优化的。对象有原型链，Map没有原型链。<br></code></pre></td></tr></table></figure>
</li>
<li><p>怎么获取对象的属性值？返回一个数组，数组是对象的所有值怎么写？</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原答：直接用键获取就可以了，用<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">values</span>()即可返回数组。<br><br>修正：可以使用<span class="hljs-keyword">Object</span>的静态方法<span class="hljs-keyword">values</span>，也可以使用forin循环中间包一个obj.hasOwnProperty(key)用于确保该键是此对象的，而不是继承下来的。<br></code></pre></td></tr></table></figure>
</li>
<li><p>对象可以直接用for of循环拿这些值吗？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">原答：可以，直接用<span class="hljs-keyword">for</span> <span class="hljs-title class_">of</span>应该就可以拿到。<span class="hljs-comment">//你知道什么是可迭代对象吗？对象还可以用for of拿这些值吗？</span><br><br>修正：不可以，<span class="hljs-keyword">for</span> <span class="hljs-title class_">of</span>是用于遍历可迭代对象的每个元素，例如数组 字符串 Map Set。<span class="hljs-keyword">for</span> <span class="hljs-title class_">in</span>用于遍历一个对象的所有可枚举的属性，包括其原型链上继承的。<br></code></pre></td></tr></table></figure>
</li>
<li><p>讲一下原型链吧</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">原答：意思是说每一个对象，每一个对象构建的时候需要用构造函数去构造原型。每一个对象都有一个prototype指向它的属性，里面还有一个constructor指向他自己，如果我需要用一个构造函数去构造一个新的对象的话，新的对象也会有一个<span class="hljs-emphasis">_proto_</span>指向原来的构造函数，如果想要获取一开始的构造函数的话，可以用原型链溯源往上找。<br><br>修正：原型链是一个用于实现继承的机制，每个对象都有一个内部属性，叫做prototype，这个内部属性引用了另一个对象，称为该对象的原型，代码中一般用getPrototypeOf去获取。这个对象的原型又有一个原型，这样一直往上就是原型链。如果想要访问一个对象的属性时，该对象本身没有这个属性，JS会沿着原型链网上找直到找到或者达到末端。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你有一个实例，怎么通过这个实例拿到他的构造函数？</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">原答：可以通过循环访问_proto_去找他的原型，如果寻找到的原型的prototype和实例的相同，那就说明这是他的构造函数。<span class="hljs-comment">//不对，八股文背得太浅了，没有理解本质</span><br><br>修正：可以使用对象.<span class="hljs-keyword">constructor</span>获取其构造函数，但是这个值其实可以被覆盖的。如果需要更稳健的方法，那可能得创建实例的时候就保存这个引用关系。<br></code></pre></td></tr></table></figure>
</li>
<li><p>什么是构造函数，什么是原型对象？</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">原答：构造函数就是用于构造对象的函数，原型对象就是你要创建一个实例的一个对象，比如我<span class="hljs-keyword">new</span> Person()，Person就是他的原型对象。<br><br>修正：构造函数是用于创建函数的函数，当用<span class="hljs-keyword">new</span>关键字调用了一个函数时，这个函数就成为了一个构造函数。构造函数会创建一个新的对象，这个对象会继承构造函数prototype的属性和方法。原型对象是指某个对象中prototype所指向的对象，每个对象都有一个对象原型，该对象从其对象原型中继承相关的属性和方法。<br></code></pre></td></tr></table></figure>
</li>
<li><p>在Vue场景下，让你封装一个Vue组件，组件实现一个登录表单界面，一个name一个password，要求创建一个子组件给别人用，别人通过v-model传进来，你的表单里也是有一个name和password，如果后续你的表单扩了，后续别人也是通过v-model传，你的这个自定义组件的v-model怎么实现？</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gams">原答：不太理解 <br><span class="hljs-comment">//那你v-model怎么用的？ </span><br>原答：绑定我所需要的一些input之类的 <br><span class="hljs-comment">//那自己写的组件不可以用v-model吗？ </span><br>原答：直接赋值不就行了吗？<br><span class="hljs-comment">//什么是v-model</span><br>原答：是用vue的时候写在盒子里的用于双向绑定的。<br><span class="hljs-comment">//那如果我绑定在你自定义的属性上面呢？v-model是为了解决什么问题？</span><br>原答：是为了解决视图到模型的问题吧<br><br>修正：可以使用一个对象来作为v-<span class="hljs-keyword">model</span>的值，并且为每一个属性创建一个input事件，这样在调用这个组件的时候外面只管传一个对象即可。<br><br>修正：v-<span class="hljs-keyword">model</span>是用于表单输入和应用状态之间创建数据双向绑定，对于自定义组件，可以使用defineModel来简化v-<span class="hljs-keyword">model</span>，接收传入的值和及时返回改变的值。<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2024-10-16云合智网"><a href="#2024-10-16云合智网" class="headerlink" title="2024.10.16云合智网"></a>2024.10.16云合智网</h2><ul>
<li><p>ES6有接触过吗，用过里面的哪些东西呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原答：用过<span class="hljs-title class_">Map</span>之类的，和箭头函数。<br><br>修正：使用过箭头函数、模板字符串、解构赋值、<span class="hljs-title class_">Promise</span>异步、<span class="hljs-keyword">let</span>和<span class="hljs-keyword">const</span>、<span class="hljs-title class_">Map</span>等。<br></code></pre></td></tr></table></figure>
</li>
<li><p>能说一下箭头函数有哪些优势吗？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">原答：箭头函数和普通函数的区别是写法不同，箭头函数的<span class="hljs-keyword">this</span>指向它本身，普通函数的<span class="hljs-keyword">this</span>按照JS规定指向，普通函数可以用new去构造，箭头函数不可以。<br><br>修正：箭头函数的出现让函数的书写变得很简洁，除此之外还解决了<span class="hljs-keyword">this</span>执行环境所造成的一些问题，比如匿名函数和setTimeout的<span class="hljs-keyword">this</span>指向问题。<br></code></pre></td></tr></table></figure>
</li>
<li><p>Map的键可以有哪些类型？</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">原答：<span class="hljs-built_in">Map</span>的键可以是任何类型，如果是对象就不可以，对象的键只能被读为字符串。<br><br>（无修正，答得挺好的，下次加油）<br></code></pre></td></tr></table></figure>
</li>
<li><p>call、apply和bind的区别？</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">原答：这三者都是用于改变<span class="hljs-keyword">this</span>的指向，<span class="hljs-keyword">call</span>传入两个值，第一个值是指向的对象，第二个值传入一个参数。apply第二个值是传入的数组，然后bind就是直接返回指向的对象。<br><br>修正：这三个函数都用于改变<span class="hljs-keyword">this</span>指向，他们三个都是函数对象的静态方法，当一个函数调用<span class="hljs-keyword">call</span>的时候，会把函数中的<span class="hljs-keyword">this</span>指向改为传入的第一个对象值，还能接受一系列参数，这些参数会传递给函数。apply的用法和<span class="hljs-keyword">call</span>差不多，但是他不再接受一系列参数而是一个数组。bind和<span class="hljs-keyword">call</span>用法一样，但是返回一个新函数可以稍后调用。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有了解过let、const和var有什么区别？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">原答：<span class="hljs-keyword">let</span>和<span class="hljs-keyword">const</span>是ES6新增的特性，是块级元素；<span class="hljs-keyword">var</span>一般作用域全局变量。<span class="hljs-keyword">let</span>的值是可变的，<span class="hljs-keyword">const</span>的值是不可变的，如果你想要试图改变它的话会报错。<span class="hljs-comment">//那如果const定义一个对象，那么我们可以改变这个对象里属性的值吗？</span><br>原答：可以的<br><br>修正：<span class="hljs-keyword">var</span>变量具有函数作用域，但是<span class="hljs-keyword">let</span>和<span class="hljs-keyword">const</span>是块级作用域；<span class="hljs-keyword">let</span>和<span class="hljs-keyword">var</span>可以被重新赋值，<span class="hljs-keyword">const</span>不能被重新赋值，但这不代表它指向的引用类型比如对象或数组内容不能改变。当<span class="hljs-keyword">var</span>在全局作用域下声明变量的时候，这个变量会变成全局对象的属性，<span class="hljs-keyword">let</span>和<span class="hljs-keyword">const</span>就不会。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你了解过哪些进行深拷贝的方法？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原答：getPrototypeOf，通过获取某个对象的原型的属性和方法来进行深拷贝。<span class="hljs-comment">//还有别的吗</span><br><br>修正：<span class="hljs-title class_">JSON</span>.<span class="hljs-property">stringify</span>+<span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span>序列化加反序列化可以深拷贝，但是这种方法不可以复制函数、<span class="hljs-literal">undefined</span>和循环引用。有些对象比如日期对象 正则对象可以使用他们的拷贝构造函数来进行深拷贝。还有一种方法就是手写递归拷贝。（一定要会手写）<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有了解过闭包？</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">原答：假如在函数<span class="hljs-selector-tag">a</span>中定义了一个函数<span class="hljs-selector-tag">b</span>，<span class="hljs-selector-tag">b</span>中可以用到<span class="hljs-selector-tag">a</span>定义的量。<span class="hljs-comment">//什么时候使用闭包？</span><br>原答：用于构建私有变量，用于...说不出，可以举个例子。...（但是举错了，把延长变量存在时间的例子举成了构建私有变量的了。）<br><br>修正：（答得挺好的，把例子举完整即可）<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有用过splice这个函数？</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">原答：用过，<span class="hljs-built_in">splice</span>对数组进行操作，第一个值是指要操作的索引，第二个值是要删除元素的数量，<span class="hljs-built_in">splice</span>会从该索引后删除指定数量的元素，第三个值是值删除后在这个位置添加的数组。<br><br>（无修正，答得挺好的，下次加油）<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有了解过事件冒泡？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">原答：在DOM中有三个阶段，第一个是啥来着，会去找那个事件，从最高的window往下找，一直找到那个事件，然后进入处于目标状态，比如click获得这个事件的状态，然后再往上冒泡，再从最小的盒子再冒泡到全局变量。<br><br>修正：当在DOM树中触发了一个事件，比如点击或键盘输入，这个事件会经历三个阶段：分别是事件捕获、目标阶段、事件冒泡。事件捕获会从文档的根节点开始一直传播到目标元素本身。然后就到了目标阶段，这里就是事件实际发生的地方。然后就从目标元素开始向上冒泡，一直冒泡到根元素，我们可以在目标元素以上的祖先元素设置事件监听器来响应事件。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你用过HTML5吗，用过里面什么东西？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">原答：...(不确定是不是<span class="hljs-title class_">HTML5</span>的)<br><br>修正：用过header、footer等语义元素，有助于搜索引擎优化。用过<span class="hljs-variable constant_">H5</span>的一些新表单类型，比如<span class="hljs-keyword">type</span>=email、url、<span class="hljs-built_in">number</span>。用过video元素嵌入视频。用过canvas绘制图形。用过<span class="hljs-variable language_">localStorage</span>和<span class="hljs-variable language_">sessionStorage</span>存储数据。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有接触过HTML5的websocket吗？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：我拿它和平时我们用的一些协议来对比吧，比如我们平时用的是Http、Https，然后用<span class="hljs-built_in">get</span>、<span class="hljs-built_in">post</span>传请求，这种只能是一次过一次回这样之类的，但是websocket是进行一个长线链接，比如说我要做一个聊天网站，我在这边发，另一台电脑也会马上同步信息过去，这就是平时websocket需要用到的一个场景。<br><br>修正：websocket提供了一种在单个TCP连接上进行全双工通信的方法，这就意味着服务器和客户端可以同时发送和接收数据，这和传统的<span class="hljs-keyword">http</span>响应模式不同，<span class="hljs-keyword">http</span>通常只支持客户端到服务器的单向通信。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你对Http协议了解得多吗？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：只了解一点<span class="hljs-comment">点//现在最新的版本是多少？</span><br>原答：http2吧好像到<span class="hljs-number">3</span>了。<br><br>修正：<span class="hljs-keyword">http</span>叫做超文本传输协议，是实现网络通信的一种规范，是万维网的数据通信的基础。最新的版本是<span class="hljs-number">2022</span>年刚更新的http3，添加的一些特性包括改用基于UDP的QUIC协议作为传输层协议，取代了传统的TCP协议。quick UDP <span class="hljs-keyword">internet</span> connections整合了TCP的可靠性和UDP的低延迟性，同时还提供TLS加密。QUIC还允许IP地址变化的情况下保持连接状态，提供了更高效的重传机制，能够更快地检测和回复丢包。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有了解过https和http的区别吗？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：<span class="hljs-keyword">https</span>简单来说就是<span class="hljs-keyword">http</span>+TLS/SSL 因为<span class="hljs-keyword">http</span>本身是不安全的，<span class="hljs-keyword">https</span>相当于在<span class="hljs-keyword">http</span>上进行了一个加密，需要在网站上获取证书啊，去进行一个传来的密文的解密。<br><br>修正：<span class="hljs-keyword">http</span>的信息传输是明文进行的，没有进行加密处理。<span class="hljs-keyword">https</span>在<span class="hljs-keyword">http</span>的基础上加入了SSL/TLS协议，连接的时候需要进行额外的握手过程，保证一定安全但也会消耗一些性能。<span class="hljs-keyword">http</span>的端口默认使用<span class="hljs-number">80</span>，<span class="hljs-keyword">https</span>的端口默认使用<span class="hljs-number">443</span>。<span class="hljs-keyword">http</span>不需要申请证书，<span class="hljs-keyword">https</span>需要。搜索引擎策略会给<span class="hljs-keyword">https</span>的网站更高的曝光度。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有了解过https加密用的是什么算法呢？</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">原答：没有<br><br>修正：主要用非对称加密算法例如公钥私钥、对称加密算法例如三重数据加密算法、<span class="hljs-built_in">hash</span>算法去加密。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有了解过http请求方法有哪些吗？</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原答：常用的<span class="hljs-keyword">get</span> post，不常用的push <span class="hljs-keyword">delete</span>之类的<br><br>修正：<span class="hljs-keyword">GET</span>方法用于从服务器获取数据，POST方法用于向服务器发送数据，PUT用于向服务器发送数据用以替换内容，<span class="hljs-keyword">DELETE</span>用于请求服务器删除资源，<span class="hljs-keyword">OPTIONS</span>用于返回服务器支持的HTTP方法及查看服务器性能，TRACE方法用于回显服务器收到的请求，用于调试。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有了解过get post有什么区别吗？</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">原答：getpost平时我们用的时候都是要有请求头的，然后<span class="hljs-keyword">post</span>是可以传一个请求内容的。<br><br>修正：GET主要是向服务器获取数据，在url明文传递内容，不安全，且只能传输ASCII字符。<span class="hljs-keyword">POST</span>主要是向服务器提交数据，在请求体中传递内容，可以传输多种数据类型，比如文本，二进制文件。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有了解过常见的http响应码有哪些吗？</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原答：<span class="hljs-number">200</span>开头的就是服务正常，<span class="hljs-number">300</span>开头没怎么见过，<span class="hljs-number">400</span>开头比如<span class="hljs-number">404</span> <span class="hljs-number">405</span><span class="hljs-keyword">Method</span> <span class="hljs-keyword">Not</span> Allow这种一般是前端路由这边的一些问题，<span class="hljs-number">500</span>开头一般是服务器那边的问题。<br><br>修正：<span class="hljs-number">100</span>是服务器已经接收到请求的一部分；<span class="hljs-number">2</span>xx是成功响应码，例如<span class="hljs-number">200</span>是成功；<span class="hljs-number">3</span>xx是重定向响应码，例如<span class="hljs-number">301</span>表示请求的资源已经被移动到新的url，会返回新的url；<span class="hljs-number">4</span>xx是客户端错误，例如<span class="hljs-number">400</span>bad request错误的参数或地址，服务器理解不了，<span class="hljs-number">403</span>forbidden服务器拒绝请求，<span class="hljs-number">404</span><span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span>找不到资源，<span class="hljs-number">405</span><span class="hljs-keyword">method</span> <span class="hljs-keyword">not</span> allow请求方法服务器不允许；<span class="hljs-number">5</span>xx是服务器错误，例如<span class="hljs-number">500</span>是服务器错误，<span class="hljs-number">503</span>是服务器超载。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有了解Vue中computed和watch有什么区别？</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">原答：计算属性不太了解，watch是用于监听<span class="hljs-built_in">ref</span>属性的改变，如果改变的话就会执行后续的相应函数。<br><br>修正：computed属性是基于其他其他的响应式数据动态计算并返回一个新的值，有缓存功能，只有当其依赖的数据发生变化时，才会重新计算，通常用于一个属性受到多个属性影响。watch属性是监听某个响应式属性，没有缓存功能，一旦监听的值改变就会发生回调，通常用于一个属性影响多个属性。<br></code></pre></td></tr></table></figure>
</li>
<li><p>写v-for的时候一般会加一个key，为什么？</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lsl">原答：<span class="hljs-type">key</span>是用于和v-for一起去遍历盒子的<br><br>修正：<span class="hljs-type">key</span>作为唯一标识，可以帮助vue快速定位到需要更新的DOM元素，提高渲染效率。同时还需要选择稳定的<span class="hljs-type">key</span>去保持每个列表值与其对应的组件实例的稳定关系。<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果你的vue项目中遇到兄弟组件之间的通信，你会用什么方法呢？</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">原答：用一些相关的插件比如pinia，可以让父传子props再用子传父emit<br><br>修正：使用父传子props再用子传父$emit，如果是祖先组件传给后代组件可以用<span class="hljs-keyword">provide</span>和inject，如果是那种没什么关系的组件传值的话，一般用全局总线库或者pinia。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有部署过项目嘛，用什么Web容器呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：直接把文件传到服务器中，然后用nginx去部署的<br><br>修正：使用Nginx部署。（常见的还有tomcat，但是没用过就不强答了。）<br></code></pre></td></tr></table></figure>
</li>
<li><p>那你改过nginx的配置嘛？</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl">原答：改过端口号和<span class="hljs-keyword">index</span>页面和<span class="hljs-keyword">location</span>指向我的文件夹。<br><br>修正：监听端口、<span class="hljs-keyword">location</span>块、SSL/TLS证书和密钥。<br></code></pre></td></tr></table></figure>
</li>
<li><p>平常有接触linux？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：接触得少<br><br>（没什么好说的，不是一下子能提升的）<br></code></pre></td></tr></table></figure>
</li>
<li><p>听说过docker容器嘛？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：听说过，相当于我这边写好了，然后用docker把我这边的环境什么的打包给别人。<br><br>修正：Docker容器中包含应用程序所需要的一切运行条件，包括代码、系统工具和库等，它可以解决同一个代码放我这里能跑放别人电脑跑不了的情况。<br></code></pre></td></tr></table></figure>
</li>
<li><p>有没有用过集成持续部署的软件，比如说Jenkins</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">原答：没有用过<br><br>修正：用过Gitlab，知道<span class="hljs-keyword">jenkins，Gitlab可以将gitlab仓库的代码持续集成和部署。 </span><br></code></pre></td></tr></table></figure>
</li>
<li><p>平常CSS写得多嘛，相对定位和绝对定位解释一下</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">原答：一般是给父盒子相对定位，然后想要使用绝对定位，需要给父元素设置相对定位才能使用绝对定位，绝对定位是相对于父元素的。<br><br>修正：相对定位的通过<span class="hljs-attribute">position</span> relative设置，设置之后改动偏移量盒子会偏移，但是它还是占据原来的位置。设置绝对定位是<span class="hljs-attribute">position</span> absolute，需要给他父元素设置相对定位，绝对定位就会完全脱离文档流，不再占据原来的空间。根据偏移量移动。<br></code></pre></td></tr></table></figure>
</li>
<li><p>用过flex布局嘛，flex布局他的容器上有哪些属性呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：比如说常用的<span class="hljs-attribute">justify-content</span>、align-item。<span class="hljs-attribute">flex-wrap</span>可以对子元素进行换行处理。<br><br>修正：用过，比如<span class="hljs-attribute">flex-direction</span>决定主轴方向，<span class="hljs-attribute">flex-wrap</span>决定子元素是否换行，<span class="hljs-attribute">justify-content</span>决定主轴的对齐方式，<span class="hljs-attribute">align-items</span>决定和主轴交叉的那个轴的对齐方式。<br></code></pre></td></tr></table></figure>
</li>
<li><p>算法题：100~999的水仙花数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//原答：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">999</span>; i++)&#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> temp = i<br>    <span class="hljs-keyword">while</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>        sum += (temp % <span class="hljs-number">10</span>) ** <span class="hljs-number">3</span><br>        temp = <span class="hljs-built_in">parseInt</span>(temp/<span class="hljs-number">10</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(sum === i)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><br><span class="hljs-comment">//（挺好的）</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2025-4-21科守搏"><a href="#2025-4-21科守搏" class="headerlink" title="2025.4.21科守搏"></a>2025.4.21科守搏</h2><p>自我介绍需要改进一下，面试官觉得有些简短了。</p>
<ul>
<li><p>可以说下双向绑定及其操作原理吗？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：使用v-model进行双向绑定，一般是用于<span class="hljs-selector-tag">input</span>输入框，如果我们在<span class="hljs-selector-tag">input</span>中改变值，会同样更新到JS中。<br><br>修正：双向绑定是一种数据绑定机制，它可以让视图（页面上的元素）和模型（Vue 实例中的数据）之间相互影响。当模型数据发生变化时，视图会自动更新；常用v-model进行双向绑定<br></code></pre></td></tr></table></figure>
</li>
<li><p>就是他的原理你有没有了解，比如说他是靠什么东西然后造成双向绑定的？</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">原答：因为Vue是MVVM模型嘛，v-model是VM那一块的，通过修改他的值，我们可以实现视图和模型的数据更新。<br><br>修正：Vue 中的双向绑定主要是通过其响应式系统实现的，这个系统的核心在于对数据的劫持和依赖收集。<br><br>vue2中主要通过三步实现：<br>	<span class="hljs-number">1.</span>数据劫持：Vue 会遍历 data 对象中的每一个属性，通过 <span class="hljs-built_in">Object</span>.defineProperty() 来劫持这些属性的 getter 和 setter。当数据被访问（通过 getter）时，Vue 可以追踪到哪些视图元素（依赖）使用了这个数据。当数据被修改（通过 setter）时，Vue 可以立即知晓数据的变化，并通知相关的视图元素进行更新。<br>	<span class="hljs-number">2.</span>依赖收集：Vue 中引入了订阅器（Dep）的概念。当一个视图元素（如指令或计算属性）访问某个数据属性时，该视图元素会被添加到该数据属性对应的订阅器（Dep）中。当数据变化时，它会通知所有相关的视图元素进行更新。<br>	<span class="hljs-number">3.</span>发布订阅模式：Vue 中的每个视图元素（或指令）都会对应一个观察者（Watcher）对象。观察者对象会监听数据的变化，当数据变化时，观察者会收到通知，并执行相应的更新函数，更新视图。<br><br>vue3则是使用ES6的<span class="hljs-built_in">Proxy</span>对象代替了<span class="hljs-built_in">Object</span>.defineProperty()，其中ref和reactive的功能都是使用此对象实现的，<span class="hljs-built_in">Proxy</span> 可以直接代理整个对象，拦截对象的读取、写入等多种操作，解决了 Vue <span class="hljs-number">2</span> 中无法检测对象属性的新增和删除等局限性。<br></code></pre></td></tr></table></figure>
</li>
<li><p>同步异步了解吗？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">原答：同步的话因为JS是单线程的，一般我们的代码就是从上往下就是同步的，异步的话就是我们执行一个线程的时候，我们需要格外开一个线程去做，比如说<span class="hljs-keyword">fetch</span>去拿一下参数，就是异步的。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你刚刚说的是一整个下来，你可以说一下异步是怎么实现的吗？</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">原答：异步的话一般可以使用<span class="hljs-built_in">Promise</span>去实现，有些比如fetch本身就是异步的，拿到返回值就可以往下执行<span class="hljs-keyword">then</span>了。<br><br>修正：实现的方式一般有以下几种：回调函数、<span class="hljs-built_in">Promise</span>、<span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>异步原理是什么呢？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">原答：应该就是再开一个线程，因为本身是单线程的，但是有需要也可以开一个线程。<br><br>修正：<span class="hljs-keyword">JS中的异步操作主要是依赖于事件循环和任务队列，就是宏任务微任务。只有用到Web </span>Worker的时候会多线程。<br></code></pre></td></tr></table></figure>
</li>
<li><p>深拷贝浅拷贝了解吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：了解，我先讲一下我们常用的数据类型吧，常用的数据我们是存在栈里面的，对象的话是存在堆里面的，浅拷贝的话只是对字面量进行拷贝，深拷贝会对内存地址进行修改。<br></code></pre></td></tr></table></figure></li>
<li><p>computed和watch的区别？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：watched的话一般就是监听一个值的改变，改变了就进行后续操作；computed的话是监测多个值，计算之后再返回一个值。<br><br>修正：computed属性是基于其他其他的响应式数据动态计算并返回一个新的值，有缓存功能，只有当其依赖的数据发生变化时，才会重新计算，通常用于一个属性受到多个属性影响。watch属性是监听某个响应式属性，没有缓存功能，一旦监听的值改变就会发生回调，通常用于一个属性影响多个属性。<br></code></pre></td></tr></table></figure>
</li>
<li><p>路由守卫了解吗？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">原答：比如我们经常需要实现管理员、用户这种身份。我们会在配置路由的时候写一些判断条件，如果不符合的话就不让他进那个路由。<br><br>修正：Vue Router 提供了多种类型的路由守卫，包括全局守卫、局部守卫和组件内的守卫。<br><br>全局守卫：<span class="hljs-keyword">beforeEach（用于判断是否允许进入）、beforeResolve（用于处理一些逻辑）</span><br><span class="hljs-keyword"></span>局部守卫：<span class="hljs-keyword">beforeEnter（写在和path同一个对象中，仅对一个路由生效）</span><br><span class="hljs-keyword"></span>组件内的守卫：<span class="hljs-keyword">beforeRouteEnter（在组件创建之前触发，可以访问路由对象，但无法访问组件实例）、beforeRouteUpdate（在当前路由改变（但该组件被复用时）触发，可以访问组件实例。）、beforeRouteLeave（在离开当前路由之前触发，可以访问组件实例。）</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>性能优化有没有做过？</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">原答：做过CSS和<span class="hljs-keyword">JS</span>的吧，CSS一般是首屏优化、骨架图。<span class="hljs-keyword">JS</span>的话，得看具体情况做优化了。<br><br>修正：减少重排重绘、防抖节流、Web Worker执行后台任务、闭包缓存减少计算量、事件委托、懒加载、SSR首屏加载、TreeShaking减少无用代码。<br></code></pre></td></tr></table></figure>
</li>
<li><p>兼容性有没有做过？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：做过 用的媒体查询，如果是比较简单的话，一般使用媒体查询去做。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你在写uniapp的时候有没有了解过，苹果安卓不同机子的出现的不同问题？</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原答：没有<br><br>修正:会有样式问题，可以根据不同机型引入特定的样式文件。<br>	IOS中<span class="hljs-keyword">input</span>键盘的keyup、keydown支持不完善，可以用<span class="hljs-keyword">input</span>时间配合监听键盘输入。<br>	iOS 输入框有内阴影，可设置-webkit-tap-highlight-color: rgba(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>); 去除。<br>	iOS 下 <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>() 不支持 “-” 字符，会导致日期解析错误。可在创建日期对象时将 “-” 替换为 “/”，如 <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(&quot;2017-08-11 12:00:00&quot;.replace(/-/g, &quot;/&quot;));。<br></code></pre></td></tr></table></figure>
</li>
<li><p>现在有一个新项目，要做项目搭建，你会做什么，主题架构设计大概怎么做？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">原答：我会根据要做的项目所需要的技术，去确定协议和技术栈，看看哪个会更加符合这个新项目<span class="hljs-operator">。</span><br><br>修正：<span class="hljs-number">1</span>.选择合适的前端框架和工具链；<span class="hljs-number">2</span>.配置代码编辑器和开发环境，确定代码风格一致性；<span class="hljs-number">3</span>.选择状态管理<span class="hljs-operator">、</span>路由管理库；<span class="hljs-number">4</span>.选择<span class="hljs-type">UI组件库；5</span>.确定<span class="hljs-type">CICD流程；</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>ws和http的区别是什么？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：<span class="hljs-keyword">http</span>是连接之后 会断开，虽然在<span class="hljs-number">1.0</span>版本后保留了长连接，但是还是会断开，每次发送一条或多条请求就会断开。ws不一样，他会进行一个长线连接，他会监听用户有没有更新新的数据。有就会马上更新。<br><br>修正：HTTP是请求 - 响应协议，由客户端主动发起请求，每次请求都要简历连接，传输数据主要是文本，连接一般是在传输完成后关闭。WebSocket是全双工通信协议，客户端和服务器可以主动发送数据，会保持持久连接，传输的数据除了文本还包含二进制。<br></code></pre></td></tr></table></figure>
</li>
<li><p>nexttick有没有了解？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：在执行生命周期的时候，他不是会根据数据的改变而反复渲染页面吗，如果有一个循环让他一直更新，那DOM是受不了的。nextTick是让他在更新好之后再进行渲染的。<br><br>修正：我们先把<span class="hljs-built_in">tick</span>是什么了解一下，事件循环中每一个循环就称为一个<span class="hljs-built_in">tick</span>，一个<span class="hljs-built_in">tick</span>结束后，vue会把更改的数据渲染到页面上，如果我们需要在DOM渲染后执行一个回调函数，那么就用nexttick。<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2025-4-23迈步科技"><a href="#2025-4-23迈步科技" class="headerlink" title="2025.4.23迈步科技"></a>2025.4.23迈步科技</h2><p>因为我忘记录音了，只记得一些我稍微答得含糊或没答到面试官期望点上的问题。</p>
<ul>
<li><p>懒加载是怎么实现的？</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">原答：比如我们有六十条数据，每一次都先和服务端拿一定数量的数据比如五条，然后每次我们滑动到页面底部的时候就再和服务端拿五条数据。<br><br>修正：延迟加载 + 视口监听<br>	首先每次都渲染少量数据，每次进入视口的时候就再加载。<br>	视口监听一般用下面两种方法去做：<br>		使用 <span class="hljs-built_in">Intersection</span> Observer API（现代化解决方案）<br>		使用滚动监听，获取元素距离顶部高度、滚动距离、视口高度、元素高度，计算判断是否进入视口。<br></code></pre></td></tr></table></figure>
</li>
<li><p>前端存储用那些？</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">原答：我用过<span class="hljs-string">cookie</span>、<span class="hljs-string">localstorage</span>、<span class="hljs-string">sessionstorage</span>。<span class="hljs-string">cookie</span>是服务端返回数据的时候请求头带有一个<span class="hljs-built_in">set-cookie，浏览器会自动存储带有的cookie。localstorage在前端设定会存储到浏览器中，如果刷新页面也不会消失。sessionstorage则是刷新页面会消失。</span><br><br>修正：（面试官觉得我存储用得少了）除了以上存储，还有一些，以下列举：<br>	<span class="hljs-string">IndexedDB</span>：持存储大量结构化数据，容量通常为 <span class="hljs-string">50MB</span> 以上，甚至可以存储几乎无限量的数据。它是一个低级 <span class="hljs-string">API</span>，提供了更强大的功能，如事务处理和索引，支持异步操作，不会阻塞用户界面，可存储和检索几乎任何类型的 <span class="hljs-string">JavaScript</span> 对象。适合存储大规模的结构化数据，如用户文件、离线数据、上万条数据等，适用于需要离线访问和复杂查询的 <span class="hljs-string">Web</span> 应用。<br>	<span class="hljs-string">Cache</span> <span class="hljs-string">Storage</span>：是一种在浏览器中缓存资源文件的存储方式，允许开发者将网站所需的资源（如 <span class="hljs-string">HTML</span>、<span class="hljs-string">CSS</span>、<span class="hljs-string">JavaScript</span>、图像等）保存在客户端的缓存中，以便在离线时仍然能够访问网站，并提供更快的加载速度和更好的用户体验。在 <span class="hljs-string">PWA</span>（<span class="hljs-string">Progressive</span> <span class="hljs-string">Web</span> <span class="hljs-string">App</span>）中应用广泛，适合用于缓存资源文件，实现离线访问和提高页面加载速度。<br>	<span class="hljs-string">File</span> <span class="hljs-string">System</span> <span class="hljs-string">API</span>：允许 <span class="hljs-string">Web</span> 应用直接操作浏览器的文件系统，适合存储大量二进制文件，如图像、音频、视频等。可用于文件管理器、离线文件编辑器等应用，但目前仅支持部分浏览器，如 <span class="hljs-string">Chrome</span>，且需要用户授权才能使用。<br>	更多的我就不列举了。<br></code></pre></td></tr></table></figure>
</li>
<li><p>Vue你使用的pinia，react有类似的库吗？</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">原答：redux库是用于组件间传值的，但是具体我不是很了解。<br><br>修正：redux是一种用于构建用户界面状态管理的开源 JavaScript 库，主要用于管理应用程序中的全局状态。其中使用createStore传入一个reducer函数（可传入初始<span class="hljs-keyword">state</span>和action），内置相关判断逻辑（比如switch case 判断action.type后执行操作）。提供两个钩子函数，通过调用useSelector读取<span class="hljs-keyword">state</span>，通过调用useDispatch传入action类别进行操作。<br></code></pre></td></tr></table></figure>
</li>
<li><p>前端的加密有哪些？</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">原答：用过JWT实现<span class="hljs-built_in">token</span>加密。<br><br>修正：对称加密AES，非对称加密RSA（证书），SSL/TLS（HTTPS协议）。<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2025-4-25钛动"><a href="#2025-4-25钛动" class="headerlink" title="2025.4.25钛动"></a>2025.4.25钛动</h2><ul>
<li><p>个人介绍</p>
</li>
<li><p>问我在上家公司解决什么比较突出的问题。</p>
<ul>
<li><p>Antv库年久失修是什么问题还有印象吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：好像是某个图表的问题，记不清了。<br><br>修正：他的文档有很多不清晰的地方，它本身给出的一些比如画布，有一些属性是没有写清晰的。<br></code></pre></td></tr></table></figure>
</li>
<li><p>按钮同时可以单击双击，防抖是怎么实现的？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：对单击进行类似防抖的操作，<span class="hljs-attribute">Gap</span>之后触发单击事件，<span class="hljs-attribute">Gap</span>内点了两次，则触发双击事件。<br><br>修正：（确实，这应该不属于防抖，防抖是同一个操作<span class="hljs-attribute">Gap</span>内被执行了则会重置。）<br></code></pre></td></tr></table></figure>
</li>
<li><p>log文件进行大文件上传？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：（参考大文件上传，同样回答，挺好的）<br></code></pre></td></tr></table></figure>
</li>
<li><p>Promise.all 100个分片可以同时上传100个吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：好像不行吧，没试过传这么多的。<br><br>修正：浏览器通常会对并发网络请求的数量进行限制。例如，大多数现代浏览器会限制同一个域名下的最大并发网络请求数量，通常在6到8个左右。如果超出这个限制，超出的任务会被放入队列等待，而不是真正并行执行。网络带宽和服务器的处理能力也会影响实际的并发能力。如果服务器端的并发处理能力有限，可能会导致部分请求被拒绝。<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TaskList相关问题</p>
<ul>
<li><p>响应式怎么做的？</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">原答：简单的响应式用@media，复杂一点的就写<span class="hljs-keyword">JS</span>。<br><br>修正：媒体查询、流式布局、flex布局、网格布局、<span class="hljs-keyword">JS</span>。<br></code></pre></td></tr></table></figure>
</li>
<li><p>主题是怎么做的？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：CSS里面可以使用<span class="hljs-selector-pseudo">:root</span>伪类选择器中命名CSS变量，然后对应的元素可以使用<span class="hljs-selector-tag">var</span>(变量名)进行引用，每次只需要改变root里面的样式就可以了。<br><br>补充：使用伪类选择器root命名CSS变量，通过切换<span class="hljs-selector-tag">body</span>的类名来激活不同的主题。<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果主题色中的颜色是碰撞的，比如背景主题同时有两种颜色你该怎么解决呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：不太懂怎么解决。<br><br>修正：可以使用策略模式按需修改背景的样式。<br></code></pre></td></tr></table></figure>
</li>
<li><p>你了解过策略模式吗，其他的设计模式了解过吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：不了解。<br><br>修正：（详见设计模式）<br></code></pre></td></tr></table></figure>
</li>
<li><p>登录全流程？</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">原答：首先注册，前端输入邮箱发送验证码，后端使用SMTP协议发送邮件，验证码生成一个随机六位数字。验证码有<span class="hljs-number">60</span>s的冷却，前后端都有<span class="hljs-number">60</span>s的计时禁止点击/发送。然后到登录，输入密码账号登录，服务端会返回一个cookie表示现在已经暂时登录了，如果这是你第一次登录的话还会返回一个<span class="hljs-built_in">token</span>用于获取用户的信息，cookie是用来持久化登录的，<span class="hljs-built_in">token</span>是用来获取用的信息。下一次登录用户浏览器cookie会表明用户最近已经登录，实现持久化登录，<span class="hljs-built_in">token</span>使用JWT加密。<br><br><span class="hljs-comment">//听过token自动刷新吗？</span><br><br>原答：好像不太了解<br><br>修正：<span class="hljs-built_in">Token</span> 自动刷新是一种机制，用于在用户不知情的情况下自动更新身份验证令牌（<span class="hljs-built_in">Token</span>），以避免因 <span class="hljs-built_in">Token</span> 过期而导致用户被迫重新登录。这种机制的核心目标是提升用户体验、保障安全性以及优化性能。<br><span class="hljs-built_in">Token</span> 自动刷新通常依赖于双 <span class="hljs-built_in">Token</span> 机制：<br>Access <span class="hljs-built_in">Token</span>：用于直接访问受保护的资源，通常具有较短的有效期（如 <span class="hljs-number">30</span> 分钟）。<br>Refresh <span class="hljs-built_in">Token</span>：用于获取新的 Access <span class="hljs-built_in">Token</span>，通常具有较长的有效期（如 <span class="hljs-number">7</span> 天）<br>（和我上面讲的双<span class="hljs-built_in">token</span>不一样这个是用来刷新Access <span class="hljs-built_in">Token</span>的）<br></code></pre></td></tr></table></figure>
</li>
<li><p>有做权限控制吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：有一点点，有做路由守卫，拿一下用户的邮箱就可以控制进不去了。<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Perfect Studio相关问题</p>
<ul>
<li><p>白屏优化怎么实现的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：因为是摄影的，有很多图片。首页进去先路由到一个骨架图，同时等待一定时间之后再把页面图片显示出来。<br></code></pre></td></tr></table></figure>
</li>
<li><p>懒加载怎么实现？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：原本要显示的图片可能有100多张200多张，我窗口就只显示7 8张，然后每次监测到滑动到窗口底部就触发加载并到数组中。<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CSS</p>
<ul>
<li><p>小程序样式上的问题，适配？</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">原答：有某种机型不适配某种圆角按钮，苹果机的input属性好像监测不到keydown和keyup。大概就这么多。 <br><br>修正：基本是一些屏幕宽高适配问题。IOS的<span class="hljs-keyword">fixed</span>元素会因为软键盘而弹起，其本质是IOS没有将页面高度变为视口高度，如果机型是IOS可以获取该元素当前可见区域作为其高度。<br></code></pre></td></tr></table></figure>
</li>
<li><p>CSS垂直居中？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：一般<span class="hljs-attribute">flex</span>解决，还有就是给这个元素的父元素设置绝对，这个元素设置相对，<span class="hljs-attribute">top</span>、<span class="hljs-attribute">left</span>、<span class="hljs-attribute">bottom</span>、<span class="hljs-attribute">right</span>设置为<span class="hljs-number">0</span>即可。<br></code></pre></td></tr></table></figure>
</li>
<li><p>flex有对某个子项进行特别处理的，你有了解过吗？</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">原答：之前用过但是现在忘了。<br><br>修正：<span class="hljs-meta">align</span>-self可以控制单个子项。<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JS</p>
<ul>
<li><p>数据类型？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：（详见数据类型）<br></code></pre></td></tr></table></figure>
</li>
<li><p>判断数据类型？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript">原答：可以使用<span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span><br><br><span class="hljs-comment">//有什么类型他判断不了吗</span><br><br>原答：<span class="hljs-literal">null</span>和<span class="hljs-literal">undefined</span>吧<br><br>修正：它会将所有的对象判定为<span class="hljs-built_in">object</span>包括数组、<span class="hljs-title class_">Date</span>、正则，甚至<span class="hljs-literal">null</span>都会被判定为<span class="hljs-built_in">object</span>。<br><br><span class="hljs-comment">//可以再看看，还有什么？</span><br><br>原答：<span class="hljs-keyword">instanceof</span> 吧<br><br>修正：<span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span>判断基本类型，<span class="hljs-keyword">instanceof</span>判断对象类型，===<span class="hljs-literal">null</span>判断<span class="hljs-literal">null</span>，<span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>判断数组，<span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span>判断<span class="hljs-title class_">NaN</span>。<br><br><span class="hljs-comment">//这边要回去再看一下哈</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>TS使用过他的一些什么特性？</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">原答：用过尖括号判断类型<br><br>修正：（详见TS）<br><br><span class="hljs-comment">//泛型你知道吗，类型工具你知道吗</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>异步编程了解吗？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">原答：JS是单线程的，比如我们有时候需要定时器之类的，就是异步了。异步是通过事件循环去实现的，我们平时写的常见代码是同步类型的，异步任务中又分微任务和宏任务，promise.then就是微任务，setTimeout就是宏任务，微任务会在下一个宏任务执行之前执行。微任务和宏任务要进队列的，普通的同步任务是进堆的。<br><br><span class="hljs-comment">//为啥JS是单线程的？</span><br><br>原答：不太了解<br><br>修正：JS一开始是作为浏览器的脚本语言去设计的，为了不和浏览器主线程抢资源，所以选择是用了单线程模型。<br></code></pre></td></tr></table></figure>
</li>
<li><p>异步任务我们一般使用什么去捕捉状态？</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">原答：一般使用promise去捕捉，使用resolve和reject确定成功失败，然后用.<span class="hljs-keyword">then</span>和.<span class="hljs-keyword">catch</span>去执行成功和失败后的操作。<br><br>修正：使用<span class="hljs-built_in">Promise</span>、<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>、事件监听，回调函数。<br><br><span class="hljs-regexp">//</span>除了reject 还有什么情况会进<span class="hljs-keyword">catch</span>？<br><br>修正：直接在promise里面及.<span class="hljs-keyword">then</span>() <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>、<span class="hljs-keyword">try</span> <span class="hljs-keyword">catch</span>、<span class="hljs-built_in">Promise</span>.all/race被拒绝。<br></code></pre></td></tr></table></figure>
</li>
<li><p>还了解Promise的什么静态方法？</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">原答：Promise.<span class="hljs-literal">all</span>吧，并发执行里面的所有任务，全部成功执行then，返回顺序是里面数组的顺序。<br><br>修正：四个 <span class="hljs-literal">all</span>、<span class="hljs-literal">all</span>Settled、<span class="hljs-literal">any</span>、race。（详见Promise常用方法）<br><br>//和<span class="hljs-literal">all</span>Settled有什么区别？<br><br>原答：记不太清了。<br><br>修正：<span class="hljs-literal">all</span>是有一个失败就返回失败，<span class="hljs-literal">all</span>Settled是全部都会执行。<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li><p>响应式原理？</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">原答：里面是<span class="hljs-built_in">ref</span> reactive去实现响应式的，原理是使用proxy去构造<span class="hljs-built_in">ref</span>和reative的，一般会进行双向绑定，如果视图更新的话，模型也会更新的，双向更新。<br><br><span class="hljs-comment">//视图是怎么追踪的</span><br><br>原答：视图对每个需要追踪的元素都有监视器，如果有改变的话就会触发一个中间的工具，去通知响应式数据更新。<br><br>修正：一般会有事件监听器绑定在元素上（addEventListener）。<br></code></pre></td></tr></table></figure>
</li>
<li><p>$nexttick了解吗？</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原答：vue有生命周期嘛，然后我们对某些数据进行更改嘛，有些东西我们可能需要渲染之后再去拿，这时候就用nexttick。<br><span class="hljs-comment"></span><br><span class="hljs-comment">//为什么会有这个间隔呢？</span><br><br>原答：因为每次dom渲染都会有个<span class="hljs-built_in">tick</span>，如果我们一更新数据就更新页面的话，消耗量会特别大。vue有一个虚拟dom，每次改变数据都会改变虚拟dom，等你更新完了再通过虚拟dom改变真实dom，所以有<span class="hljs-built_in">tick</span>。<br><span class="hljs-comment"></span><br><span class="hljs-comment">//nexttick的底层，怎么实现知道吗？</span><br><br>修正：其实也是基于宏任务微任务去实现的，其实相当于我们执行同步任务，然后执行宏任务再执行微任务，我们业务逻辑的微任务执行完了，vue会在当前的微任务队列末端添加一个渲染真实DOM的微任务，同时再添加一个nexttick<br>回调的微任务，这样就可以在下一个<span class="hljs-built_in">tick</span>之前触发nexttick了。（值得一提的是虚拟DOM也是微任务中进行更行）<br></code></pre></td></tr></table></figure>
</li>
<li><p>v-if和v-show的区别？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">原答：（详见v-<span class="hljs-keyword">if</span>和v-<span class="hljs-keyword">show</span>）<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>反问环节：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">建议？<br><br>从我问的问题来看，你有些原理还要去了解清楚，就差一点点。（🤕）项目还是有点单薄，很多都是工具上的应用，没有提了多少效之类的。得突出一些重难点，尤其现在对前端的要求不只是工具了，还要有原理和理解，比如你用某些工具具体量化出来提效多少。<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2025-4-28趣链"><a href="#2025-4-28趣链" class="headerlink" title="2025.4.28趣链"></a>2025.4.28趣链</h2><p>自我介绍这一块还是欠缺，得整理出一个模板</p>
<ul>
<li><p>实习期间遇到的项目和个人项目的差别在哪？</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">原答：统一规划、发版，用专业的<span class="hljs-keyword">CI</span>/<span class="hljs-keyword">CD</span>软件。<br><br>修正：团队的项目规划、技术栈选择、前端工程化会更为成熟、更为专业，如果是个人可能会不过多的考虑技术栈的适用度。<br></code></pre></td></tr></table></figure>
</li>
<li><p>大文件上传？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：（见之前上面）<br></code></pre></td></tr></table></figure>
</li>
<li><p>小程序只做过微信的对吗，RN做过吗？</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">修正：QQ小程序的接口基本和微信的差不太多，只不过需要把 `wx.` 改为 `qq.` 。微信使用的是原生框架，而支付宝小程序框架采用的是类似react框架。<br></code></pre></td></tr></table></figure>
</li>
<li><p>说一下你们团队的git怎么用？</p>
</li>
<li><p>前端工程化了解得多吗？</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">原答：直接用的vite和<span class="hljs-keyword">next</span>的默认打包，没有调整过。<br><br>修正：前端工程化是指将软件工程的原理应用于前端开发，我们常见的工程化有模块化、构建打包工具、代码管理、自动测试、构建优化。我自己有在使用打包工具的时候根据Rollup官方文档更改过treeshaking（去屑优化）的配置。<br></code></pre></td></tr></table></figure>
</li>
<li><p>ES6？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">原答：let、cosnt、promise、箭头函数<br></code></pre></td></tr></table></figure>
</li>
<li><p>展开说说promise</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">原答：用于处理异步的，带有reject和resolve，正常触发then，异常触发<span class="hljs-keyword">catch</span>。<br><br><span class="hljs-comment">//then有几个参数？</span><br><br>原答：一般用第一个，没用过第二个。<br><br>修正：两个参数，第一个是promise中的reslove触发时触发，第二个是reject触发时触发，如果同时有第二个函数参数和<span class="hljs-keyword">catch</span>，只触发then的第二个参数<br></code></pre></td></tr></table></figure>
</li>
<li><p>Promise静态方法？</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mercury">原答：<span class="hljs-built_in">all</span>，race之类的，（解释）<br><br>//说一下自己封装<span class="hljs-built_in">all</span>方法的思路<br><br>修正：Promise.<span class="hljs-built_in">all</span>接收一个<span class="hljs-keyword">promise</span>数组，返回一个<span class="hljs-keyword">promise</span>对象。先判断接收的参数是不是数组，然后对<span class="hljs-keyword">promise</span>数组进行遍历操作，执行每一个<span class="hljs-keyword">promise</span>如果触发fulfilled就用<span class="hljs-built_in">then</span>回调然后添加结果到结果数组中，如果结果数组的长度等于<span class="hljs-keyword">promise</span>数组长度则触发返回<span class="hljs-keyword">promise</span>对象的resolve，某个<span class="hljs-keyword">promise</span>进入了rejected状态则触发reject。<br></code></pre></td></tr></table></figure>
</li>
<li><p>浏览器的本地存储，怎么实现localStorage过期？</p>
</li>
<li><p>做过H5页面吗？</p>
</li>
<li><p>前端性能优化？</p>
</li>
<li><p>服务端渲染做过吗？</p>
</li>
<li><p>伪类和伪元素的区别？</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">原答：<span class="hljs-symbol">:root</span>好像是伪类、<span class="hljs-symbol">:before</span>这种好像就是伪元素。<br><br>修正：伪类本质是选择在特定状态下的元素，比如<span class="hljs-symbol">:hover</span>、<span class="hljs-symbol">:active</span>。而伪元素则是创建一个不在<span class="hljs-title class_">DOM</span>中的虚拟元素，比如::before、::<span class="hljs-keyword">after</span>。<br></code></pre></td></tr></table></figure>
</li>
<li><p>介绍一下Vue及相关的一些工具？</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">原答：我一般用Vite+Pinia+TailwindCSS。<br><br>修正：Vue是一个渐进式<span class="hljs-keyword">JS</span>框架，轻量灵活，支持响应式数据绑定、组件化开发、虚拟DOM。脚手架工具常用的有Vite、Nuxt，UI库常用的有ElementPlus、Vuetify、其他的一些辅助工具有Pinia、Tailwind。<br></code></pre></td></tr></table></figure>
</li>
<li><p>如何做全局状态管理？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">原答：应该也可以用闭包的方法实现一个全局状态管理工具。<br><br>修正：创建一个状态管理器类，提供方法以获取、设置、监听状态变化。数据持久化可以通过将数据存储到IndexedDB中<br></code></pre></td></tr></table></figure>
</li>
<li><p>路由有了解吗？</p>
</li>
<li><p>场景题：一个表格进入某个详细项，回来怎么不取消筛选项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">原答：使用<span class="hljs-variable language_">localStorage</span>吧<br><br>修正：全局状态管理器、<span class="hljs-variable language_">localStorage</span>、keep-alive、<span class="hljs-variable constant_">URL</span>参数。<br></code></pre></td></tr></table></figure>
</li>
<li><p>keep-alive用过吗？</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">修正：Vue中用<span class="hljs-meta">keep</span>-alive标签包裹需要的组件，可以保持切换路由的时候组件不销毁，当使用<span class="hljs-meta">keep</span>-alive的时候会多出来两个生命周期钩子，组件被缓存时触发deactivate，复用时触发activated。如果想要在react中实现可以使用memo钩子。<br><br>如果是指https1.<span class="hljs-number">1</span>的<span class="hljs-meta">keep</span>-alive 它是一种长连接机制，用于发送多个请求和响应，从而减少了连接的建立和关闭次数，提高了网络通信的效率。<br></code></pre></td></tr></table></figure>
</li>
<li><p>怎么学习前端的？</p>
</li>
<li><p>反问：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">建议？<br><br>个人介绍需要讲清楚成果，前端基础方面需要深化，React、RN、小程序写了就要会。<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="2025-6-11字节跳动"><a href="#2025-6-11字节跳动" class="headerlink" title="2025.6.11字节跳动"></a>2025.6.11字节跳动</h2><ul>
<li><p>笔试题（都没写出来😫）</p>
<ul>
<li>模块化引用执行顺序</li>
<li>普通函数promise化</li>
</ul>
</li>
<li><p>数组和集合的区别？</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">原答：数组和集合的静态方法有所不同，集合自动去重。<br><br><span class="hljs-comment">//我要找一个值，数组和集合的时间复杂度分别是多少</span><br><br>原答：不太清楚<br><br><span class="hljs-comment">//怎么实现的？（到这里已经被杀晕了，脑子不清晰了）</span><br><br>原答：不清楚<br><br>修正：数组寻找值的方法是遍历，集合寻找值的方法是静态方法has，时间复杂度分别是<span class="hljs-built_in">O</span>(n)和<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，因为集合的has本质是使用类似哈希表的方式进行查询。<br></code></pre></td></tr></table></figure>
</li>
<li><p>事件捕获和事件冒泡是什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">原答：（都答出来了，但是面试官没听见捕获，又问了我一次，我以为答错了，就说我不会。）<br></code></pre></td></tr></table></figure>
</li>
<li><p>HTTPS加密过程？</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">原答：通过TLS/SSL进行非对称加密。<br><br><span class="hljs-comment">//再详细一些</span><br><br>修正：（详见HTTP与HTTPS）<br></code></pre></td></tr></table></figure>
</li>
<li><p>浏览器的缓存机制？</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">原答：cookie、<span class="hljs-built_in">local</span> storage、session storage。<span class="hljs-params">...</span>.<br><br>修正：HTTP 缓存（强缓存、协商缓存）、本地缓存（<span class="hljs-built_in">local</span> storage、session storage）、Cookie、<span class="hljs-keyword">Cache</span>、IndexedDB<br></code></pre></td></tr></table></figure>
</li>
<li><p>强缓存和协商缓存的协议是怎么样的？</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">原答：不太了解<br><br>修正：<br>	强缓存和协商缓存是 <span class="hljs-variable">HTTP</span> 协议中两种不同类型的缓存机制。<br>	发送资源请求后响应头可以携带某些字段。<br>	<br>	强缓存：<br>	就是无论资源有没有更新，只要还没到过期时间就不请求新的资源<br>	依据缓存控制相关指令直接判定是否使用本地缓存资源，无需向服务器验证资源是否更新。<br>	常见的控制指令有<span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span><span class="hljs-operator">:</span> <span class="hljs-variable">max</span><span class="hljs-operator">-</span><span class="hljs-variable">age</span>和<span class="hljs-variable">Expires</span>等。<br>	<br>	协商缓存：<br>	就是每次请求资源都检查相关字段，一旦更新就请求资源。<br>	浏览器携带缓存标识向服务器发起请求，由服务器根据请求中的标识判断资源是否可用。<br>	常见的协商缓存机制有<span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">/</span><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span>和<span class="hljs-variable">ETag</span><span class="hljs-operator">/</span><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span>等。<br></code></pre></td></tr></table></figure>
</li>
<li><p>移动端适配方案？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">原答：<span class="hljs-attribute">flex</span> 网格 vh vw <span class="hljs-keyword">@media</span> 再难就JS<br></code></pre></td></tr></table></figure></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/Blog/categories/%E9%9A%8F%E7%AC%94/" class="category-chain-item">随笔</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/Blog/tags/%F0%9F%98%B6%E2%80%8D%F0%9F%8C%AB%EF%B8%8F/" class="print-no-link">#😶‍🌫️</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Interview</div>
      <div>https://taskmanagerol.github.io/Blog/2024/08/31/Interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>TaskManagerOL</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2025/04/12/Electron/" title="Electron">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Electron</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2024/07/01/Eventstorm/" title="Eventstorm">
                        <span class="hidden-mobile">Eventstorm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      a tiny tiny tiny tiny blog
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/Blog/js/local-search.js" ></script>

  <script defer src="/Blog/js/leancloud.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/Blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
