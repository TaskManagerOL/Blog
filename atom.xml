<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Don&#39;t Fall Asleep Now.</title>
  
  <subtitle>a tiny blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-07T13:53:12.667Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TaskManagerOL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MiniProgram</title>
    <link href="http://example.com/2024/04/30/MiniProgram/"/>
    <id>http://example.com/2024/04/30/MiniProgram/</id>
    <published>2024-04-30T11:56:30.000Z</published>
    <updated>2024-06-07T13:53:12.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本篇笔记还会重新排版"><a href="#本篇笔记还会重新排版" class="headerlink" title="本篇笔记还会重新排版"></a>本篇笔记还会重新排版</h2><p>发现运行打不开，说要配置好小程序的AppId，一个身份证号、一个手机号只能注册5个小程序。</p><blockquote><p>管理员身份验证还卡了我一下，说是要重新绑定一遍银行卡，成了。</p></blockquote><p>uniapp运行又打不开，要到微信开发者工具那里设置端口开放，全部关掉重开才行。</p><p>想用element-plus 好，他不给用；想用pinia，好，还是报错，刚刚问了一下，tailwind也是不能用的。哈哈。</p><p>去网上搜索了一下，原来uniapp本来就没什么好用的UI库，难绷。uniapp的风评更是依托。看到这我打算直接转回原生开发平台开发了。</p><p>哈哈。原本以为可以爽复制粘贴的项目，重构吧。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>问题一：阿里的icon引不了，需要去icon库里下载，然后将download好的文件放入工作区，新建一个<code>iconfont.wxss</code>复制<code>iconfont.css</code>的内容。在<code>app.wxss</code>中<code>@import</code>引入<code>iconfont.wxss</code>。</p><p>还需要把最新的链接<code>@font-face</code>复制粘贴替换掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">//在wxml文件中 iconfont表示iconfont.wxss中默认引入源 icon-name表示图标类名，可以在下载的包的html中查看<br><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新的时候要把文件替换，还要把在线链接换掉iconfont.wxss的在线链接换掉。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>问题二：模拟器和真机调试的显示内容不一样。</p><h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p>app.json下pages配置，页面内使用navigator标签进行跳转，一个文件夹下的wxml、wxss、js直接放一起打包了。</p><h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><p><a href="https://lbs.amap.com/api/wx/gettingstarted">入门指南-微信小程序插件 | 高德地图API (amap.com)</a></p><p>logo隐藏找了几篇都不行，决定overflowhidden完事。</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>引入JS文件需要让文件名大写。</p><h2 id="高德定位app-json配置"><a href="#高德定位app-json配置" class="headerlink" title="#高德定位app.json配置"></a>#高德定位app.json配置</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;permission&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;scope.userLocation&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;requiredPrivateInfos&quot;</span>: [<br>    <span class="hljs-string">&quot;chooseLocation&quot;</span>,<br>    <span class="hljs-string">&quot;getLocation&quot;</span><br>  ]<br></code></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>哈哈调用获得用户号码、身份证验证都需要钱。</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//想要在success回调函数中改变data中的数据要</span><br><span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//在主函数或者某个函数中打印要</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)<br></code></pre></td></tr></table></figure><h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用函数初始化data里的数据</span><br><span class="hljs-attr">onLoad</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">init</span>()<span class="hljs-comment">//初始化你data的操作</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>  <span class="hljs-attr">dataName</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">dataName</span><br>&#125;)<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><p>如果下次写还是用uni吧，不是uni烂，是小程序烂</p><h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><p>用div不用view的话盒子撑不开，比如你已经设置了w&amp;h，但他还是会没有大小</p><h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><p>小程序点击不能在函数后面加括号传参，要写个<code>data-xxx</code>然后在<code>e.currentTarget.dataset.xxx</code>里获取</p>]]></content>
    
    
    <summary type="html">小程序就是依托，我说的。</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Network</title>
    <link href="http://example.com/2024/04/22/Network/"/>
    <id>http://example.com/2024/04/22/Network/</id>
    <published>2024-04-22T03:30:16.000Z</published>
    <updated>2024-04-23T08:36:44.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>（HyperText Transfer Protocol，超文本传输协议）</strong></p><h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><ul><li>应用层<ul><li>为应用软件提供了很多服务，构建于协议之上。</li></ul></li><li>传输层<ul><li>数据的传输都是在这层定义的，数据过大分包分片。</li></ul></li><li>网络层<ul><li>为数据在节点之间传输创建逻辑链路</li></ul></li><li>数据链路层<ul><li>通讯实体间建立数据链路连接。</li></ul></li><li>物理层<ul><li>主要作用是定义物理设备如何传输数据（光缆、网线）</li></ul></li></ul><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><ul><li><p>HTTP 0.9</p><ul><li>只有一个GET，发送完毕就关闭tcp协议。</li></ul></li><li><p>HTTP 1.0</p><ul><li>增加了GET POST HEAD</li><li>Status Code</li><li>Header</li><li>多字符集支持</li><li>权限</li><li>缓存</li><li>内容编码</li><li>多部分发送</li></ul><blockquote><p>缺点：每个TCP连接都只能发送一个请求，发送数据完毕连接就关闭。如果还要请求其他资源就必须再新建一个连接。但是TCP新建连接的成本很高，因为客户端和服务器需要三次握手，而且刚开始发送的时候效率很慢。有些浏览器为了解决这个问题使用了一个非标准的Connection字段<code>Connection:Keep-alive</code>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。</p></blockquote></li><li><p>HTTP 1.1</p><ul><li>增加了OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT</li><li>持久连接</li><li>增加host</li></ul><blockquote><p>缺点：虽然1.1版本支持TCP复用，但是同一个TCP连接中，所有数据通信是按照次序进行的，服务器只有处理完一个回应才会进行下一个回应。会造成<strong>队头堵塞</strong>，这就导致一些网页优化技巧：合并脚本和样式表、图片嵌入CSS代码、域名分片等。</p></blockquote></li><li><p>HTTP 2.0</p><ul><li>二进制传输</li><li>信道复用</li><li>分帧传输</li><li>Sever Push</li></ul></li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>第一次握手: 发送SYN报文, 传达信息: “你好, 我想建立连接”</li><li>第二次握手: 回传SYN+ACK报文, 传达信息: “好的, 可以建立链接”;</li><li>第三次握手: 回传ACK报文, 传到信息: “好的, 我知道了, 那我们连接”。然后建立连接</li></ul><blockquote><p>TCP为什么要进行三次握手：因为网络传输有延迟，客户端发送请求到服务器端要求建立连接，如果服务器端直接返回的话可能会产生丢 包的情况导致客户端接收不到数据，客户端会因为超时就关闭了，可能就去发送新的请求了，然而服务端并不知道丢包导致客户端没有接收数据，服务端端口就一直开着，造成了额外的开销。所以需要三次握手确认 这个过程。</p></blockquote><h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><ul><li>请求报文<ul><li>请求组成：请求行，消息报头，请求正文</li></ul></li><li>响应报文<ul><li>响应组成：状态行，消息报头，响应正文</li></ul></li></ul><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul><li>1XX：指示信息–表示请求已接收，继续处理。</li><li>2XX：成功–表示请求已被成功接受、理解、接受。</li><li>3XX：重定向–要完成请求必须进一步操作。</li><li>4XX：客户端错误–请求有语法错误或无法实现。</li><li>5XX：服务端错误–服务端未能实现合法的请求。</li></ul><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是一个 <strong>HTTP 协议中关于缓存的响应头</strong>，它由一些能够允许你定义一个响应资源应该何时、如何被缓存以及缓存多长时间的指令组成。 当浏览器保存了资源的副本从而达到 快速访问的目的 的时候也就是 HTTP 发生了缓存。</p><ul><li>可缓存性：<ul><li>public 任何都可以</li><li>private 只有它发起浏览器可以缓存</li><li>no-cache 去服务端验证才能使用</li><li>no-store 彻底不能</li><li>no-transform 代理服务器、客户端实体不能改动返回内容</li></ul></li><li>到期时间<ul><li>max-age 最大时间</li><li>s-maxage 只有在代理服务器才会生效</li><li>max-stale 只能在发起端设置 就算max-age时间过期 max-stale时间没过期也会走缓存</li></ul></li></ul><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>Connection：keep-alive&#x2F;close 打开关闭</p><p>打开的话就是TCP连接上把HTTP请求的内容发送并接受完返回，不需要多次握手。</p><p>这里可以设置关闭时间，也有些浏览器会有TCP并发限制，比如Chrome浏览器就是6次并发请求限制。</p><h4 id="数据协商"><a href="#数据协商" class="headerlink" title="数据协商"></a>数据协商</h4><ul><li><p>请求</p><ul><li><p>Accept 什么类型</p></li><li><p>Accept-Encoding 压缩方式</p></li><li><p>Accept-Language 语言 </p></li><li><p>user-Agent 浏览器信息</p></li></ul></li><li><p>返回</p><ul><li><p>Content-type 类型</p></li><li><p>Content-Encoding 压缩类型</p></li><li><p>Content-Language 语言</p></li></ul></li></ul><h4 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP 内容安全策略"></a>CSP 内容安全策略</h4><ul><li>限制方式：Content-Security-Policy:””</li></ul><p>如果没有按照限制的方式加载会发回一个错误信息</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS是通过握手进行加密，通过公钥进行加密，通过私钥进行解密。</p><ul><li>流程<ul><li>客户端请求服务器获取<code>证书公钥</code></li><li>客户端解析证书</li><li>生成随机值</li><li>用<code>公钥加密</code>随机值生成密钥</li><li>客户端将<code>秘钥</code>发送给服务器</li><li>服务器用<code>私钥</code>解密得到随机值</li><li>将信息和随机值混合在一起进行对称加密</li><li>将加密的内容发送给客户端</li><li>客户端用<code>秘钥</code>解密信息</li></ul></li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="跨域原因"><a href="#跨域原因" class="headerlink" title="跨域原因"></a>跨域原因</h4><p>浏览器的同源策略限制了跨域请求资源。</p><h4 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h4><p>JSONP（JSON with Padding）是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问。具体来说，当一个网页想要从另一个域名获取数据时，它会向那个域名发送一个请求，然后在返回的响应中插入一段script标签，这段标签的src属性就是数据所在的URL。这样，浏览器就会去执行这段script标签中的JavaScript代码，从而获取到数据。但是这种方法存在一定的安全风险，因为它绕过了浏览器的同源策略。</p><h4 id="跨域的限制"><a href="#跨域的限制" class="headerlink" title="跨域的限制"></a>跨域的限制</h4><ul><li>默认跨域允许的方法只有GET、POST、HEAD，其他的方法都不允许。</li><li>默认允许Content-type以下三个，其他的预请求验证，通过就能发送。<ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul></li><li>请求头限制，自定义的请求头是不允许的，预请求验证才能通过。</li></ul><h2 id="Cookie-amp-Session-amp-Token-的区别"><a href="#Cookie-amp-Session-amp-Token-的区别" class="headerlink" title="Cookie &amp; Session &amp; Token 的区别"></a>Cookie &amp; Session &amp; Token 的区别</h2><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>客户端的浏览器发出HTTP请求，服务器会进行Cookie设置，也就是set-Cookie，Cookie发送给浏览器之后，浏览器会保存起来，之后发送的每一个请求都会附上这个Cookie。</p><p>但是Cookie本身是有有被篡改风险的，同时用户可能禁用、容量限制4KB。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>相当于加密版的Cookie，首先也是浏览器发出HTTP请求，服务器这边会设置一个SessionID，并把此ID和会话结束时间一起记录到Cookie返回到客户端，然后不带有用户的密码，只带有SessionID和会话结束时间，在结束时间到的时候就删除cookie，然后由于cookie性质，每次访问都会附上cookie，所以就可以实现长时间登录了。</p><p>但是如果多很多用户，那么SessionID对于服务器将是一个巨大的负担；如果拥有多台服务器的话，那么SessionID又需要去共享给每一台服务器。太笨拙了。</p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>多服务器的情况下，如果想要存储SessionID的话，可以放到数据库中，但是如果数据库和后端连接的某个地方又炸了呢。种种情况下催生出了JWT(JSON Web Token)</p><p>也是像上面那样的，首先是浏览器发出HTTP请求，给到一个JSON格式的账号密码给服务端，服务端将其转化为JWT签名密文发给客户端，根据Cookie的性质，每次都会把JWT密文发回给服务端，这样就可以认证登录了。</p><blockquote><p>JWT是由三个部分构成的 <code>header</code>.<code>payload</code>.<code>signature</code></p><p><code>header</code>部分声明需要用什么算法来生成签名。<br><code>payload</code>部分是一些特殊的数据，比如有效期之类的。</p><p><code>header</code> <code>payload</code>的JSON格式Base64编码之后 服务器保存的一段密码对这俩进行算法运算，算出来的东西就是<code>signature</code></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Cookie是一个载体，Session是保存在服务器那边的下信息，Token是诞生于服务器但是保存在浏览器这边。</p><h2 id="Session-Storage-amp-Local-Storage-amp-Cookie-的区别"><a href="#Session-Storage-amp-Local-Storage-amp-Cookie-的区别" class="headerlink" title="Session Storage &amp; Local Storage &amp; Cookie 的区别"></a>Session Storage &amp; Local Storage &amp; Cookie 的区别</h2><h3 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h3><p>Session Storage 是用于本地存储一个会话中的数据，当会话结束时数据就会被销毁，也就是浏览器关闭的时候就会被销毁。<strong>Session Storage 和 Session 不是一个东西</strong> 。</p><p>是 Web Storage 用于本地存储的一个方式。</p><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p>Local Storage 是持久化的存储数据，不删除j（通过各种方式）是不会消失的。</p><p>是 Web Storage 用于本地存储的一个方式。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie 是存储在浏览器端的一小段文本数据，每次向服务端发送请求的时候Cookie都会被发送过去。故Cookie不能作为前端的数据缓存。</p><p>是HTTP规范的一部分。</p>]]></content>
    
    
    <summary type="html">网络层及其周边知识的学习</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Amap</title>
    <link href="http://example.com/2024/04/08/Amap/"/>
    <id>http://example.com/2024/04/08/Amap/</id>
    <published>2024-04-08T09:39:27.000Z</published>
    <updated>2024-04-24T11:03:04.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高德地图api使用"><a href="#高德地图api使用" class="headerlink" title="高德地图api使用"></a>高德地图api使用</h2><p><a href="https://lbs.amap.com/api/javascript-api-v2/summary">概述-地图 JS API 2.0|高德地图API (amap.com)</a></p><h3 id="Vue-使用前准备"><a href="#Vue-使用前准备" class="headerlink" title="Vue 使用前准备"></a>Vue 使用前准备</h3><ul><li><p>首先登录高德，注册成为开发者，创建key，服务平台选择Web端（JS API）。</p></li><li><p>进入工作区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">   npm i @amap/amap-jsapi-loader --save<br></code></pre></td></tr></table></figure></li><li><p>在需要使用的组件下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AMapLoader</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@amap/amap-jsapi-loader&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onMounted, onUnmounted &#125; from &quot;vue&quot;;<br>import AMapLoader from &quot;@amap/amap-jsapi-loader&quot;;<br><br>let map = null;<br><br>onMounted(() =&gt; &#123;<br>  AMapLoader.load(&#123;<br>    key: &quot;&quot;, // 申请好的Web端开发者Key，首次调用 load 时必填<br>    version: &quot;2.0&quot;, // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15<br>    plugins: [&quot;AMap.Scale&quot;], //需要使用的的插件列表，如比例尺&#x27;AMap.Scale&#x27;，支持添加多个如：[&#x27;...&#x27;,&#x27;...&#x27;]<br>  &#125;)<br>    .then((AMap) =&gt; &#123;<br>      map = new AMap.Map(&quot;container&quot;, &#123;<br>        // 设置地图容器id<br>        viewMode: &quot;3D&quot;, // 是否为3D地图模式<br>        zoom: 11, // 初始化地图级别<br>        center: [116.397428, 39.90923], // 初始化地图中心点位置<br>      &#125;);<br>    &#125;)<br>    .catch((e) =&gt; &#123;<br>      console.log(e);<br>    &#125;);<br>&#125;);<br><br>onUnmounted(() =&gt; &#123;<br>  map?.destroy();<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>#container &#123;<br>  width: 100%;<br>  height: 800px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Vue-水印去除"><a href="#Vue-水印去除" class="headerlink" title="Vue 水印去除"></a>Vue 水印去除</h3><p>在index.html中加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.amap-logo</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: none;</span><br><span class="language-css">      <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><br><span class="language-css">    <span class="hljs-selector-class">.amap-copyright</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">高德API小小标记一下</summary>
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Pinia</title>
    <link href="http://example.com/2024/03/25/Pinia/"/>
    <id>http://example.com/2024/03/25/Pinia/</id>
    <published>2024-03-25T08:31:57.000Z</published>
    <updated>2024-04-06T13:22:26.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pinia简介"><a href="#Pinia简介" class="headerlink" title="Pinia简介"></a>Pinia简介</h1><p>Pinia 是 Vue 的专属状态管理库，可以同时支持vue2和vue3，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 <code>export const state = reactive(&#123;&#125;)</code> 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些<a href="https://cn.vuejs.org/guide/scaling-up/ssr#cross-request-state-pollution">安全漏洞</a>。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：</p><ul><li>Devtools 支持<ul><li>追踪 actions、mutations 的时间线</li><li>在组件中展示它们所用到的 Store</li><li>让调试更容易的 Time travel</li></ul></li><li>热更新<ul><li>不必重载页面即可修改 Store</li><li>开发时可保持当前的 State</li></ul></li><li>插件：可通过插件扩展 Pinia 功能</li><li>为 JS 开发者提供适当的 TypeScript 支持以及<strong>自动补全</strong>功能。</li><li>支持服务端渲染</li></ul><p>Pinia其实就是Vuex5，所以他们是一样的东西。</p><p>它拥有比MITT更多的功能。而且也没有遇到兄弟组件传值出现的问题。好用。</p><h1 id="Pinia安装"><a href="#Pinia安装" class="headerlink" title="Pinia安装"></a>Pinia安装</h1><p><a href="https://pinia.vuejs.org/zh/getting-started.html">Pinia官网</a></p><p>Nodejs包管理器下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install pinia<br></code></pre></td></tr></table></figure><p>vite配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(pinia).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h1><h3 id="Store简介"><a href="#Store简介" class="headerlink" title="Store简介"></a>Store简介</h3><p>Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，<strong>它承载着全局状态</strong>。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有<strong>三个概念</strong>，<a href="https://pinia.vuejs.org/zh/core-concepts/state.html">state</a>、<a href="https://pinia.vuejs.org/zh/core-concepts/getters.html">getter</a> 和 <a href="https://pinia.vuejs.org/zh/core-concepts/actions.html">action</a>，我们可以假设这些概念相当于组件中的 <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p><h3 id="Store使用"><a href="#Store使用" class="headerlink" title="Store使用"></a>Store使用</h3><p>先创建一个js&#x2F;ts文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//我是直接创到了public目录下  /public/store/user.js</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref,computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    count.<span class="hljs-property">value</span>++<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123; count, doubleCount, increment &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后直接使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/public/stores/user.js&#x27;</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useCounterStore</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-property">count</span>)<br></code></pre></td></tr></table></figure><p>就行了，感觉比MITT方便不少，store似乎就是一个reactive对象。可以解构。</p>]]></content>
    
    
    <summary type="html">Pinia 是 Vue 的专属状态管理库，允许你跨组件或页面共享状态。</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey</title>
    <link href="http://example.com/2024/03/01/AutoHotKey/"/>
    <id>http://example.com/2024/03/01/AutoHotKey/</id>
    <published>2024-03-01T05:33:37.000Z</published>
    <updated>2024-03-09T07:00:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>工作的时候手碰着键盘就不想去动鼠标了，但是有一些常用的文件夹或者软件需要点点点点开，就算把他放在桌面或者开始界面都还是需要点点点，那么对于我们这种快捷键爱好者应该怎么设置一个全局快捷键呢。</p><p>本来呢这篇文章是关于 文件夹&#x2F;软件全局快捷键设置的 但是我使用的方法吧他时灵时不灵</p><blockquote><p>就是创快捷方式点属性改快捷键</p></blockquote><p>虽然偶尔能打开，但是更多的是按完快捷键卡顿很久才打开或者干脆开不开了，很蠢。</p><p>干脆去找桌面脚本语言了。</p><h1 id="AutoHotKey"><a href="#AutoHotKey" class="headerlink" title="AutoHotKey"></a>AutoHotKey</h1><p>找到了这个，这玩意好用啊，无论是文件还是网站都可以快速打开，真的很爽。</p><p>现在只是探索了一个简单的使用方法，还有很多可以尝试来着。</p><p><a href="https://www.autohotkey.com/">AutoHotkey</a> </p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><p>首先就是进行一个2.0版本的下载。</p></li><li><p>下载完成之后是一个autohotkey dash，新建一个empty文件，直接用右键啥方式打开都行（我是vscode），进去编写。</p></li><li><p>编写好了右键使用其他方式打开，找到autohotkey目录下的<code>AutoHotkeyU64.exe</code>打开 一路确定</p></li><li><p>然后双击你写的脚本文件，就开始运行了。</p></li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li><p><code>;</code>是注释</p></li><li><p>热键：</p><ul><li><code>#</code>:win键</li><li><code>!</code>:alt键</li><li><code>^</code>:ctrl键</li><li><code>+</code>:shift键</li></ul></li><li><p>连接符是<code>::</code> 用于连接热键和运行</p></li><li><p>运行是 <code>Run</code> 运行后面跟文件路径、网址、程序</p></li><li><p>示例：</p><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ahk"><span class="hljs-comment">;ctrl+shift+z 打开c盘</span><br><span class="hljs-title">^+z::</span>Run C:\<br></code></pre></td></tr></table></figure></li></ul><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>如果需要不双击运行而是一开机就运行，那么执行以下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">把写好的脚本放到<br>&#123;C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup&#125;<br>或者也可能是<br>&#123;C:\用户\用户名\AppData\Roaming\Microsoft\Windows\开始菜单\程序\启动&#125;<br></code></pre></td></tr></table></figure><p>这样之后每次开电脑就会打开，虽然不是马上开，等个几秒就可以了</p>]]></content>
    
    
    <summary type="html">AutoHotKey是一个脚本语言，用来编写一个简单的脚本还是很方便的。</summary>
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="快捷使用" scheme="http://example.com/tags/%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://example.com/2024/01/30/Nginx/"/>
    <id>http://example.com/2024/01/30/Nginx/</id>
    <published>2024-01-30T12:53:18.000Z</published>
    <updated>2024-03-16T11:46:48.063Z</updated>
    
    <content type="html"><![CDATA[<p>下载路径：<a href="https://nginx.org/en/download.html">nginx下载</a></p><p>Nginx是目前最流行的web服务器，同类型的还有Apache、Cloudflare、OpenResty。最开始是由⼀个叫做igor的俄罗斯的程序员开发的，2019年3⽉11⽇被美国的F5公司以6.7亿美元的价格收购，现在Nginx是F5公司旗下的⼀款产品了。</p><h1 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h1><ul><li>Master进程是Nginx的主进程，负责读取和验证配置文件。</li><li>worker进程就是nginx的工作进程，负责处理实际的请求。</li><li>master进程只可以有一个，但是worker进程可以有很多个。</li></ul><h1 id="Nginx部署静态资源"><a href="#Nginx部署静态资源" class="headerlink" title="Nginx部署静态资源"></a>Nginx部署静态资源</h1><p>nginx静态资源部署运行时需要开任务管理器检查是否存在。</p><p>子文件夹：</p><ul><li>html：用于放你需要部署的、打包好的静态资源。tips：直接放有html的那一堆不要再多包一个文件夹了。</li><li>logs：用于放每次运行的情况。</li><li>conf：是配置，可以在nginx.conf中修改端口号，默认80，如果占用就会报错，可修改。<ul><li>端口号：需要修改时打开nginx.conf文件，找到server-&gt;listen 修改后面端口号即可</li></ul></li></ul><h1 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h1><h3 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h3><p>Nginx的配置⽂件是由⼀系列的指令组成的，每个指令都是由⼀个指令名和⼀个或者多个参数组成的。</p><p>指令和参数之间使⽤空格来分隔，指令以分号 ; 结尾，参数可以使⽤单引号或者双引号来包裹。</p><p>配置⽂件分为以下⼏个部分：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 全局块</span><br><br><span class="hljs-attribute">worker_processes</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-section">events</span> &#123;<br><span class="hljs-comment"># events块</span><br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># http块</span><br>    <span class="hljs-section">server</span> &#123;<br><span class="hljs-comment"># server块</span><br>         <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-comment"># location块</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h5><ul><li>worker_processes是用于控制worker进程数量的，也可以设置auto，worker进程数量保持同服务器CPU内核数量相同比较合适</li><li>其他一些能配置的东西包括运行Nginx服务器的用户组、进程PID存放路径、日志存放路径和类型以及配置文件引入等。</li></ul><h5 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h5><blockquote><p>用于配置客户端和服务器网络连接的一些配置。比如指定每个worker进程可以接收多少个网络连接、网络IO模型等。</p></blockquote><ul><li>use：指定使用哪种网络IO模型，只能在events块中进行配置。</li><li>worker_connections：每个worker process允许链接的最大连接数。</li></ul><h5 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h5><blockquote><p>虚拟主机、反向代理、负载均衡等都在这里配置，http块可以包含很多server块又叫虚拟主机。</p></blockquote><ul><li>include：nginx可以使用include指令引入其他配置文件。</li><li>default_type：默认类型，如果请求的URL没有包含文件类型，会使用默认类型。</li><li>sendflie：开启高效文件传输模式。</li><li>keepalive_timeout：连接超时时间。</li><li>access_log：日志的存放路径和类型。</li><li>log_format：自定义日志格式。</li><li>sendfile_max_chunk：设置sendfile最⼤传输⽚段⼤⼩，默认为0，表示不限制。</li><li>keepalive_requests：每个连接的请求次数。</li><li>keepalive_timeout： keepalive超时时间。</li><li>gzip：开启gzip压缩。</li><li>gzip_min_length： 开启gzip压缩的最⼩⽂件⼤⼩。</li><li>gzip_comp_level：gzip压缩级别，1-9，级别越⾼压缩率越⾼，但是消耗CPU资源也越多。</li><li>gzip_types：gzip压缩⽂件类型。</li><li>upstream： upstream指令⽤于定义⼀组服务器，⼀般⽤来配置反向代理和负载均衡。</li><li>ip_hash指令⽤于设置负载均衡的⽅式，ip_hash表示使⽤客户端的IP进⾏hash，这样可以保证同⼀个客户端的请求每次都会分配到同⼀个服务器，解决了session共享的问题。</li><li>weight ⽤于设置权重，权重越⾼被分配到的⼏率越⼤</li></ul><h5 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h5><ul><li><p>listen：监听IP和端⼝。</p><ul><li>listen指令⾮常灵活，可以指定多个IP和端⼝，也可以使⽤通配符</li></ul>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">下⾯是⼏个实际的例⼦：<br># listen <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">80</span>; # 监听来⾃<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>的<span class="hljs-number">80</span>端⼝的请求<br># listen <span class="hljs-number">80</span>; # 监听来⾃所有IP的<span class="hljs-number">80</span>端⼝的请求<br># listen *:<span class="hljs-number">80</span>; # 监听来⾃所有IP的<span class="hljs-number">80</span>端⼝的请求，同上<br># listen <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>; # 监听来⾃来⾃<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>的<span class="hljs-number">80</span>端⼝，默认端⼝为<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></li><li><p>server_name：⽤来指定虚拟主机的域名，可以使⽤精确匹配、通配符匹配和正则匹配等⽅式</p></li><li><p>location：location块⽤来配置请求的路由，⼀个server块可以包含多个location块，每个location块就是⼀个请求路由。</p><ul><li>root：root指令⽤于指定请求的根⽬录，可以是绝对路径，也可以是相对路径</li><li>index：index指令⽤于指定默认⽂件，如果请求的是⽬录，则会在⽬录下查找默认⽂件</li></ul></li><li><p>error_page：⽤于指定错误⻚⾯，可以指定多个，按照优先级从⾼到低依次查找</p></li></ul><h1 id="Nginx的常用模块"><a href="#Nginx的常用模块" class="headerlink" title="Nginx的常用模块"></a>Nginx的常用模块</h1><ul><li><p>http_access_module ：接受或者拒绝特定的客户端请求</p></li><li><p>http_auth_basic_module ：HTTP基本认证，使用用户名和密码来限制对资源的访问</p></li><li><p>http_autoindex_module ：⾃动索引，⽤于显示⽬录列表</p></li><li><p>http_browser_module ：从 User-Agent 请求头中获取和识别客户端浏览器</p></li><li><p>http_charset_module ：添加特定的字符集到 Content-Type 响应头中</p></li><li><p>http_empty_gif_module ：返回⼀个1像素的透明GIF图⽚</p></li><li><p>http_fastcgi_module ：FastCGI⽀持</p></li><li><p>http_geo_module ：从IP地址中获取地理位置信息</p></li><li><p>http_gzip_module ：Gzip压缩⽀持</p></li><li><p>http_limit_conn_module ：限制并发连接数</p></li><li><p>http_limit_req_module ：限制请求速率</p></li><li><p>http_map_module ：从变量中获取值</p></li><li><p>http_memcached_module ：Memcached⽀持</p></li><li><p>http_proxy_module ：反向代理⽀持</p></li><li><p>http_referer_module ：防盗链</p></li><li><p>http_rewrite_module ：URL重写</p></li><li><p>http_scgi_module ：转发请求到SCGI服务器</p></li><li><p>http_ssi_module ：处理和⽀持SSI（Server Side Includes）</p></li><li><p>http_split_clients_module ：根据客户端IP地址或者其他变量将客户端分配到组中，⼀般⽤于A&#x2F;B测试</p></li><li><p>http_upstream_hash_module ：启⽤⼀致性哈希负载均衡</p></li><li><p>http_upstream_ip_hash_module ：启⽤IP哈希负载均衡</p></li><li><p>http_upstream_keepalive_module ：启⽤⻓连接负载均衡</p></li><li><p>http_upstream_least_conn_module ：启⽤最少连接负载均衡</p></li><li><p>http_upstream_zone_module ：启⽤共享内存负载均衡</p></li><li><p>http_userid_module ：为客户端设置⼀个唯⼀的ID（UID、cookie）</p></li><li><p>http_uwsgi_module ：转发请求到uWSGI服务器，⼀般⽤于Python应⽤</p></li></ul><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><blockquote><p>正向代理：正向代理就是代理客户端，比如想访问某些国外网站的时候访问不了，这个时候就需要VPN代理服务器进行正向代理，帮你代理客户端</p></blockquote><blockquote><p>反向代理：反向代理就是代理服务端，比如访问一个网站的时候，比如访问咕噜咕噜（Google），他有很多很多服务器，但是对外暴露的只有一个域名，那我们访问的请求会被转发到后面的服务器上，真实的端口IP服务器信息被隐藏。</p></blockquote><h3 id="第一步：在upstream里面放服务器配置："><a href="#第一步：在upstream里面放服务器配置：" class="headerlink" title="第一步：在upstream里面放服务器配置："></a>第一步：在upstream里面放服务器配置：</h3><p>在upstream后面是一个名字类似Vue路由配置中的name，可以随便取。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> name &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8000</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8001</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8002</span>;<br>    ...(启动的服务)<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候后台服务器的性能可能不同，以下为两种策略：</p><ul><li>ip_hash指令⽤于设置负载均衡的⽅式，ip_hash表示使⽤客户端的IP进⾏hash，这样可以保证同⼀个客户端的请求每次都会分配到同⼀个服务器，解决了session共享的问题。</li><li>weight：⽤于设置权重，权重越⾼被分配到的⼏率越⼤，用于分流。</li></ul><h3 id="第二步：在localtion中配置："><a href="#第二步：在localtion中配置：" class="headerlink" title="第二步：在localtion中配置："></a>第二步：在localtion中配置：</h3><p>localtion后面的&#x2F;…是自己取的名字，意思是将所有访问<a href="http://app的请求发送到前面取的name里,/">http://app的请求发送到前面取的name里，</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">localtion</span> /route &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样请求都被代理到我们所有服务器中，默认是以轮询的方式来代理。</p><h1 id="HTTPS配置"><a href="#HTTPS配置" class="headerlink" title="HTTPS配置"></a>HTTPS配置</h1><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>HTTP默认端口是80，HTTPS默认端口是443。</p><p>HTTPS协议需要使用到SSL证书，主流云平台上都可以申请到SSL证书，也可以通过openssl生成一个自签名的证书。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">生成私钥文件：<br>openssl genrsa -out <span class="hljs-keyword">private</span>.<span class="hljs-keyword">key</span> <span class="hljs-number">2048</span><br>根据私钥生成证书签名请求文件：<br>openssl req -<span class="hljs-built_in">new</span> -<span class="hljs-keyword">key</span> <span class="hljs-keyword">private</span>.<span class="hljs-keyword">key</span> -out cert.csr<br>使用私钥对证书申请进行签名从而生成证书文件：<br>openssl x509 -req -<span class="hljs-keyword">in</span> cert.csr -out cacert.pem -signkey <span class="hljs-keyword">private</span>.<span class="hljs-keyword">key</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在server中修改listen监听端口，改为 <code>443 ssl</code></p><ul><li>ssl_certificate：用于放证书文件路径（填入完整证书链可以不报红）</li><li>ssl_certificate_key：用于放证书私钥文件路径（填入完整证书链可以不报红）</li><li>ssl_session_timeout：缓存有效期</li><li>ssl_protocols：安全链接可选的加密协议</li><li>ssl_ciphers：配置加密套件&#x2F;加密算法</li><li>ssl_prefer_server_ciphers：使用服务器端的首选算法</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>在http的server上加如下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span><span class="hljs-variable">$server_name</span><span class="hljs-variable">$request_url</span><br></code></pre></td></tr></table></figure><h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>虚拟主机可以在一台服务器上部署多个站点，nginx的虚拟主机是通过server块来实现的，每个server块就是一个虚拟主机，通过server_name来指定这个虚拟主机的域名。</p>]]></content>
    
    
    <summary type="html">常用的用于设置代理的工具，同类的有使用Golang写的更轻量一点的Caddy。</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="服务器" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Problem</title>
    <link href="http://example.com/2024/01/30/Problem/"/>
    <id>http://example.com/2024/01/30/Problem/</id>
    <published>2024-01-30T12:05:30.000Z</published>
    <updated>2024-04-24T11:22:18.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-gt-Time-out"><a href="#Git-gt-Time-out" class="headerlink" title="Git -&gt; Time out"></a>Git -&gt; Time out</h1><ul><li><p>背景：</p><p>用于解决git上传Time out的情况。<br>无论是用git的push还是hexo的deploy，经常会出现Time out的情况。</p></li><li><p>解决方法一：</p><p>重启+开开关关梯子+更换网络</p><blockquote><p>这个的话完全看玄学，我之前经常开开关关梯子+换网就解决了，很抽象。</p></blockquote></li><li><p>解决方法二：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> https<span class="hljs-selector-class">.proxy</span> <span class="hljs-comment">//使用代理</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https<span class="hljs-selector-class">.proxy</span> <span class="hljs-comment">//取消代理</span><br></code></pre></td></tr></table></figure><blockquote><p>这个我用过很多很多很多很多次，都把他背下来了，有时候确实有用</p></blockquote></li><li><p>解决方法三：</p><p>在传TS笔记的时候家里的网死活传不上去，尝试过网上所有的方法了整了一下午，很抽象的是可以去外网。</p><p>那不妨直接用git自己内置的update flies，即拖动上传。</p></li></ul><h1 id="TypeScript-gt-“Could-not-find-a-declaration-file-for-module-‘xxx-js’-‘xxx-js’-implicitly-has-an-‘any’-type"><a href="#TypeScript-gt-“Could-not-find-a-declaration-file-for-module-‘xxx-js’-‘xxx-js’-implicitly-has-an-‘any’-type" class="headerlink" title="TypeScript -&gt; “Could not find a declaration file for module ‘xxx.js’. ‘xxx.js’ implicitly has an ‘any’ type."></a>TypeScript -&gt; “Could not find a declaration file for module ‘xxx.js’. ‘xxx.js’ implicitly has an ‘any’ type.</h1><ul><li><p>背景：</p><p>尝试使用TS的时候呢，遇到了一些问题，在main.ts中引用已经写好的js文件时(旧版本已经写好的配置文件，详见blog中的vue.config)发生报错，错误代码为ts(7016)，一眼ts和原生起冲突了。</p></li><li><p>解决方法一：</p><p>我没试过这个方法，但是Vue2的可以试试（也许）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//将import引入改为require引入</span><br><span class="hljs-keyword">import</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module.js&quot;</span><br><span class="hljs-comment">//改为=&gt;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module.js&#x27;</span>)<br></code></pre></td></tr></table></figure><p>为啥我没试过呢，因为在Vue3中，require语法已经不能使用了，在Vue3版本中，直接使用上述的require语法会导致报错，提示require不是一个函数。这是因为Vue3及以上版本使用了ES Module语法，不再支持使用CommonJS语法来引入模块。</p><blockquote><p>小知识：require和import的性能比较</p><p><code>require</code> 的性能相对于 <code>import</code> 稍低。</p><p>因为 <code>require</code> 是在运行时才引入模块并且还赋值给某个变量，而 <code>import</code> 只需要依据 <code>import</code> 中的接口在编译时引入指定模块所以性能稍高</p></blockquote></li><li><p>解决方法二：</p><p>也是我自己琢磨出来的方法，适用性比较低吧可能。</p><p>问题既然出在 TS 和 JS 对接上，那我向上兼容，把 JS 文件更新成 TS 的不就完事了，在修改引用的文件后缀和文件内容后果然还是不报错了。</p></li><li><p>解决方法三：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//先在项目目录(也就是和众多config同目录)下创建一个modules.d.ts</span><br><span class="hljs-comment">//modules.d.ts (modules可以自己取名字)</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.js&#x27;</span>;<br><br><span class="hljs-comment">//然后在 tsconfig.json 中的 &quot;include&quot; 配置下添加一个 &quot;modules.d.ts&quot;</span><br><span class="hljs-comment">// tsconfig.json</span><br><span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src/**/*.ts&quot;</span>, <span class="hljs-string">&quot;src/**/*.tsx&quot;</span>, <span class="hljs-string">&quot;src/**/*.vue&quot;</span>, <span class="hljs-string">&quot;module.d.ts&quot;</span>]<br><br><span class="hljs-comment">//然后在你的main.ts中用正常的import xx from &#x27;xx.js&#x27; 即可</span><br><span class="hljs-comment">//main.ts</span><br><span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xx.js&#x27;</span><br></code></pre></td></tr></table></figure><p>推荐使用的方法，无论是你自己的Js文件还是引的依赖包都可以从这里引入到main.ts中，如果引依赖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//modules.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;依赖名&#x27;</span>;<br><br><span class="hljs-comment">//main.ts</span><br><span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;依赖名&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="TypeScript-gt-代码未错误但出现错误提醒（编辑器为vscode）"><a href="#TypeScript-gt-代码未错误但出现错误提醒（编辑器为vscode）" class="headerlink" title="TypeScript  -&gt; 代码未错误但出现错误提醒（编辑器为vscode）"></a>TypeScript  -&gt; 代码未错误但出现错误提醒（编辑器为vscode）</h1><ul><li><p>背景：</p><p>在写TS项目的时候发现出了报错提示，但是我是直接粘的element-plus的代码，报的错也很奇怪，网上搜也解决不彻底，最抽象的是项目能跑。</p></li></ul><blockquote><p> 后面才知道是因为eslint（vscode扩展-用于检查js书写错误）</p></blockquote><p>​遂去找ts检查扩展，发现根本找不到。</p><blockquote><p>好像目前就没有好用的ts语法检查扩展</p></blockquote><ul><li><p>解决方法一：</p><p>首先这个方法我是行不通的，但是我觉得可能是我某个扩展的问题。</p><p>打开设置 -&gt; 搜索validate -&gt;下面找到并设置禁止typescript验证 -&gt; 重新启动编辑器。</p></li><li><p>解决方法二：</p><p>直接让他不检查语法错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">在script标签下加上这行注释。注意，是注释！！<br><br><span class="hljs-comment">// @ts-nocheck</span><br></code></pre></td></tr></table></figure><p>这样ts代码就不会报错了，但也检查不出来问题了，至少不难受了看着。</p></li><li><p>解决方法三：</p><p>没有三了，按道理来说网上是有某种关于eslint配置可行的，但是我配了两个都不行。我以后找到了再来更新吧🤕</p></li></ul><h1 id="IPv4-amp-IPv6-gt-“http-proxy-error”"><a href="#IPv4-amp-IPv6-gt-“http-proxy-error”" class="headerlink" title="IPv4&amp;IPv6 -&gt; “http proxy error”"></a>IPv4&amp;IPv6 -&gt; “http proxy error”</h1><p>之前在打ICT的时候就遇到过类似的问题，当时以为是es6的fetch哪里没配置好，后面换成axios就可以了，但实际不是这样。今天在打服创的时候又遇到这玩意了。</p><ul><li><p>背景</p><p>跨域，localhost但是不同端口跨域。</p><p>我前端config文件明明配置得好好的，但是f12永远报我接的是前端跑着的端口，代码编辑器上更是出一个http proxy error，我就对着一直改啊改啊，发现一直还是这个报错，后面找到是后端的问题。</p></li><li><p>解决方法：</p><p>我遇到的问题实际上是后端允许的网络协议和前端发出来的网络协议不同，用的python后端，那边是给的一个IPv4接口，前端用的是IPv6，结果接不上，解决方法就是更改后端接口使用的网络协议。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#此处就放后端部分代码了，语言是python</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,port = <span class="hljs-number">5000</span>)<br>    <span class="hljs-comment">#在本地的端口5000运行，配置IPv4 IPv6都可以使用，不然前端报错http proxy error</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Headers-gt-400-Bad-REQUEST-文件上传"><a href="#Headers-gt-400-Bad-REQUEST-文件上传" class="headerlink" title="Headers -&gt; 400(Bad REQUEST)文件上传"></a>Headers -&gt; 400(Bad REQUEST)<code>文件上传</code></h1><ul><li><p>背景：</p><p>是需要上传一个文件，又是经典的Postman可以前端不行。</p></li><li><p>解决方法：</p><p>最后发现是Headers的问题，大家都说：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">headers</span>: &#123;<br>     <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;multipart/form-data&#x27;</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>上传文件要这样子配置，但是实际上我把它整个headers删了反而成功了，原因是什么呢？</p><blockquote><p>发现去掉 Content-Type 的请求头部多了一个 boundary ，查查。</p><p><strong>Boundary 是一种用于分隔多个实体（如文件、表单字段等）的标识符</strong>。 它通常用于 multipart&#x2F;form-data 类型的请求中，用于将多个部分组合在一起，并指示它们的边界。</p></blockquote><p>原来<code>POST</code>请求上传文件的时候是不需要自己设置 Content-Type，会自动给你添加一个 boundary ，用来分割消息主体中的每个字段，如果这个时候自己设置了 Content-Type， 服务器反而不知道怎么分割各个字段。</p></li></ul><h1 id="Javascript-amp-CSS-gt-label点击事件阻止"><a href="#Javascript-amp-CSS-gt-label点击事件阻止" class="headerlink" title="Javascript&amp;CSS -&gt; label点击事件阻止"></a>Javascript&amp;CSS -&gt; label点击事件阻止</h1><ul><li><p>背景：</p><p>以下HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;console.log(1)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p>怎么才能实现点击div但是不触发label的点击事件呢？我找了很多方法CSS的还有JS的都不太行，CSS的话是想hover到div上时label的点击事件取消，但是又会连带到div里，用div包label和div加absolute又很麻烦因为还有别的需求。JS是想使用stopPropagation阻止冒泡，但是label的点击事件不受影响。</p></li><li><p>解决方法：</p><p>改成这个结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;inputFocus&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;stopFocus()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;inputRef&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">inputFocus</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    inputRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">click</span>();<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">stopFocus</span> = (<span class="hljs-params">event</span>) =&gt; &#123;<br>    <span class="hljs-comment">//业务函数</span><br>    ...<br>    <span class="hljs-comment">//阻止冒泡</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就行了div是可以使用stopPropagation函数的。</p><blockquote><p>但是为什么label不行呢，全网查找了一下没找到。</p><p>去MDN看了一下对于这个标签的描述：</p><p>不要在 <code>label</code> 元素内部放置可交互的元素，这样做会让用户更难激活&#x2F;触发与 <code>label</code> 相关联的表单输入元素。</p></blockquote></li></ul><h1 id="HTML-amp-Javascript-gt-“input标签使用”"><a href="#HTML-amp-Javascript-gt-“input标签使用”" class="headerlink" title="HTML&amp;Javascript -&gt; “input标签使用”"></a>HTML&amp;Javascript -&gt; “input标签使用”</h1><ul><li><p>背景：</p><p>需求是上传图片、显示、点icon删除、点icon预览。</p><p>但是卡在删除上面了，有一个小bug——每次点击icon删除后就会没办法上传之前上传的那一张图片。</p></li><li><p>解决方法：</p><p>其实很简单只不过说我把input标签隐藏起来了，每次删除都是把显示的图片删掉，原本传到input里图片的没删掉。</p><p>但为什么还要写到Problem中呢？</p><p>因为我发现input里图片删除也很有意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;input ref=&quot;inputRef&quot;&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    const inputRef = ref(&#x27;&#x27;)<br>    //inputRef.value 对应的是他的页面标签<br>    //inputRef.value.value 对应的是他的图片(路径)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h1 id="Vue-gt-“addEventListener-is-not-a-function”"><a href="#Vue-gt-“addEventListener-is-not-a-function”" class="headerlink" title="Vue -&gt; “addEventListener is not a function”"></a>Vue -&gt; “addEventListener is not a function”</h1><ul><li><p>背景：</p><p>在引一个3d canvas库，但是一直报这个错误，后面找到是vue的ref问题，其实报这个错误是因为一直都获取不到标签。</p></li><li><p>解决方法：</p><p>添加onMounted函数，是这样的：</p><ul><li>Vue 会首先解析和执行组件中的 <code>&lt;script&gt;</code> 部分，这包括响应式数据、计算属性、监听器、方法等的定义。</li><li>接着会编译模板，将数据绑定到视图中，渲染生成的 HTML。这一步通常是在<code>beforeCreate</code> 和 <code>created</code> 阶段中完成，因为 Vue 需要在渲染之前准备好数据、计算属性等。</li><li><code>onMounted</code> 生命周期钩子函数是在 Vue 3 中的 Composition API 中使用的，它在组件挂载到 DOM 后执行。在 Vue 3 的生命周期中，类似于 <code>onMounted</code> 的生命周期钩子函数会在合适的时机被调用。这意味着它在组件渲染后执行。</li></ul><p>因为定义的ref在script中还未访问到DOM元素，就自然还为空，为空的话后续函数就没办法执行咯。</p></li></ul><h1 id="MITT-gt-onAPI使用问题"><a href="#MITT-gt-onAPI使用问题" class="headerlink" title="MITT -&gt; onAPI使用问题"></a>MITT -&gt; onAPI使用问题</h1><ul><li><p>背景：</p><p>在兄弟组件中调用全局事件总线MITT的时候，emit和on都是可以使用的，但是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> test = <span class="hljs-title function_">ref</span>()<br>event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<span class="hljs-comment">//可以得到值</span><br>    test.<span class="hljs-property">value</span> = val;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">value</span>);<span class="hljs-comment">//可以得到值</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">value</span>);<span class="hljs-comment">//不可以得到值</span><br></code></pre></td></tr></table></figure><p>这就很抽象了，那我调用on的意义不久完全失去了嘛。</p><p>经过尝试ref -&gt; reactive、生命周期等等都没用。</p><p>讨论了一下能看出是渲染顺序问题或者深拷贝问题，但是就是不知道怎么解决。</p></li><li><p>解决方法一：</p><p>最原始的方法就是存到localstorage里面🤣。</p></li><li><p>解决方法二：</p><p>换用pinia Vue状态管理库。</p></li><li><p>解决方法三：</p><p>先用emit传到父组件中，然后再用defineprops传到目的组件中。</p></li></ul><h1 id="HTML-amp-CSS-gt-fixed状态盒子消失"><a href="#HTML-amp-CSS-gt-fixed状态盒子消失" class="headerlink" title="HTML&amp;CSS -&gt; fixed状态盒子消失"></a>HTML&amp;CSS -&gt; fixed状态盒子消失</h1><ul><li><p>背景：</p><p>Header盒子加了一个fixed样式，但是不见了。</p></li><li><p>解决方法：</p><p>加一下z-index。</p></li></ul><h1 id="Pack-gt-打包的时候index-html无法打开"><a href="#Pack-gt-打包的时候index-html无法打开" class="headerlink" title="Pack -&gt; 打包的时候index.html无法打开"></a>Pack -&gt; 打包的时候index.html无法打开</h1><ul><li><p>背景：</p><p>需要把写好的文件给队友调试，但是发现index.html无法打开。</p></li><li><p>解决方法：</p><p>在vite.config.js下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//添加如下代码</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">base</span>:<span class="hljs-string">&#x27;./&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后index.html不要直接打开，会有跨域问题，使用vscode 的<code>Live Server</code>插件打开。</p></li></ul>]]></content>
    
    
    <summary type="html">这里是一些我遇到的问题集合</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="😶‍🌫️" scheme="http://example.com/tags/%F0%9F%98%B6%E2%80%8D%F0%9F%8C%AB%EF%B8%8F/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://example.com/2024/01/30/TypeScript/"/>
    <id>http://example.com/2024/01/30/TypeScript/</id>
    <published>2024-01-30T04:17:40.000Z</published>
    <updated>2024-03-09T07:01:30.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>前言：很久之前就想着学Typescript了，但是一直在嘴上说没有时间学，说是没有但实际上学习这个也不会花费太久时间，只要肯挤时间并强制去完成就肯定可以完成。</p><p><a href="https://typescript.bootcss.com/">TypeScript 中文手册 </a></p><p>TS其实就是JS Plus，笔记中只写我觉得和JS不一样的很多的地方详细需要自己参考文档。</p><h1 id="TypeScript相比JS的优势"><a href="#TypeScript相比JS的优势" class="headerlink" title="TypeScript相比JS的优势"></a>TypeScript相比JS的优势</h1><ul><li>更早(写代码的同时)发现错误，减少找Bug、改Bug时间，提升开发效率。</li><li>程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。</li><li>强大的类型系统提升了代码的可维护性，使得重构代码更加容易。</li><li>支持最新的ECMAScript语法，优先体验最新的语法，让你走在前端技术的最前沿。</li><li>TS类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。除此之外，Vue 3源码使用TS重写、Angular默认支持TS、React与TS完美配合，TypeScript已成为大中型前端项目的首先编程语言。</li></ul><h1 id="安装TypeScript"><a href="#安装TypeScript" class="headerlink" title="安装TypeScript"></a>安装TypeScript</h1><p>有两种主要的方式来获取TypeScript工具：</p><ul><li>通过npm（Node.js包管理器）</li><li>安装Visual Studio的TypeScript插件</li></ul><p>Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以<a href="https://typescript.bootcss.com/index.html#download-links">下载</a>它。</p><p>针对使用npm的用户：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g typescript<br></code></pre></td></tr></table></figure><h1 id="TS中的高级功能"><a href="#TS中的高级功能" class="headerlink" title="TS中的高级功能"></a>TS中的高级功能</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望<code>greeter</code>函数接收一个字符串参数。 然后尝试把<code>greeter</code>的调用改成传入一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><p>重新编译，你会看到产生了一个错误。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;.<br></code></pre></td></tr></table></figure><p>类似地，尝试删除<code>greeter</code>调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p><p><strong>要注意的是尽管有错误，<code>greeter.js</code>文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>让我们开发这个示例应用。这里我们使用接口来描述一个拥有<code>firstName</code>和<code>lastName</code>字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用<code>implements</code>语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person: Person</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + person.<span class="hljs-property">lastName</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;User&quot;</span> &#125;;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><p>因为我对type对象不是很了解（看完这些文章之后感觉到tasklist有些语句需要规范化了orz），这里也补充一下type&amp;interface的知识：</p><p>类型别名 type 和 接口 interface 区别与联系</p><ul><li><p>不同点：</p><ul><li><p>类型别名type用来给一个类型起个新名字，接口interface是命名数据结构（例如对象）的另一种方式</p></li><li><p>type可以用来表示基本类型、对象类型、联合类型、元组和交集；interface仅限于描述对象类型</p></li><li><p>interface 定义重名了会合并属性，type 会报错</p></li><li><p>interface 可以 extends， type 是不允许 extends ，但是 type 缺可以通过交叉类型 实现 interface 的 extend 行为，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 与 interface 类型 交叉</p></li></ul></li><li><p>相同点：</p><ul><li><p>都可以描述 Object和Function</p></li><li><p>interface 和 type 都可以继承。</p></li></ul></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。</p><p>让我们创建一个<code>Student</code>类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。</p><p>还要注意的是，在构造函数的参数上使用<code>public</code>等同于创建了同名的成员变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-attr">fullName</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> firstName: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> middleInitial: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> lastName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = firstName + <span class="hljs-string">&quot; &quot;</span> + middleInitial + <span class="hljs-string">&quot; &quot;</span> + lastName;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person : Person</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + person.<span class="hljs-property">lastName</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-string">&quot;M.&quot;</span>, <span class="hljs-string">&quot;User&quot;</span>);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br></code></pre></td></tr></table></figure><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br></code></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span> = <span class="hljs-number">2</span>, <span class="hljs-title class_">Blue</span> = <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br></code></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">colorName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">2</span>];<br><br><span class="hljs-title function_">alert</span>(colorName);  <span class="hljs-comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span><br></code></pre></td></tr></table></figure><h2 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;free&quot;</span>];<br></code></pre></td></tr></table></figure><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。</p><p>下面是一些返回<code>never</code>类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>另一个为<code>as</code>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有<code>as</code>语法断言是被允许的。</p><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。 像我们之前提到过的，<code>let</code>在很多方面与<code>var</code>是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 <code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p><p>因为TypeScript是JavaScript的超集，所以它本身就支持<code>let</code>和<code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替<code>var</code>。</p><h2 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h2><p>对于熟悉其它语言的人来说，<code>var</code>声明有些奇怪的作用域规则。 看下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">shouldInitialize: <span class="hljs-built_in">boolean</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (shouldInitialize) &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-title function_">f</span>(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// returns &#x27;10&#x27;</span><br><span class="hljs-title function_">f</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// returns &#x27;undefined&#x27;</span><br></code></pre></td></tr></table></figure><p>有些读者可能要多看几遍这个例子。 变量<code>x</code>是定义在*<code>if</code>语句里面<em>，但是我们却可以在语句的外面访问它。 这是因为<code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为</em><code>var</code>作用域<em>或</em>函数作用域*。 函数参数也使用函数作用域。</p><h2 id="变量获取怪异之处"><a href="#变量获取怪异之处" class="headerlink" title="变量获取怪异之处"></a>变量获取怪异之处</h2><p>快速的猜一下下面的代码会返回什么：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); &#125;, <span class="hljs-number">100</span> * i);<br>&#125;<br></code></pre></td></tr></table></figure><p>介绍一下，<code>setTimeout</code>会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p><p>好吧，看一下结果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>还记得我们上面讲的变量获取吗？</p><blockquote><p>每当<code>g</code>被调用时，它都可以访问到<code>f</code>里的<code>a</code>变量。</p></blockquote><p>让我们花点时间考虑在这个上下文里的情况。 <code>setTimeout</code>在若干毫秒后执行一个函数，并且是在<code>for</code>循环结束后。 <code>for</code>循环结束后，<code>i</code>的值为<code>10</code>。 所以当函数被调用的时候，它会打印出<code>10</code>！</p><p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时<code>i</code>的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-comment">// capture the current state of &#x27;i&#x27;</span><br>    <span class="hljs-comment">// by invoking a function with its current value</span><br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); &#125;, <span class="hljs-number">100</span> * i);<br>    &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种奇怪的形式我们已经司空见惯了。 参数<code>i</code>会覆盖<code>for</code>循环里的<code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改<code>for</code>循环体里的代码。</p><h2 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>当用<code>let</code>声明一个变量，它使用的是<em>词法作用域</em>或<em>块作用域</em>。 不同于使用<code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或<code>for</code>循环之外是不能访问的。</p><h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h3><p>我们提过使用<code>var</code>声明时，它不在乎你声明多少次；你只会得到1个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">var</span> x;<br>    <span class="hljs-keyword">var</span> x;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子里，所有<code>x</code>的声明实际上都引用一个<em>相同</em>的<code>x</code>，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是，<code>let</code>声明就不会这么宽松了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> x = <span class="hljs-number">20</span>; <span class="hljs-comment">// 错误，不能在1个作用域里多次声明`x`</span><br></code></pre></td></tr></table></figure><p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: interferes with parameter declaration</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">condition, x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-title function_">f</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// returns 0</span><br><span class="hljs-title function_">f</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// returns 100</span><br></code></pre></td></tr></table></figure><p>在一个嵌套作用域里引入一个新名字的行为称做<em>屏蔽</em>。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用<code>let</code>重写之前的<code>sumMatrix</code>函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumMatrix</span>(<span class="hljs-params">matrix: <span class="hljs-built_in">number</span>[][]</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">var</span> currentRow = matrix[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; currentRow.<span class="hljs-property">length</span>; i++) &#123;<br>            sum += currentRow[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本的循环能得到正确的结果，因为内层循环的<code>i</code>可以屏蔽掉外层循环的<code>i</code>。</p><p><em>通常</em>来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p><h2 id="let和const用哪个"><a href="#let和const用哪个" class="headerlink" title="let和const用哪个"></a><code>let</code>和<code>const</code>用哪个</h2><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p><p>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小特权原则</a>，所有变量除了你计划去修改的都应该使用<code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用<code>const</code>也可以让我们更容易的推测数据的流动。</p><p>另一方面，用户很喜欢<code>let</code>的简洁性。 这个手册大部分地方都使用了<code>let</code>。</p><h2 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h2><p>最简单的解构莫过于数组的解构赋值了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> input = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> [first, second] = input;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// outputs 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second); <span class="hljs-comment">// outputs 2</span><br></code></pre></td></tr></table></figure><p>这创建了2个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript">first = input[<span class="hljs-number">0</span>];<br>second = input[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>解构作用于已声明的变量会更好：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// swap variables</span><br>[first, second] = [second, first];<br></code></pre></td></tr></table></figure><p>作用于函数参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">[first, second]: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second);<br>&#125;<br><span class="hljs-title function_">f</span>(input);<br></code></pre></td></tr></table></figure><p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// outputs 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest); <span class="hljs-comment">// outputs [ 2, 3, 4 ]</span><br></code></pre></td></tr></table></figure><p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> [first] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// outputs 1</span><br></code></pre></td></tr></table></figure><p>或其它元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> [, second, , fourth] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>你也可以解构对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;bar&quot;</span><br>&#125;;<br><span class="hljs-keyword">let</span> &#123; a, b &#125; = o;<br></code></pre></td></tr></table></figure><p>这通过 <code>o.a</code> and <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p><p>就像数组解构，你可以用没有声明的赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">(&#123; a, b &#125; = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;baz&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">101</span> &#125;);<br></code></pre></td></tr></table></figure><p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>&#123;</code> 起始的语句解析为一个块。</p><p>你可以在对象里使用<code>...</code>语法创建剩余变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> &#123; a, ...passthrough &#125; = o;<br><span class="hljs-keyword">let</span> total = passthrough.<span class="hljs-property">b</span> + passthrough.<span class="hljs-property">c</span>.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h2 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h2><p>你也可以给属性以不同的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">a</span>: newName1, <span class="hljs-attr">b</span>: newName2 &#125; = o;<br></code></pre></td></tr></table></figure><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 “<code>a</code> 作为 <code>newName1</code>“。 方向是从左到右，好像你写成了以下样子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> newName1 = o.<span class="hljs-property">a</span>;<br><span class="hljs-keyword">let</span> newName2 = o.<span class="hljs-property">b</span>;<br></code></pre></td></tr></table></figure><p>令人困惑的是，这里的冒号<em>不是</em>指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> &#123;a, b&#125;: &#123;<span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>&#125; = o;<br></code></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>默认值可以让你在属性为 undefined 时使用缺省值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">keepWholeObject</span>(<span class="hljs-params">wholeObject: &#123; a: <span class="hljs-built_in">string</span>, b?: <span class="hljs-built_in">number</span> &#125;</span>) &#123;<br>    <span class="hljs-keyword">let</span> &#123; a, b = <span class="hljs-number">1001</span> &#125; = wholeObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>解构也能用于函数声明。 看以下简单的情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> C = &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, b?: <span class="hljs-built_in">number</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">&#123; a, b &#125;: C</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">&#123; a, b &#125; = &#123; a: <span class="hljs-string">&quot;&quot;</span>, b: <span class="hljs-number">0</span> &#125;</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// ok, default to &#123; a: &quot;&quot;, b: 0 &#125;</span><br></code></pre></td></tr></table></figure><p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">&#123; a, b = <span class="hljs-number">0</span> &#125; = &#123; a: <span class="hljs-string">&quot;&quot;</span> &#125;</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-title function_">f</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;yes&quot;</span> &#125;); <span class="hljs-comment">// ok, default b = 0</span><br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span><br><span class="hljs-title function_">f</span>(&#123;&#125;); <span class="hljs-comment">// error, &#x27;a&#x27; is required if you supply an argument</span><br></code></pre></td></tr></table></figure><p><strong>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</strong></p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> first = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> second = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> bothPlus = [<span class="hljs-number">0</span>, ...first, ...second, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>这会令<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了<code>first</code>和<code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p><p>你还可以展开对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> defaults = &#123; <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;spicy&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$$&quot;</span>, <span class="hljs-attr">ambiance</span>: <span class="hljs-string">&quot;noisy&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> search = &#123; ...defaults, <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;rich&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p><code>search</code>的值为<code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> defaults = &#123; <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;spicy&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$$&quot;</span>, <span class="hljs-attr">ambiance</span>: <span class="hljs-string">&quot;noisy&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> search = &#123; <span class="hljs-attr">food</span>: <span class="hljs-string">&quot;rich&quot;</span>, ...defaults &#125;;<br></code></pre></td></tr></table></figure><p>那么，<code>defaults</code>里的<code>food</code>属性会重写<code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。</p><p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>  p = <span class="hljs-number">12</span>;<br>  <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br><span class="hljs-keyword">let</span> clone = &#123; ...c &#125;;<br>clone.<span class="hljs-property">p</span>; <span class="hljs-comment">// ok</span><br>clone.<span class="hljs-title function_">m</span>(); <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Javascript进阶版👽</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Interview&amp;Knowledge about Web-Front</title>
    <link href="http://example.com/2023/12/06/Interview-Knowledge-about-Web-Front/"/>
    <id>http://example.com/2023/12/06/Interview-Knowledge-about-Web-Front/</id>
    <published>2023-12-06T04:28:54.000Z</published>
    <updated>2024-03-16T11:47:15.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端未来的展望✨"><a href="#前端未来的展望✨" class="headerlink" title="前端未来的展望✨"></a>前端未来的展望✨</h3><p>当前PC和Mobile端前端都开发得差不多了，渐渐趋于一个稳态的状态，我们不妨展望一下未来：</p><ul><li>ChatGPT在短期内很快就兴起了，最为容易看到的就是我去年这个时间节点还在自己手搓代码，但是这一届的学弟学妹已经开始使用GPT进行查找代码错误和提供代码思路了🤕。所以GPTwith前端、也可以推广到AIwith前端是一个大方向，但是前端这个东西似乎不是很适合机器学习，目前能做的好像我知道的就是用于代码优化（指机器学习作用于前端）。</li><li>脑机接口近年来也开始兴起，前端作为人机交互工程师，未来脑机接口热潮的时候一定是一个风口浪尖。</li><li>语音转文字前端也是一个点。</li></ul><h3 id="前端人应该拥有的素养❤️"><a href="#前端人应该拥有的素养❤️" class="headerlink" title="前端人应该拥有的素养❤️"></a>前端人应该拥有的素养❤️</h3><ul><li>Blog要经常记录，我打算寒假就让学弟学妹们去制作一个自己的blog，可以使用vercel、4everland自己部署，也可以hexo+github部署……自己决定。Blog内容还是尽量自己手敲（这点我自己也没有做到，自己手敲上去的东西更加属于自己，虽然复制粘贴文档的显得工作量更多🥺）</li><li>积极思考，常常思考自己的代码有没有改进的地方，这个是从韦华贤学长那里学到的，事件点是在我的tasklist有一个函数一眼就需要封装一下，自己很蠢的没看出来，和他沟通之后他说是一个习惯问题，我仔细思考过后觉得这个也是一个前端人应该拥有的素养😈</li><li>拥有好奇心和自趣力——前端-WEB-或者说整个计算机行业都是快速迭代的，需要你跳出工作&amp;其他需求式编程去自己学习自己钻研，这个过程是相当有趣的。</li><li>责任心这个东西就算跳开前端工程师这个tag也是很重要的东西，它是可以伴随你一生的良好品质，不管是平日的生活遇到的东西还是以后自己项目中会遇到的一些事情，你都需要一个很重的责任心去维护一些东西。</li><li>增加学习深度，扩宽学习广度：这个是一个很有意思的问题，在我多方向调研和请教很多人过后，我得到一个结论：在国内大环境，广度重要性远大于深度重要性（至少对于前端且考虑范围取最大）。这过程中我请教了厚华学长、阿韦学长、环节、工具箱学长，各有说辞：<ul><li>厚华学长在准备实习，有很多自己整理出来的面经，他得到的结论是，我需要去弄懂很多之前已经学过会用的，但是基层逻辑不懂的东西，确实是这样，他share过来的很多面试题目我基本看了只能答出表层的东西，再问深一点就没办法说出它的底层逻辑了，但是我认为这个是一个很基本的深度（本来就需要去掌握的东西）以至于他不能算是深度。</li><li>第二个就是阿韦，在深度广度这一块的话给的建议是先学透一个，这样基本原理弄清楚之后其他也会好搞很多。</li><li>工具箱学长也是说建议有自己能拿出手的东西，深度。</li><li>但是面向实际开发中，不管是大厂小厂，都需要你有一个很广的技术栈，会了web需要app，甚至后端、操作系统、ui都需要。</li></ul></li></ul><h3 id="漫谈🎇"><a href="#漫谈🎇" class="headerlink" title="漫谈🎇"></a>漫谈🎇</h3><ul><li>面试相关问题：<ul><li>对于前端工程师面试中更加需要注意的是编程范式的问题，作为一个刚刚毕业或者还没有毕业的小东西，当你没有一个非常专业or深度的知识的话，面试官更加有可能考你的是很基础的编程——数据结构等。</li><li>对于后端工程师，需要通透的是数据库有关知识，这里我不是很了解，不多胡诌了。</li><li>如果拥有自己的项目的话，面试官会问项目相关架构。</li><li>更加重要的是，你需要面试的时候自己编写代码，这就需要你拥有相关的能力。</li></ul></li><li>面试八股文这一块，我有一个观点，我觉得这个属于一个戏称，其实面试中提到的问题我个人认为还是很有用的，通透原理才能使用。所以我觉得多收集多解决这些问题还是很有趣的，有时候还能遇到一些自己不会的问题。</li><li>当你通过面试进入公司之后技术就不会是最难的东西了，更加难的是团队的协作等。这是一个很有趣的我从一些前端大牛身上拿到的观点。</li><li>多投简历、脸皮要厚，什么想投的都去尝试，过后成或不成都可以促进你的学习——在面试中没有解决的问题可以自己花时间去解决。</li><li>多参与开源项目，可能一开始在开源项目中能做的很少，但是这是一个渐进的过程，后面就可以做的多起来了。</li></ul>]]></content>
    
    
    <summary type="html">写一些目前的想法。</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="😶‍🌫️" scheme="http://example.com/tags/%F0%9F%98%B6%E2%80%8D%F0%9F%8C%AB%EF%B8%8F/"/>
    
  </entry>
  
  <entry>
    <title>MITT</title>
    <link href="http://example.com/2023/11/13/MITT/"/>
    <id>http://example.com/2023/11/13/MITT/</id>
    <published>2023-11-13T06:58:08.000Z</published>
    <updated>2024-03-20T08:49:31.843Z</updated>
    
    <content type="html"><![CDATA[<p>在Vue3中为了优化代码会使用全局事件总线bus去在不同组件之间传值。</p><p>首先先安装一下mitt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mitt<br></code></pre></td></tr></table></figure><p>添加一个bus.js的文件里面放这些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mitt&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> events = <span class="hljs-title function_">mitt</span>()<br></code></pre></td></tr></table></figure><p>在需要使用bus的组件里引入依赖</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; events &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;.../.../bus.js&#x27;</span><br></code></pre></td></tr></table></figure><p>使用方法主要是三种：</p><ul><li><p>emit：想要传出值或函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;functionName&#x27;</span>, postValue)<br><span class="hljs-comment">//其中functionName是你绑定的一个函数名，相当于一个标识，可以在不同组件中靠这个来判定来源和目的地，postValue是你要传的值。</span><br></code></pre></td></tr></table></figure></li><li><p>on：想要接受传入值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">events.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;functionName&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123; ... &#125;)<br><span class="hljs-comment">//其中functionName是你绑定的一个函数名，相当于一个标识，可以在不同组件中靠这个来判定来源和目的地，val是你上面传出来的postValue，要干什么自己写在...里。</span><br></code></pre></td></tr></table></figure><p>兄弟组件之间使用on会有一个小问题，详见<a href="https://taskmanagerol.github.io/2024/01/30/Problem/">Problem</a> </p></li><li><p>off：想要解绑事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//某些情况可能要解绑</span><br>events.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;functionName&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">一个全局传参的JavaScript库</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue.Config</title>
    <link href="http://example.com/2023/11/13/Vue.Config/"/>
    <id>http://example.com/2023/11/13/Vue.Config/</id>
    <published>2023-11-13T06:57:44.000Z</published>
    <updated>2024-04-24T11:22:43.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vite框架项目创建"><a href="#Vite框架项目创建" class="headerlink" title="Vite框架项目创建"></a>Vite框架项目创建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest<br>npm install<br>npm run dev<br>//(别忘记在package.json中<span class="hljs-string">&quot;scripts&quot;</span>对象中<span class="hljs-string">&quot;dev&quot;</span>后面把<span class="hljs-string">&quot;vite&quot;</span>改成<span class="hljs-string">&quot;vite --open&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Vue-Router路由安装"><a href="#Vue-Router路由安装" class="headerlink" title="Vue Router路由安装"></a>Vue Router路由安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vue-router@4<br>//安装后别忘记在src下新建一个router子文件夹和index.js、routes.js子文件<br></code></pre></td></tr></table></figure><h3 id="index-js（直接复制粘贴即可）"><a href="#index-js（直接复制粘贴即可）" class="headerlink" title="index.js（直接复制粘贴即可）"></a>index.js（直接复制粘贴即可）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入router所需的方法</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-comment">// 导入路由页面的配置</span><br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes.js&#x27;</span><br><br><span class="hljs-comment">// 路由参数配置</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-comment">// 使用hash(createWebHashHistory)模式，(createWebHistory是HTML5历史模式，支持SEO)</span><br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>    <span class="hljs-attr">routes</span>: routes,<br>&#125;)<br><br><span class="hljs-comment">// 全局前置守卫，这里可以加入用户登录判断</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 继续前进 next()</span><br>    <span class="hljs-comment">// 返回 false 以取消导航</span><br>    <span class="hljs-title function_">next</span>()<br>&#125;)<br><br><span class="hljs-comment">// 全局后置钩子，这里可以加入改变页面标题等操作</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// const _title = to.meta.title</span><br>    <span class="hljs-comment">// if (_title) &#123;</span><br>    <span class="hljs-comment">//     window.document.title = _title</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;)<br><br><span class="hljs-comment">// 导出默认值</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><h3 id="routes-js（直接复制粘贴即可）"><a href="#routes-js（直接复制粘贴即可）" class="headerlink" title="routes.js（直接复制粘贴即可）"></a>routes.js（直接复制粘贴即可）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;HOME&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> routes<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//最后就是别忘记在main.js里添加引入依赖</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index.js&#x27;</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<span class="hljs-comment">//.use(router)</span><br></code></pre></td></tr></table></figure><h2 id="APP-vue初始化"><a href="#APP-vue初始化" class="headerlink" title="APP.vue初始化"></a>APP.vue初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;router-view&gt;&lt;/router-view&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="style-css初始化"><a href="#style-css初始化" class="headerlink" title="style.css初始化"></a>style.css初始化</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 部分标签修改 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  place-items: center;<br>&#125;<br><br><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1280px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">每次新建项目都得配置不少东西，在这里标记一下防止遗忘。</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="😶‍🌫️" scheme="http://example.com/tags/%F0%9F%98%B6%E2%80%8D%F0%9F%8C%AB%EF%B8%8F/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="http://example.com/2023/07/21/Canvas/"/>
    <id>http://example.com/2023/07/21/Canvas/</id>
    <published>2023-07-21T07:53:10.000Z</published>
    <updated>2024-03-25T08:37:38.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas画布使用——CSS进阶"><a href="#canvas画布使用——CSS进阶" class="headerlink" title="canvas画布使用——CSS进阶"></a>canvas画布使用——CSS进阶</h1><p>​在大一的时候学的一些高数、线性代数都可以用于canvas画布，所以还是很重要的，能好好学就好好学。</p><p>​文章参考：<a href="https://www.jianshu.com/p/e3ebe08dddad">在canvas上绘制3d图形 - 简书 (jianshu.com)</a>(写得真的很好，少见的好文章)</p><h3 id="简单绘制三维图形"><a href="#简单绘制三维图形" class="headerlink" title="简单绘制三维图形"></a>简单绘制三维图形</h3><p>​因为canvas是一个二维的东西，所以我们想要画出三维的图形就要考虑把这个三维图形给投影到二维上，进而给造成一种三维的错觉。所以首先需要学习的是如何表示三维坐标轴上的任意一个点。通过文章中的推导我们可以看到：</p><p>​从空间内的任意点A(xA，yA，zA)观察空间内的任一点G(xG，yG，zG)，它在xy平面内的投影H的坐标为：</p><p>​ $x &#x3D; ((xG-xA)*zA)&#x2F;(zA-zG) ;  y &#x3D; ((yG-yA)*zA)&#x2F;(zA-zG)$</p><h3 id="三维图形-的旋转"><a href="#三维图形-的旋转" class="headerlink" title="三维图形 的旋转"></a>三维图形 的旋转</h3><p>​对于一个图形，如果要对其进行y轴的旋转（从观察点更为明显且符合逻辑），则从y轴向下俯视xz平面可以使用一个极坐标的逻辑从而确定我们变换之后的坐标点。<br>​主要就是确定每个点（控制旋转的是角度）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDk2NTEyMi1kMmM1NWUzNTFhMmQ0Zjc1LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93LzMxMS9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt="img"></p><p>​这个时候假定D点与x轴的夹角是α，圆的半径为R，将D点绕着y轴旋转β旋转至D’点，这个时候D’与x轴夹角为α+β，此时D’的x坐标为cos(α+β)*R，D’的z坐标为sin(α+β)*R</p><p>​D’的x坐标:</p><p>​$cos(α+β)<em>R&#x3D;R</em>cosα<em>cosβ-R</em>sinα*sinβ$</p><p>D’的z坐标sin(α+β)<em>R&#x3D;R</em>sinα<em>cosβ+R</em>cosα<em>sinβ<br>而R</em>sinα就是旋转之前D点的z坐标，R<em>cosα就是旋转之前D点的x坐标，<br>D’的x坐标为x</em>cosβ-z<em>sinβ<br>D’的z坐标为z</em>cosβ+x<em>sinβ<br>将结论代入到我们的立方体的8个顶点ABCDEFGH中<br>对于任一点D(xD，yD，zD)，其绕y轴旋转β角的时候，它的三维坐标变为(xD</em>cosβ-zD<em>sinβ，yD，zD</em>cosβ+xD*sinβ)</p><h3 id="正弦曲线阵（含代码）"><a href="#正弦曲线阵（含代码）" class="headerlink" title="正弦曲线阵（含代码）"></a>正弦曲线阵（含代码）</h3><p>​博客中写的是vue2的，我自己用的是vue3，所以以下是我已经写好的正弦曲线阵代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;wave&quot;</span> <span class="hljs-attr">:width</span>=<span class="hljs-string">&quot;canvasWidth&quot;</span> <span class="hljs-attr">:height</span>=<span class="hljs-string">&quot;canvasHeight&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//绘制正弦波浪canvas</span><br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>; <br><span class="hljs-keyword">const</span> wave = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">const</span> canvasWidth = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1920</span>)<br><span class="hljs-keyword">const</span> canvasHeight = <span class="hljs-title function_">ref</span>(<span class="hljs-number">800</span>)<br><span class="hljs-comment">//构建一个结构体 方便后期绘制多条正弦曲线</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (a, b, c, d, z, start, end, gap) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = b<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = c<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">d</span> = d  <span class="hljs-comment">//以上四个控制正弦函数振幅周期之类的</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span> = z  <span class="hljs-comment">//三维坐标</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = start <span class="hljs-comment">//绘画开始点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = end  <span class="hljs-comment">//绘画结束点</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gap</span> = gap <span class="hljs-comment">//间距</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span> = []<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">computePointList</span>()<br>    &#125;<br>    computePointList () &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span> = []<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span>; i = i + <span class="hljs-variable language_">this</span>.<span class="hljs-property">gap</span>) &#123;<br>            <span class="hljs-keyword">let</span> x = i<br>            <span class="hljs-keyword">let</span> y = <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>((<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> * x + <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span>) / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-property">d</span>   <span class="hljs-comment">// 即y = A sin(ωx + φ) + B</span><br>            <span class="hljs-keyword">let</span> offset = i <span class="hljs-comment">//偏移量用来让他运动</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">push</span>(&#123;<br>                x,<br>                y,<br>                <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span>,<br>                <span class="hljs-attr">originX</span>: x,<br>                offset<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> lineList = [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">390</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">360</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">330</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">300</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">270</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">240</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">210</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">180</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">150</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">120</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">90</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">60</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">30</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">90</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">120</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">150</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">210</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">240</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">270</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, -<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>),<br>    <br>]<span class="hljs-comment">//整个类的列表出来</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">draw</span> = (<span class="hljs-params">visual</span>) =&gt; &#123; <span class="hljs-comment">//这是个绘制正弦点的函数</span><br>    <span class="hljs-keyword">const</span> context = wave.<span class="hljs-property">value</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>    context.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvasWidth.<span class="hljs-property">value</span>, canvasHeight.<span class="hljs-property">value</span>) <span class="hljs-comment">//清空像素</span><br>    lineList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> &#123;<br>        line.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> pointSize = <span class="hljs-number">1.5</span> * visual.<span class="hljs-property">z</span> / (visual.<span class="hljs-property">z</span> - item.<span class="hljs-property">z</span>) <span class="hljs-comment">//整个近大远小</span><br>            context.<span class="hljs-title function_">beginPath</span>()<br>            context.<span class="hljs-title function_">arc</span>(item.<span class="hljs-property">canvasX</span>  + canvasWidth.<span class="hljs-property">value</span> / <span class="hljs-number">2</span>, item.<span class="hljs-property">canvasY</span>  + canvasHeight.<span class="hljs-property">value</span> / <span class="hljs-number">2</span>, pointSize, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) <span class="hljs-comment">//arc(x, y, radius, startAngle, endAngle, counterclockwise);</span><br>            context.<span class="hljs-title function_">closePath</span>()<br>            context.<span class="hljs-title function_">fill</span>()<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">updatePointList</span> = (<span class="hljs-params">rotationAngleSpeed, visual</span>) =&gt; &#123; <span class="hljs-comment">//这是个更新点的位置而使正弦函数移动的函数</span><br>    lineList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> &#123;<br>        line.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> x = item.<span class="hljs-property">x</span><br>            <span class="hljs-keyword">let</span> z = item.<span class="hljs-property">z</span><br>            item.<span class="hljs-property">x</span> = x * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rotationAngleSpeed / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) - z * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rotationAngleSpeed / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) <br>            item.<span class="hljs-property">z</span> = z * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rotationAngleSpeed / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) + x * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rotationAngleSpeed / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) <br>            item.<span class="hljs-property">y</span> = line.<span class="hljs-property">a</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>((line.<span class="hljs-property">b</span> * item.<span class="hljs-property">originX</span> + line.<span class="hljs-property">c</span> + item.<span class="hljs-property">offset</span>) / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) + line.<span class="hljs-property">d</span> <span class="hljs-comment">//绕y轴旋转所以y比较特别</span><br>            item.<span class="hljs-property">canvasX</span> = (item.<span class="hljs-property">x</span> - visual.<span class="hljs-property">x</span>) * visual.<span class="hljs-property">z</span> / (visual.<span class="hljs-property">z</span> - z)<br>            item.<span class="hljs-property">canvasY</span> = (item.<span class="hljs-property">y</span> - visual.<span class="hljs-property">y</span>) * visual.<span class="hljs-property">z</span> / (visual.<span class="hljs-property">z</span> - z)<br>            &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">animationFrame</span> = (<span class="hljs-params">visual</span>) =&gt; &#123; <span class="hljs-comment">//正弦函数动画</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        lineList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">line,index</span>) =&gt;</span> &#123;<br>            line.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            line.<span class="hljs-property">c</span> = item.<span class="hljs-property">offset</span> + index * <span class="hljs-number">30</span> <span class="hljs-comment">//index控制偏移量更美观</span><br>            item.<span class="hljs-property">offset</span> = item.<span class="hljs-property">offset</span> + <span class="hljs-number">1</span><br>            &#125;)<br>            <span class="hljs-title function_">updatePointList</span>(<span class="hljs-number">.003</span>,visual)<br>        &#125;)<br>        <span class="hljs-title function_">draw</span>(visual)<br>        <span class="hljs-title function_">animationFrame</span>(visual)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//监听canvas标签创建、因为JS比标签创建更快，所以需要监听。</span><br><span class="hljs-title function_">watch</span>(wave, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> visual = &#123; <span class="hljs-comment">//观察点设置</span><br>        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">y</span>: -<span class="hljs-number">70</span>,<br>        <span class="hljs-attr">z</span>: <span class="hljs-number">500</span><br>    &#125;<br>    <span class="hljs-title function_">draw</span>(visual);<br>    <span class="hljs-title function_">animationFrame</span>(visual)<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Canvas画布学习，很多特殊效果都是用这个实现的。</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TailwindCSS</title>
    <link href="http://example.com/2023/06/29/TailwindCSS/"/>
    <id>http://example.com/2023/06/29/TailwindCSS/</id>
    <published>2023-06-29T02:31:19.000Z</published>
    <updated>2024-04-24T08:59:17.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tailwindcss介绍"><a href="#Tailwindcss介绍" class="headerlink" title="Tailwindcss介绍"></a>Tailwindcss介绍</h1><p>Tailwindcss是一种简单好用的css框架，我们在项目中经常遇见只需要赋一次样式的div。</p><p>要么在div上写class后再到css部分去修改样式，这样会相当麻烦（前端人想要6块屏幕呜呜呜），需要上下滑动或者分屏什么什么的。</p><p>要么就在div中使用style去进行修改，但是这样会有两个问题：一个是div中的style不可以配合vscode的插件进行一个自动补全，需要自己去记。另一个是很长很繁杂。</p><p>Tailwindcss就可以解决这样的问题，灵活、没有运行时的负担。</p><p>配置很简单，配置和学习使用半小时可以完成。</p><h1 id="Tailwindcss快速入门"><a href="#Tailwindcss快速入门" class="headerlink" title="Tailwindcss快速入门"></a>Tailwindcss快速入门</h1><p><a href="https://www.tailwindcss.cn/docs/installation/framework-guides">Framework Guides - TailwindCSS中文文档 | TailwindCSS中文网</a></p><p>此处点击选择进入相应的前端框架（我使用的Vite，然后呢进去有vue和react，一开始我没看见用的react配置，然后就没成。）</p><p>然后文档写得很详细了，缺点是他的中文文档似乎没有完全中文化，需要自己进行一个翻译。</p><p>大概使用就是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-3xl font-bold underline&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Vite快速配置"><a href="#Vite快速配置" class="headerlink" title="Vite快速配置"></a>Vite快速配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">//在工作区安装tailwindcss<br>npm install -D tailwindcss postcss autoprefixer<br>npx tailwindcss init -p<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//新创建的tailwind.config.js下复制如下代码</span><br><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">content</span>: [<br>    <span class="hljs-string">&quot;./index.html&quot;</span>,<br>    <span class="hljs-string">&quot;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&quot;</span>,<br>  ],<br>  <span class="hljs-attr">theme</span>: &#123;<br>    <span class="hljs-attr">extend</span>: &#123;&#125;,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [],<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">//在style<span class="hljs-selector-class">.css</span>中加入<br><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CSS框架，减少很多代码量，但是不便于维护。</summary>
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="速通" scheme="http://example.com/tags/%E9%80%9F%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://example.com/2023/06/24/Vue/"/>
    <id>http://example.com/2023/06/24/Vue/</id>
    <published>2023-06-24T10:02:16.000Z</published>
    <updated>2024-04-22T18:03:53.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>（本来记录这个没什么意义，但是很符合我，就记下来了）</p><p>实际的前端开发：</p><ul><li>模块化（js的模块化，css模块化，资源的模块化）</li><li>组件化（复用现有的UI结构、样式、行为）</li><li>规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><p>而不是一开始所以为的缺什么组件或API直接去拿</p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="vue简介"><a href="#vue简介" class="headerlink" title="vue简介"></a>vue简介</h3><p>Vue是一套用于构建用户界面的前端框架。</p><p>Vue框架的特性，主要体现在如下两个方面：</p><h5 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a>数据驱动视图</h5><p>在使用了vue的界面中，vue会监听数据的变化，从而自动重新渲染页面的结构。即当页面数据发生变化时，页面会自动重新渲染。</p><h5 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h5><p>在填写表单时，双向数据绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中。开发者不需要再手动操作来获取表单元素的最新值。</p><h3 id="Vue的基本使用"><a href="#Vue的基本使用" class="headerlink" title="Vue的基本使用"></a>Vue的基本使用</h3><ul><li>导入Vue.js的script脚本文件</li><li>在页面中声明一个将要被Vue控制的DOM区域</li><li>创建vm实例对象</li></ul><h3 id="Vue的指令和过滤器"><a href="#Vue的指令和过滤器" class="headerlink" title="Vue的指令和过滤器"></a>Vue的指令和过滤器</h3><p>&#x3D;&#x3D;过滤器只能在Vue2.x使用&#x3D;&#x3D;</p><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><p>指令时Vue为开发者提供的模板语法，用于辅助者渲染界面的基本结构</p><p>Vue中的指令按照不同的用途可以分为如下6大类：</p><ul><li><p>内容渲染指令</p><ul><li>v-text           覆盖原有的指令</li><li>双括号                插值</li><li>v-html           渲染含有标签的文本</li></ul></li><li><p>属性绑定指令</p><ul><li>如果需要为元素的属性动态绑定属性值，则需要用到v-bind属性绑定指令。可以简写成冒号：</li></ul></li><li><p>事件绑定指令</p><ul><li>v-on用于绑定事件，简写@，事件修饰符可以快速完成methods中定义的某些函数</li><li>常见的事件修饰符有：.stop阻止冒泡，.prevent阻止默认事件，.capture添加事件侦听器时使用事件捕获模式，.self只当事件在该元素本身触发时回调，.once事件只触发一次</li></ul></li><li><p>双向绑定指令</p><ul><li>v-model</li></ul></li><li><p>条件渲染指令</p><ul><li>v-if&#x2F;v-show</li></ul></li><li><p>列表渲染指令</p></li></ul><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>过滤器是vue为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式 和 v-bind 属性绑定</p><p>和 el data methods 同级，filters 为过滤器，本质上还是一个函数，过滤器中，必须要有一个返回值</p><p>芝士私有过滤器</p><p>全局过滤器可以让任何一个vue实例使用</p><p>怎么定义呢？</p><p>Vue.filter(‘过滤器名称’,(str)&#x3D;&gt;{<br>balabalabala<br>})</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>和 el data methods 同级，watch 为侦听器 可以随时观察数据变化 定义时用data中的数据定义 表示的是“如果改变就”</p><p>如果是data中的对象的对象 那定义时就是 单引号 对象.对象 单引号 这样</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性指的时通过一系列运算之后，最终得到一个属性值。</p><p>这个动态计算出来的属性值可以被模板结构或methods方法使用</p><p>和 el data methods 同级，computed 为计算属性</p><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>方法类似于Ajax 多了一个params用于传参 和data一样 data用不了就用params</p><p>这个的话 我有点不理解 好像用到了 es6 的语法 </p><p>我干脆抄一段现成的代码下来吧 以后对着改 </p><p>document.querySelector(“#btnPOST”).addEventListener(‘click’,&#x3D;&#x3D;async&#x3D;&#x3D; fucntion(){<br>const { data: res } &#x3D; &#x3D;&#x3D;await&#x3D;&#x3D; axios.post(“URL”,{ JSON })<br>console.log(res)<br>}) </p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>生命周期又名生命周期回调函数、生命周期函数、生命周期钩子</p></li><li><p>它是Vue在关键时刻帮我们调用的一些特殊名称的函数</p></li><li><p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</p></li><li><p>生命周期函数中的this指向是vm 或 组件实例对象</p><img src="https://v2.cn.vuejs.org/images/lifecycle.png"></li></ul><h5 id="挂载流程"><a href="#挂载流程" class="headerlink" title="挂载流程"></a>挂载流程</h5><p>new一个vue </p><p>然后初始化生命周期和事件</p><blockquote><p>beforeCreate: 但此时数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法</p></blockquote><p>然后初始化数据监测和数据代理</p><blockquote><p>created: 这个时候就可以通过vm访问到data中的数据、methods中的方法</p></blockquote><p>然后Vue开始解析你的模板 </p><blockquote><p>就是你.vue文件中的script，但此时页面还不能显示解析好的内容</p></blockquote><ul><li>会判断有无el，无就看$amount()</li><li>会判断有无template(和直接挂载不同 这个会直接把目标标签也给杀死)，无就不管</li></ul><blockquote><p>beforeMount: 此时页面显示的是未经Vue编译的DOM结构</p><p>此时所有对DOM的操作，最终都不奏效</p></blockquote><p>然后Vue 将内存中 虚拟的DOM转化为 真实的DOM 插入页面</p><blockquote><p>mounted: 此时页面中显示的是经过Vue编译的DOM</p><p>对DOM的操作均有效（尽可能避免）。至此初始化过程结束，一般在此开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作</p></blockquote><h5 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h5><blockquote><p>此时Vue处于Mounted 挂载中的状态 </p></blockquote><p>当页面数据更新</p><blockquote><p>beforeUpdata: 此时：数据是新的，但页面是旧的，即：页面尚未和数据保持同步。</p></blockquote><p>根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，即：完成了Model &#x3D;&gt; View的更新</p><blockquote><p>updated: 此时：数据是新的，页面也是新的，即：页面和数据保持同步</p></blockquote><h5 id="销毁流程"><a href="#销毁流程" class="headerlink" title="销毁流程"></a>销毁流程</h5><p>当遇见.$destory()时</p><blockquote><p>beforeDestory: 此时vm中的所有的：data、methods、指令等等，都处于可用状态，即将执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾工作。</p></blockquote><p>然后移出所有的侦听器、子组件、事件监听器</p><h3 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h3><p>单页面应用程序 简称 SPA，顾名思义，指的是一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能与交互都在这唯一的一个页面内完成。</p><h3 id="VUE组件"><a href="#VUE组件" class="headerlink" title="VUE组件"></a>VUE组件</h3><p>巧妙了解组件的优点：</p><p>传统方法编写应用</p><ul><li>依赖关系混乱、不好维护</li><li>代码复用率不高</li></ul><blockquote><p>比如你写的一些footer啊之类的 之前的操作就是新建一个页面就复制粘贴HTML 再对应的引用CSS文件和JS文件</p><p>这样就比较混乱 不好管理  而Vue就是为了解决这个的 它是提供一个框架 把做项目所需要用到的都给我们搭建出来</p></blockquote><h5 id="vue组件的三个组成部分"><a href="#vue组件的三个组成部分" class="headerlink" title="vue组件的三个组成部分"></a>vue组件的三个组成部分</h5><p>每个.vue组件都由 3 部分组成，分别是：</p><ul><li>template -&gt; 组件的模板结构</li><li>script -&gt; 组件的JavaScript</li><li>style -&gt; 组件的样式</li></ul><h5 id="组件的父子关系"><a href="#组件的父子关系" class="headerlink" title="组件的父子关系"></a>组件的父子关系</h5><ul><li>组件在被封装好之后，彼此之间是相互独立的，不存在父子关系。</li><li>在使用组件时，根据彼此的嵌套关系，形成了父子关系、兄弟关系。</li></ul><h5 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的三个步骤</h5><ul><li>使用 import 语法导入需要的组件</li><li>使用 components 节点注册<ul><li>通过 components 注册的是 私有子组件，即在 组件A 的 components 节点下，注册了 组件F 。则 组件F 只能用于 组件A 不能用于 组件C</li></ul></li><li>以 标签形式 使用刚才的注册的组件</li></ul><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><p>在vue项目的 main.js 入口文件中，通过 Vue.component()方法 </p><h5 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h5><p>props 是组件的自定义属性，在封装通用组件的时候，合理的使用 props 可以极大的提高组件的复用性</p><h3 id="VUE-CLI-脚手架"><a href="#VUE-CLI-脚手架" class="headerlink" title="VUE-CLI(脚手架)"></a>VUE-CLI(脚手架)</h3><p>cli &#x3D; command + line + interface.</p><p>vue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>vue cerate 项目的名称</p><h5 id="vue中src目录的构成"><a href="#vue中src目录的构成" class="headerlink" title="vue中src目录的构成"></a>vue中src目录的构成</h5><ul><li>assets 文件夹：存放项目用到的静态资源文件，例如css样式表、图片资源</li><li>components 文件夹：程序员封装的、可复用的组件</li><li>main.js 是项目的入口文件。整个项目的运行，要先执行main.js</li></ul><h5 id="vue项目的运行流程"><a href="#vue项目的运行流程" class="headerlink" title="vue项目的运行流程"></a>vue项目的运行流程</h5><p>在工程化的项目中，vue要做的事情非常单纯：通过main.js 把 App.vue 渲染到 index.html 的指定区域中</p><h5 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h5><p>在 import vue from ‘vue’ 时，我们会引用到不完整的、残缺的vue文件 （当然vue.js是完整的）</p><p>缺什么呢 缺的就是 模板解析器 （作用就是 把你的东西渲染到主页面上） 这时候就需要render函数来帮忙</p><h5 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h5><p>在 vue.config.js 里面是可以写对脚手架的默认修改的，具体可以阅读文档</p><h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><p>在 main.js 同目录下创建，本质是 对象 ，需要使用 install 安装</p><p>使用 Vue.use( 插件名 )</p><h3 id="组件化编码流程（通用）"><a href="#组件化编码流程（通用）" class="headerlink" title="组件化编码流程（通用）"></a>组件化编码流程（通用）</h3><h5 id="实现静态组件"><a href="#实现静态组件" class="headerlink" title="实现静态组件"></a>实现静态组件</h5><p>抽取组件，使用组件实现静态页面效果</p><h3 id="全局事件总线实现"><a href="#全局事件总线实现" class="headerlink" title="全局事件总线实现"></a>全局事件总线实现</h3><p>实现任意组件之间的通信</p><p>安装全局事件总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue"> new Vue(&#123;<br>beforeCreate()&#123;<br>Vue.prototype.$bus = this<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用全局事件总线</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$bus.$emit 传参<br>$bus.$on 接收<br></code></pre></td></tr></table></figure><blockquote><p>EventBus已经弃用，官方文档中推荐使用mitt</p></blockquote><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>vuex是专门在Vue中实现集中式状态管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理，也是一种组件间通信的方式，且适用于任意组件间通信</p><p>当多个组件依赖于同一状态，来自不同组件的行为需要变更同一状态时我们启用Vuex</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>一个路由就是一组映射关系</p><p>key 为路径，value 可能是 function 或 component </p><h5 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h5><ul><li><p>后端路由：</p><ul><li><p>value 是 function ，用于处理客户端提交的请求。</p></li><li><p>服务器接收到一个请求时</p></li></ul></li><li><p>前端路由：</p><ul><li>value 是 component，用于展示页面。</li><li>当浏览器的路径发生改变时，对应的组件就会显示。</li></ul></li></ul><h5 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h5><p>引用 vue-router 组件并新建一个router文件夹用于存放index.js 写路由器</p><p>创建并暴露一个路由器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default new Vue Router(&#123;<br>routes:[<br>&#123;<br>path:&#x27;/路径&#x27;,<br>component:组件<br>&#125;,<br>&#123;<br>//嵌套路由的话<br>path:&#x27;/路径&#x27;,<br>component:组件,<br>children:[<br>&#123;<br>path:&#x27;路径&#x27;,<br>component:组件<br>&#125;<br>]<br>&#125;<br>]<br>&#125;)<br></code></pre></td></tr></table></figure><p>并在点击切换的 a标签 处改为 router-link 并将 href 改为 to&#x3D;”&#x2F;路径” 这样的写法</p><h3 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h3><p>Vue3中一个新的配置项，值为一个函数。</p><p>setup 是所有Composition API（组合API）</p><p>组件中使用的 数据 方法 皆需要配置在 setup 中</p><p>setup若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。</p><p>setup尽量不要与Vue2.x配置混用</p><h3 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h3><p>传参的时候 如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> name = <span class="hljs-keyword">ref</span>(<span class="hljs-string">&#x27;张三&#x27;</span>)<br><span class="hljs-keyword">let</span> job = <span class="hljs-keyword">ref</span>(&#123;<br>type:<span class="hljs-string">&#x27;123&#x27;</span>,<br>epyt:<span class="hljs-string">&quot;321&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候就需要用到ref函数 </p><h3 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h3><p>定义一个对象类型的响应式数据（基本类型不用，用<code>ref</code>函数）</p><p>语法 <code>const 代理对象 = reactive(源对象)</code> 接收一个对象（或数组），返回一个代理对象（Proxy对象）</p><p>reactive定义的响应式数据是“深层次”的</p>]]></content>
    
    
    <summary type="html">经典前端框架之一</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>Postman</title>
    <link href="http://example.com/2023/06/24/Postman/"/>
    <id>http://example.com/2023/06/24/Postman/</id>
    <published>2023-06-24T10:02:02.000Z</published>
    <updated>2024-03-16T11:51:39.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h3><p>接口：就是软件提供给外部的一种服务。用作数据传输。 在硬件方面USB、投影机被称为接口，在软件方面统称API，如微信的支付和提现。（统称鉴权码，有token、key、appkey）</p><p>内部接口：开发人员自己开发的对自身系统提供的接口</p><p>外部接口：开发系统调用外部的，微信、支付宝，其它的接口</p><p>接口测试的本质：就是测试接口能否正常的交互数据，权限控制以及异常场景。</p><h3 id="软件为什么需要接口"><a href="#软件为什么需要接口" class="headerlink" title="软件为什么需要接口"></a>软件为什么需要接口</h3><p>因为接口能够让内部的数据被外部进行修改</p><h3 id="为什么要做接口测试"><a href="#为什么要做接口测试" class="headerlink" title="为什么要做接口测试"></a>为什么要做接口测试</h3><ul><li>现在很多系统都是前后端分离，开发的进度不一样，需要把一开始开发出来的接口进行测试</li><li>基于安全考虑，前端有验证很容易绕过，直接请求接口</li><li>测试推崇的是测试左移，即尽早测试。</li></ul><h3 id="接口测试的简介和分类"><a href="#接口测试的简介和分类" class="headerlink" title="接口测试的简介和分类"></a>接口测试的简介和分类</h3><p>接口测试就是测试系统组件接口之间的一种测试</p><p>分类：</p><ul><li>测试外部接口：测试被测系统和外部系统之间的接口（只需要测试正例即可）</li><li>测试内部接口：<ul><li>内部接口只提供给内部系统使用。（预算系统，承保系统）（只需要测试正例即可）</li><li>内部接口提供给外部系统使用（测试必须非常全面）</li></ul></li></ul><h3 id="接口测试的流程以及用例的设计"><a href="#接口测试的流程以及用例的设计" class="headerlink" title="接口测试的流程以及用例的设计"></a>接口测试的流程以及用例的设计</h3><ul><li>拿到接口api文档（通过抓包工具获取），熟悉接口业务，接口地址，鉴权方式，入参，码</li><li>编写接口用例以及评审</li><li>使用接口测试工具Postman实现接口测试</li><li>Postman-+Newman+Jenkins实现持续集成，并且输出测试报告并且发送邮件，并且输出测试报告并且发送邮件</li></ul><h3 id="接口返回数据和JSON详解"><a href="#接口返回数据和JSON详解" class="headerlink" title="接口返回数据和JSON详解"></a>接口返回数据和JSON详解</h3><ul><li>json格式：三组数据<ul><li>{error_code:0,msg:”0”,data:[]}</li><li>error_code:错误码</li><li>msg:对错误码的中文说明</li><li>data：真正的返回的数据</li></ul></li><li>jsonj就是一种数据类型，整形，小数，字符串</li><li>JSON由两组数据组成<ul><li>MAP对象，键值对</li><li>数组</li></ul></li></ul><h1 id="Postman界面介绍"><a href="#Postman界面介绍" class="headerlink" title="Postman界面介绍"></a>Postman界面介绍</h1><ul><li>Home主页</li><li>workspaces 工作空间<ul><li>Collections 项目集合</li><li>ApiS api文档</li><li>Environments 全局变量</li><li>Mock Server 虚拟服务器</li><li>Monitors 监听器</li><li>History 历史记录</li></ul></li></ul><h1 id="常见的请求头"><a href="#常见的请求头" class="headerlink" title="常见的请求头"></a>常见的请求头</h1><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>常用，它的作用是：客户端接收的数据格式；</p><p>比方说你的参数值填写的是application&#x2F;json，就说明浏览器所接收的数据是json类型的数据，当你加了Accept请求头之后，你会发现你得到的数据和你没有加Accept请求头的数据是完全不一样的。如果你没有加Accept这个请求头，你得到的数据可能就是一个简单的网页。Accept它可以影响你返回的数据。</p><h3 id="X-Requested-With"><a href="#X-Requested-With" class="headerlink" title="X-Requested-With"></a>X-Requested-With</h3><p>它的作用是：异步请求；</p><p>如果对开发有一定的了解的话，前端里面有这样一个技术Ajax异步请求。现在很多的功能都会用到这个异步请求，比如说登录。</p><p>简单的举个列子：如果现在你想去上海，只有一条路的话，你只能走唯一的一条路。那么如果有两条路或者多条路，可以坐飞机，高铁，汽车等等。那么它们就相当于异步，也就是说你可以通过飞机到上海，也可以坐高铁到上海，这样通俗的理解异步请求。</p><p>异步请求的特点：无刷新。就是说登录的时候是需要进行页面跳转的，而异步请求它不需要跳转也可以做到这样的请求。</p><h3 id="User-Aget"><a href="#User-Aget" class="headerlink" title="User-Aget"></a>User-Aget</h3><p>它的作用是：发送请求的客户端的类型；</p><p>比如说我们可以通过postman去发送请求类型，也可通过浏览器去发送请求等等，那么有的接口你通过非浏览器去请求它是无法通过的</p><h3 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h3><p>它的作用是：请求的报文格式；</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie信息；</p><p>有的接口需要登录之后才会生成Cookie信息，必须要保持登录的状态。这种情况我们就需要对Cookie信息进行管理。</p><h1 id="Postman执行接口测试"><a href="#Postman执行接口测试" class="headerlink" title="Postman执行接口测试"></a>Postman执行接口测试</h1><h3 id="请求页签"><a href="#请求页签" class="headerlink" title="请求页签"></a>请求页签</h3><ul><li>Params：get请求传参</li><li>authorization：鉴权</li><li>headers：请求头</li><li>Body：<ul><li>post  请求传参</li><li>none 没有参数</li><li>form-data：既可以传键值对参数也可以传文件</li><li>x-www-from-urlencoded：只能够传键值对参数</li><li>raw：json，text，xml，html，javascript</li><li>binary：把文件以二进制的方式传参</li></ul></li><li>pre-request-script：请求之前的脚本</li><li>tests：请求之后的断言</li><li>cookies：用于管理cookie信息</li></ul><h3 id="响应页签"><a href="#响应页签" class="headerlink" title="响应页签"></a>响应页签</h3><ul><li>Body：接口返回的数据<ul><li>Pretty：以Json、html、XML…不同格式查看返回的数据</li><li>Raw：以文本的方式查看返回的数据</li><li>PreView：以网页的方式查看返回的数据</li></ul></li><li>Cookies：响应的cookies信息</li><li>Headers：响应头</li><li>Test Results：断言的结果</li><li>200是状态码 Ok是状态信息 681MS是响应的时间  343B是响应的字节数</li></ul><h1 id="环境变量和全局变量"><a href="#环境变量和全局变量" class="headerlink" title="环境变量和全局变量"></a>环境变量和全局变量</h1><p>可以在Environments那里设置不同情况的环境</p><p>比如开发环境、测试环境、生成环境</p><p>并且使用来使用你的环境</p><p>比如：https:&#x2F;&#x2F;&#x2F;路径</p><p>然后再在右上角选择你需要的环境即可</p><p>环境变量：环境变量就是全局变量</p><p>全局变量：全局变量就是能够在任何接口里面访问的变量</p><h1 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h1><ul><li>json提取器实现接口关联<ul><li>在请求页签：Tests中使用var 变量名&#x3D;JSON.parse(responseBody)，json提取器将得到数据提取成json格式，这样可以设置一个全局变量，然后使用</li></ul></li><li>使用正则表达式提取器实现接口关联<ul><li>在请求页签：Tests中使用var 变量名&#x3D;responseBody.match(new RegExp(‘复制Raw并把Value改为(*?)’))，这样可以设置一个全局变量，然后使用（记得是变量名[1]）</li></ul></li></ul><h1 id="postman内置动态参数以及自定义的动态参数"><a href="#postman内置动态参数以及自定义的动态参数" class="headerlink" title="postman内置动态参数以及自定义的动态参数"></a>postman内置动态参数以及自定义的动态参数</h1><ul><li>          生成当前时间的时间戳</li><li>          生成0-1000之间的随机数</li><li>                   生成速记GUID字符串</li></ul>]]></content>
    
    
    <summary type="html">接口测试软件</summary>
    
    
    
    <category term="工具使用" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://example.com/2023/06/24/JavaScript/"/>
    <id>http://example.com/2023/06/24/JavaScript/</id>
    <published>2023-06-24T10:01:53.000Z</published>
    <updated>2024-04-28T03:30:15.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JS的作用"><a href="#JS的作用" class="headerlink" title="JS的作用"></a>JS的作用</h2><p>JS本身是一个脚本语言，主要作用于Web，由ECMAScript、DOM、BOM构成。</p><blockquote><p>可以拿来 表单动态校验、网页特效、服务端开发、桌面程序、APP、控制硬件、游戏开发等。</p></blockquote><h2 id="浏览器怎么执行JS"><a href="#浏览器怎么执行JS" class="headerlink" title="浏览器怎么执行JS"></a>浏览器怎么执行JS</h2><ul><li>渲染引擎：用于解析HTML和CSS，俗称内核</li><li>JS引擎：也称为JS解释器。用于读取网页中的JS代码，对其处理后运行。</li></ul><blockquote><p> 浏览器本身并不会执行JS代码，而是通过内置的JS引擎来执行JS代码，JS引擎执行代码时逐行解释每一句源码，然后由计算机去执行，所以JS语言归为脚本语言，会逐行解释执行。</p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>JS时一种弱类型或者说动态的语言，这意味着不用提前声明变量的类型，在程序运行的过程中，类型会被自动锁定。</p><h2 id="Null-类型-amp-Undefined-类型"><a href="#Null-类型-amp-Undefined-类型" class="headerlink" title="Null 类型 &amp; Undefined 类型"></a>Null 类型 &amp; Undefined 类型</h2><p>这俩都只有本身即 <code>null</code> &amp; <code>underfined</code> 。</p><blockquote><p>从概念上讲，<code>undefined</code> 表示<em>值</em>的缺失，<code>null</code> 表示<em>对象</em>的缺失，当某些东西没有值时，该语言通常默认为 <code>undefined</code>。</p></blockquote><h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p><code>Boolean</code> 类型表示一个逻辑实体并且包括两个值：<code>true</code> 和 <code>false</code>。</p><h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p><code>Number</code> 类型能存储±(2^-1074 ~2^1024)之间的浮点数，超过会自动转换为 ±Infinity.</p><blockquote><p>NaN是一种特殊的数值，当目前运算的结果不为数值的时候就会输出NaN</p></blockquote><h2 id="BigInt-类型"><a href="#BigInt-类型" class="headerlink" title="BigInt 类型"></a>BigInt 类型</h2><p><code>BigInt</code>类型在JS中是一个数字的原始值，它可以表示任意大小的整数。使用BigInt可以安全地存储和操作巨大的整数。</p><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>字符串一般可以用来表示任何数据结构。但这并不总是一个好主意。例如，使用一个分隔符，可以模拟一个列表（而 JavaScript 数组可能更适合）。</p><h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p><code>Symbol</code> 是<strong>唯一</strong>并且<strong>不可变</strong>的原始值并且可以用来作为对象属性的键（如下）。在某些程序语言当中，Symbol 也被称作“原子（atom）类型”。symbol 的目的是去创建一个唯一属性键，保证不会与其他代码中的键产生冲突。</p><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>在JS中，对象是唯一可变的值。</p><blockquote><p>函数也是具有可以被调用能力的对象。</p></blockquote><h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input&#x2F;Output"></a>Input&#x2F;Output</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//浏览器弹出警示框</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;msg&quot;</span>)<br><span class="hljs-comment">//浏览器控制台打印输出信息----&gt;程序员测试用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br><span class="hljs-comment">//浏览器弹出输入框，用户可以输入---&gt;取到的值是字符串</span><br><span class="hljs-title function_">prompt</span>(info)<br><span class="hljs-comment">//可以打印我们返回的元素对象 更好的查看里面的属性和方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(msg)<br></code></pre></td></tr></table></figure><blockquote><p>有趣的是，Hacker有一种方法也是通过I&#x2F;O，内嵌JS语句对网站或者对主机进行骇入。</p></blockquote><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述"></a>正则表达式概述</h3><p>正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</p><h3 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h3><ul><li>灵活性、逻辑性和功能性非常的强。</li><li>可以迅速地用极为简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂。</li><li>实际开发中，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并且根据实际情况修改正则表达式。</li></ul><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><p>一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合，其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号。</p><p>特殊字符可以参考：MDN</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fuctionName</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;<br>&#125;<br><span class="hljs-comment">//ECMAScript6</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fuctionName</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h2><p>如果函数没有返回值就会返回undefined。</p><blockquote><p>在Vue3中，如果在行内使用@click &#x3D; “functionName”之类的指令，带括号表示需要返回值，不带就是不需要。</p></blockquote><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> objectName = &#123;<br><span class="hljs-string">&quot;kid&quot;</span>:<span class="hljs-string">&quot;isme&quot;</span>,<br>    <span class="hljs-string">&quot;man&quot;</span>:<span class="hljs-string">&quot;isyou&quot;</span><br>&#125;<br><span class="hljs-comment">//使用New Object,值得一提的是该方法里是什么类型的数据创建出来的就是什么类型。</span><br><span class="hljs-keyword">const</span> objectName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(&#123;<br>    <span class="hljs-string">&quot;kid&quot;</span>:<span class="hljs-string">&quot;isme&quot;</span>,<br>    <span class="hljs-string">&quot;man&quot;</span>:<span class="hljs-string">&quot;isyou&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//for in</span><br><span class="hljs-keyword">for</span>(item <span class="hljs-keyword">in</span> <span class="hljs-title class_">ObjectName</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br><span class="hljs-comment">//Object.keys() 返回属性名数组</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">ObjectName</span>)<br><span class="hljs-comment">//Object.values() 返回属性值数组</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-title class_">ObjectName</span>)<br><span class="hljs-comment">//Object.entries() 返回嵌套数组</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ObjectName</span>)<br></code></pre></td></tr></table></figure><h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><ul><li>内置对象就是JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）</li><li>内置对象的最大优点就是帮助我们快速开发</li><li>JS提供了多个内置对象：Math、Data、Array、String等</li></ul><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul><li>文档对象模型</li><li>DOM就是把文档当作一个对象来看待</li><li>DOM的顶级对象是document</li><li>DOM主要学习的是操作页面元素</li><li>DOM是W3C标准规范</li></ul><p>1.对于JS，为了能够使JS操作HTML，JS就有了一套自己的dom编程接口。</p><p>2.对于HTML，dom使得html形成一棵dom树。包括文档、元素、节点。</p><h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><p>文档对象模型（DOM），是一种标准编程接口。W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结果、样式。</p><h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>元素：页面中的所有标签都是元素，DOM中用element表示</li><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中用node表示</li></ul><p>&#x3D;&#x3D;DOM把以上内容都看成对象&#x3D;&#x3D;</p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="根据ID获取"><a href="#根据ID获取" class="headerlink" title="根据ID获取"></a>根据ID获取</h3><ul><li>样式为：element.getElementById（’id’）</li></ul><h3 id="根据标签名获取"><a href="#根据标签名获取" class="headerlink" title="根据标签名获取"></a>根据标签名获取</h3><ul><li><p>样式为：element.getElementsTagName（’元素’）</p></li><li><p>得到的是对象的集合</p></li><li><p>输出要在元素后面加s</p></li></ul><h3 id="通过HTML5新增的方法获取"><a href="#通过HTML5新增的方法获取" class="headerlink" title="通过HTML5新增的方法获取"></a>通过HTML5新增的方法获取</h3><ul><li>考虑兼容性不可使用</li><li>样式为：element.getElementsClassName（’元素’）&#x2F;&#x2F;根据类名返回元素对象集合</li><li>样式为：element.querySelector（’选择器’） &#x2F;&#x2F;根据指定选择器返回第一个元素对象—&gt;比如.什么什么就是类选择器<ul><li>只能返回第一个元素对象</li><li>返回全部的话：element.querySelectorAll（’选择器’）</li></ul></li></ul><h3 id="特殊元素获取"><a href="#特殊元素获取" class="headerlink" title="特殊元素获取"></a>特殊元素获取</h3><ul><li>获取body标签<ul><li>样式element.body；</li></ul></li><li>获取html元素<ul><li>样式element.documentElement；</li></ul></li></ul><h2 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h2><h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><p>JS使我们有能力创建动态页面，而事件是可以被JS侦测到的行为</p><p>简单理解：触发—响应机制</p><p>事件由三部分组成： 事件源 事件类型 事件处理程序</p><ul><li>事件源 事件被触发的对象 如 按钮<ul><li>var btn&#x3D;button.getElementById(‘btn’)</li></ul></li><li>事件类型 如何触发 什么事件 比如鼠标点击（onclick） 还是鼠标经过 还是键盘按下</li><li>事件处理程序 通过一个函数赋值的方式完成<ul><li>btn.onclick&#x3D;function( ){…..}</li></ul></li></ul><h3 id="执行事件的步骤"><a href="#执行事件的步骤" class="headerlink" title="执行事件的步骤"></a>执行事件的步骤</h3><ul><li>获取事件源</li><li>注册事件（绑定事件）</li><li>添加事件处理程序</li></ul><h3 id="鼠标事件操作"><a href="#鼠标事件操作" class="headerlink" title="鼠标事件操作"></a>鼠标事件操作</h3><ul><li>onclick鼠标点击左键触发。</li><li>onmouseover鼠标经过触发</li><li>onmouseout鼠标离开触发</li><li>onfocus获得鼠标焦点触发</li><li>onblur失去鼠标焦点触发</li><li>onmousemove鼠标移动触发</li><li>onmouseup鼠标弹起触发</li><li>onmousedown鼠标按下触发</li></ul><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><h3 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h3><ul><li><p>element.innerText&#x3D;  可以改变元素内容(不识别html标签)</p></li><li><p>element.innerHTML&#x3D;  可以改变元素内容(识别html标签)——使用最多</p></li></ul><h3 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h3><ul><li>element.style&#x3D;行内样式操作</li><li>element.className&#x3D;类名样式操作</li></ul><h3 id="改变元素类名"><a href="#改变元素类名" class="headerlink" title="改变元素类名"></a>改变元素类名</h3><ul><li>在JS中想一下子改很多，而且有多个项目要更改时，可以用更改类名。</li><li>正常是element.style修改的样式，但是你可以先定义一个类名是你要修改后的样式，然后写this.className&#x3D;’该类名’，就可以做到修改了。（会进行覆盖）</li><li>如果想要保留原来的类名，可以用this.className&#x3D;’原来的类名 该类名’    这样。</li></ul><h3 id="自定义属性的操作"><a href="#自定义属性的操作" class="headerlink" title="自定义属性的操作"></a>自定义属性的操作</h3><ul><li>获取属性值<ul><li>element.属性   获取属性值</li><li>element.getAttribute(‘属性’)；</li></ul></li><li>区别：<ul><li>element.属性 获取内置属性值（元素本身自带的属性）</li><li>element.getAttribute(‘属性’)； 主要获得自定义的（标准）我们程序员自定义的属性（没错，属性是可以自定义的）</li></ul></li><li>设置属性值<ul><li>element.属性&#x3D;“值”  设置内置属性值。</li><li>element.setAttribute(‘属性’,’值’)</li></ul></li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><p>一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点 nodeType 为 1；</li><li>属性节点 nodeType 为 2；</li><li>文本节点 nodeType 为 3（文本节点包含文字、空格、换行等）；</li></ul><p><strong>我们在实际开发中，节点操作的主要操作的是元素节点</strong></p><p>为什么要用节点操作呢？</p><p>因为在利用我们节点层次关系获取元素的时候会更简单一些。</p><h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><p>利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系</p><ul><li>element.parentNode就可以直接代替var …………（得到的是离元素最近的父节点）</li><li>element.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。而且childNodes返回的是所有子节点 包括元素节点、文本节点等等。</li><li>element.children返回所有元素子节点，虽然看着很不兼容，但是各个浏览器都是允许使用的。其中对第一个元素子节点和最后一个子节点有特殊的获取方式：（包括元素节点、文本节点等等）<ul><li>第一个子节点：element.firstChild即为获取第一个子节点。</li><li>最后的子节点：element.lastChild即为获取最后一个子节点。</li><li>第一个元素子节点：element.firstElementChild即为获取第一个元素子节点。（有兼容性问题IE9+支持）</li><li>最后的元素子节点：element.lastElementChild即为获取最后的元素子节点。（有兼容性问题IE9+支持）</li><li>正常开发的写法都是element.children[number]这样。</li></ul></li><li>兄弟节点：<ul><li>下一个兄弟节点：element.nextSibling返回当前元素的下一个兄弟节点，找不到则返回NULL</li><li>上一个兄弟节点：element.previousSibling返回当前元素上一个兄弟节点，找不到则返回null</li><li>下一个元素兄弟节点：element.nextElementSibling返回当前元素的下一个元素兄弟节点（有兼容性问题IE9+支持）</li><li>上一个元素兄弟节点：element.previousElementSibling返回当前元素的上一个元素兄弟节点（有兼容性问题IE9+支持）</li></ul></li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul><li>创建元素节点：var 节点名字&#x3D;document.creatElement(‘需要创建的节点’) （innerHTML也可以创建节点，但是innerHTML的原理是拼接字符串，creatElement是创建新节点，所以，creatElement会相对快很多。</li><li>添加元素节点：<ul><li>element.appendChild（child）其中element是父级，child是子级  将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素。</li><li>element.insertBefore（child，指定元素）  将一个节点添加到父节点的指定子节点前面。类似于CSS里面的before伪元素。</li></ul></li><li>删除元素节点：element.remove(需要删除的元素节点);（例如某某元素[]）</li><li>克隆元素节点：element.cloneNode(); 复制元素节点，但是复制后需要添加，相当于var name&#x3D;node.cloneNode();   然后再使用添加元素节点的知识进行添加。<ul><li>括号为空或为false则为浅拷贝，即只复制节点本身，不copy里面的子节点。</li><li>括号里为ture则为深拷贝，可以复制节点里面的所有东西。</li></ul></li></ul><h3 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h3><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><ul><li><p>注册事件概述：给元素添加事件，称为注册事件或者绑定事件。</p></li><li><p>注册事件有两种方式：传统方式和方法监听注册方式。</p></li><li><p>传统注册方式：</p><ul><li><p>利用on开头的事件onclick</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;hi~&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>btn.onclick&#x3D;function(){}</p></li><li><p>特点注册事件的唯一性</p></li><li><p>同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。</p></li></ul></li><li><p>方法监听注册方式：</p><ul><li>w3c标准 推荐方法</li><li>addEventListener（）它是一个方法</li><li>IE9之前的IE不支持此方法，可使用attachEvent（）代替</li><li>特点：同一个元素，同一个事件可以注册多个监听器。</li><li>按注册顺序依次执行。</li></ul></li><li><p>addEventListener事件监听方式</p><ul><li>eventTarget.addEventListener（type，listener[，useCapture]）方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，就会触发执行事件处理函数。</li><li>该方法接收三个参数：<ul><li>type：事件类型字符串，比如click，mouseover，注意这里不要带on</li><li>listener：事件处理函数，事件发生时，会调用该监听函数。</li><li>useCapture：可选参数，用于描述事件是冒泡还是捕获，是一个布尔值，默认是false。</li></ul></li></ul></li><li><p>attachEvent事件监听方式（IE9前版本支持）</p><ul><li>eventTarget.attachEvent(eventNameWithOn,callback)方法将指定的监听器注册到eventTarget上，当该对象触发指定的事件时，指定的回调函数就会被执行。</li><li>该方法接受两个函数：<ul><li>eventNameWithOn:事件类型字符串，比如onclick，onmouseover这里要带on</li><li>callback：事件处理函数，当目标触发事件时回调函数被调用。</li></ul></li></ul></li></ul><h4 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h4><ul><li><p>传统注册方式：eventTarget.onclick&#x3D;null；</p></li><li><p>方法监听注册方式：</p><ul><li><p>eventTargrt.removeEventListener（type，listener[，useCapture]）；</p><p>其中listener要写函数的名称，这也就意味着注册的时候也要用函数的名称。</p></li><li><p>eventTargrt.detachEventListener（type，listener[，useCapture]）；</p><p>此为IE9前适用</p></li></ul></li></ul><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件发生时会在元素节点之间按照待定的顺序传播，这个传播过程即为DOM事件流。</p><p>DOM事件流分为三个阶段：1.捕获阶段。2.当前目标阶段。3.冒泡阶段。</p><ul><li><p>事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后<strong>逐级上</strong>传到DOM最顶层节点的过程。</p><p>有些事件是没有冒泡的：例如onblur、onfocus、onmouseenter、onmouseleave</p></li><li><p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后<strong>逐级向下</strong>传播到最具体的元素接收过程。</p></li><li><p>结合useCapture，若useCapture为true则为事件捕获，false为事件冒泡</p></li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>div.onclick&#x3D;function(event){}</p><p>1.event就是一个事件对象，写到我们侦听函数的小括号里面，当形参来看。即事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，他有很多的属性和方法。</p><p>2.事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数。</p><p>3.事件对象是我们事件的一系列相关数据的集合，跟事件相关的，比如鼠标点击里面就包含鼠标的相关信息，鼠标坐标之类的，如果是键盘事件里面就包含的键盘事件的信息，比如判断用户按下了哪个键。</p><p>4.这个事件对象我们可以自己命名 比如event、evt、e（你第一次写的空洞骑士界面音乐盒就是e）</p><p>5.事件对象也有兼容性问题 IE678通过window.event</p><p>兼容性写法e&#x3D;e||window.event</p><h3 id="事件对象的常见属性和方法"><a href="#事件对象的常见属性和方法" class="headerlink" title="事件对象的常见属性和方法"></a>事件对象的常见属性和方法</h3><ul><li><p>e.target   返回触发事件的对象 标准</p><p>e.target返回的是触发事件的对象（元素） this返回的是绑定事件的对象（元素）如绑定ul但触发的li</p></li><li><p>e.srcElement  返回触发事件的对象 非标准IE6~8使用</p></li><li><p>e.type 返回事件的类型 比如click mouseover不带on</p></li><li><p>e.cancelBubble 该属性阻止冒泡 非标准 IE6~8使用</p></li><li><p>e.stopPropagation 该方法阻止冒泡 标准</p></li><li><p>e.returnValue 该属性阻止默认事件 非标准IE6~8使用 比如不让链接跳转</p></li><li><p>e.preventDefault 该方法阻止默认事件 标准 比如不让链接跳转</p></li></ul><h3 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h3><p>事件委托也称为事件代理，在jQuery里面称为事件委派。</p><ul><li>事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响每一个子节点（面试时用得到！！！！！！）  </li><li>事件委托的作用：只操作了一次DOM，提高了程序的性能。</li></ul><h2 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h2><h3 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h3><ul><li><p>contextmenu是鼠标右键的菜单</p></li><li><p>selectstart是鼠标的选中（拉动的选中）</p></li><li><p>click  单击鼠标左键时发生，如果右键也按下则不会发生。当用户的焦点在按钮上并按了 Enter 键时，同样会触发这个事件</p></li><li><p>mousedown 单击任意一个鼠标按钮时发生</p></li><li><p>mouseout 鼠标指针位于某个元素上且将要移出元素的边界时发生</p></li><li><p>mouseover  鼠标指针移出某个元素到另一个元素上时发生</p></li><li><p>mouseup  松开任意一个鼠标按钮时发生</p></li><li><p>mousemove   鼠标在某个元素上时持续发生</p></li></ul><h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><ul><li>e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标</li><li>e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标</li><li>e.pageX 返回鼠标相对于文档页面的X坐标 IE9+支持</li><li>e.pageY 返回鼠标相对于文档页面的Y坐标 IE9+支持</li><li>e.screenX 返回鼠标相对于电脑屏幕的X坐标</li><li>e.screenY 返回鼠标相对于电脑屏幕的Y坐标</li></ul><h3 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h3><p>mouseover经过自身盒子会触发，经过子盒子还会触发。</p><p>mouseenter只有经过自身盒子才会触发。（不会冒泡）</p><h2 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h2><h3 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h3><ul><li>onkeyup 某个键盘按键被松开时触发</li><li>onkeydown 某个键盘按键被按下时触发</li><li>onkeypress 某个键盘按键被按下时触发 但是不能识别功能键 如ctrl shift 箭头等</li></ul><h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><ul><li>KeyCode 返回键盘按下键的ASCII码值<ul><li>keyup和keydown事件不区分字母大小写，都按照大写来看</li><li>keypress事件区分字母大小写</li></ul></li></ul><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul><li>浏览器对象模型</li><li>把浏览器当作一个对象来看待</li><li>BOM的顶级对象是window</li><li>BOM学习的是浏览器窗口交互的一些对象</li><li>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差</li></ul><h2 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象时window。</p><p>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。</p><p>BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C</p><h2 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h2><p>window对象是浏览器的顶级对象，它具有双重角色</p><p>1.它是JS访问浏览器窗口的一个接口</p><p>2.他是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。</p><p>在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert、prompt等</p><h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h3 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h3><ul><li>window.onload&#x3D;function(){}</li></ul><p>或者</p><ul><li><p>window.addEventListener(“load”,function(){});</p></li><li><p>window.onload是窗口（页面）加载事件，当文档内容完全加载会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数。</p></li><li><p>document.addEventListener(‘DOMCotentLoaded’,function(){})</p><ul><li>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片、flash等。</li><li>IE9以上才支持</li><li>如果页面的图片很多的话，从用户访问到onload触发可能需要较长时间，交互效果就不能实现，必然影响用户体验，此时用DOMCotentLoaded事件比较合适。</li></ul></li></ul><p>注意：</p><ul><li>有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。</li><li>window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。（addEventListener则没有限制）</li></ul><h3 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h3><ul><li>window.onresize&#x3D;function(){}</li><li>window.addEventListener(“resize”,function(){})</li><li>window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数。<ul><li>只要窗口大小发生像素变化，就会触发这个事件。</li><li>我们经常利用这个事件完成响应式布局。window.innerWidth为当前屏幕的宽度</li></ul></li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout()定时器"></a>setTimeout()定时器</h4><p>window.setTimeout(调用函数,[延迟的毫秒数]);  </p><p>setTimeout()方法用于设置一个定时器，在该定时器在定时器到期后会执行调用函数。</p><ul><li>window可以省略</li><li>这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式。第三种不推荐。</li><li>延迟的毫秒数省略默认为0，如果写，必须是毫秒。</li><li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li></ul><h4 id="停止setTimeout-定时器"><a href="#停止setTimeout-定时器" class="headerlink" title="停止setTimeout()定时器"></a>停止setTimeout()定时器</h4><p>window.clearTimeout（timeout ID）</p><ul><li>window可以省略</li><li>里面的参数就是定时器的名字</li></ul><h4 id="setlnterval-定时器"><a href="#setlnterval-定时器" class="headerlink" title="setlnterval()定时器"></a>setlnterval()定时器</h4><p>window.setInterval(调用函数,[延迟的毫秒数]);  </p><p>setlnterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。</p><ul><li>window可以省略</li><li>这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名（）’三种形式。</li><li>延迟的毫秒数省略默认为0，如果写，必须是毫秒。</li><li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li></ul><h4 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h4><p>window.clearInterval（interval ID）</p><ul><li>window可以省略</li><li>里面的参数就是定时器的名字</li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象</p><ul><li>全局作用域或者普通函数中this指向全局对象window、</li><li>方法调用中谁调用就指向谁</li></ul><h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><p>Javascript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致——Javascript是为处理页面中用户的交互以及操作DOM而诞生的。</p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。于是JS出现了同步和异步。</p><ul><li>同步任务：同步任务都在主线程上执行，形成一个执行栈。</li><li>异步任务：JS的异步是通过回调函数实现的。一般而言，异步事件有以下三种类型：<ul><li>普通事件：如click，resize</li><li>资源加载：如load，error</li><li>定时器：如setInterval，setTimeout</li></ul></li></ul><p>JS 设计之初就是一个单线程的编程语言，单线程的异步编程方式有无需考虑线程同步和资源竞争的问题，从源头上避免了线程切换。</p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>如果我们需要依次进行多个异步操作，使用回调函数会一层一层的嵌套下去，可读性会变得非常的差，这种情况也叫做“回调地狱”。Promise应运而生。</p><blockquote><p>Fetch函数就是Promise很好的例子，fetch先向目标服务器发送请求，<code>.then()</code>中表示如果服务器返回了，则会执行下面的语句。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//举个异步例子</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://....&quot;</span>)<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">()=&gt;</span> &#123; <span class="hljs-comment">//获取到数据之后做什么</span><br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span> &#123; <span class="hljs-comment">//抛出错误后做什么</span><br>&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span> &#123; <span class="hljs-comment">//异步结束后做什么</span><br>&#125;)<br><span class="hljs-comment">//异步中的错误使用.catch() then不会执行。</span><br><span class="hljs-comment">//.finally()是Promise结束时调用无论失败与否，可以做清除工作。</span><br></code></pre></td></tr></table></figure><p>async和await是ES17的语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//举个例子</span><br><span class="hljs-comment">//async 可以直接用在 function前面用于标记 ,await 只能在 async函数中使用。</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//可以用await直接获得异步函数的返回值，await过程中还是异步</span><br><span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://....&quot;</span>)<br>    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://....&quot;</span>)<br>    <span class="hljs-comment">//如果需要同时异步多个，不然像上面这样就是同步</span><br>    <span class="hljs-keyword">const</span> [a,b] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([res1,res2])<br>    <span class="hljs-comment">//如果在循环中执行异步操作，是不可以直接调用forEach和map这类方法，还是用for，如果需要循环中每个步骤都异步执行，使用for await</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> test <span class="hljs-keyword">of</span> tests)&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h3><p>1.先执行执行栈中的同步任务</p><p>2.异步任务放入任务队列</p><p>3.一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><h3 id="location对象概述"><a href="#location对象概述" class="headerlink" title="location对象概述"></a>location对象概述</h3><p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以解析URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符（Uniform Resource Locator，URL）是互联网上标准资源的地址。互联网上的每个文件都有唯一的一个URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p>URL的一般语法格式为：</p><p>protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</p><p>如<a href="http://www.itcast.cn/index.html?name=andy&age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a></p><ul><li>protocol：通信协议 常用的http，ftp，maito</li><li>host：主机（域名）</li><li>port：端口号 可选，省略时使用方案的默认端口 如http的默认端口为80</li><li>path：路径 由0或多个&#x2F;符号分割开的字符串，一般用来表示主机上的一个目录或文件地址</li><li>query：参数 以键值对的形式，通过&amp;符号分开</li><li>fragment：片段 #后内容常见于锚点 链接</li></ul><h3 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h3><ul><li>location.href：获取或设置整个URL</li><li>location.host：返回主机（域名）</li><li>location.port：返回端口号 如果未写返回 空字符串</li><li>location.pathname：返回路径</li><li>location.search：返回参数</li><li>location.hash：返回片段 #后面内容</li></ul><h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><ul><li>location.assign()：跟href一样，可以转跳页面</li><li>location.replace()：替换当前页面，因为不记录历史，所以不能后退页面。</li><li>location.reload()：重新加载当前页面，相当于刷新按钮或者F5如果参数为true 强制刷新ctrl+f5</li></ul><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送的user-agent头部的值。</p><p>下面前端代码可以判断用户哪个终端打开界面，实现转跳：</p><p>if((navigator.userAgent.match(&#x2F;(phone|pad|pod|iPhone|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|WOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)&#x2F;i))){</p><p>window.location.href&#x3D;””; &#x2F;&#x2F;手机</p><p>}else{<br>window.location.href&#x3D;””;&#x2F;&#x2F;电脑</p><p>}</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL</p><ul><li>history.back()可以使用后退功能</li><li>history.forward()前进功能</li><li>history.go(参数)前进后退功能 参数如果是1前进一个页面，如果是-1 后退一个页面。</li></ul>]]></content>
    
    
    <summary type="html">前端三剑客之一</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>JQuery</title>
    <link href="http://example.com/2023/06/24/JQuery/"/>
    <id>http://example.com/2023/06/24/JQuery/</id>
    <published>2023-06-24T10:01:47.000Z</published>
    <updated>2024-03-16T11:52:59.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><p>但是他已经过时了，不建议去学，了解即可（2024）</p><p><a href="https://jquery.cuishifeng.cn/">jQuery API 中文文档链接</a></p><h3 id="JavaScript库"><a href="#JavaScript库" class="headerlink" title="JavaScript库"></a>JavaScript库</h3><p>即library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show。</p><p>简单理解：就是一个JS文件，里面对我们原生的JS代码进行了封装，存放到里面。这样我们可以快速高效的使用封装好的功能。</p><h3 id="jQuery的优点"><a href="#jQuery的优点" class="headerlink" title="jQuery的优点"></a>jQuery的优点</h3><ul><li>轻量级。</li><li>跨浏览器兼容</li><li>链式编程、隐式迭代</li><li>对事件、样式、动画支持，大大简化了DOM操作。</li><li>支持插件扩展开发。有着丰富的第三方插件，例如：树形菜单、日期控件、轮播图等。</li><li>免费开源。</li></ul><h3 id="jQuery的顶级对象"><a href="#jQuery的顶级对象" class="headerlink" title="jQuery的顶级对象$"></a>jQuery的顶级对象$</h3><p>1.$是jQuery的别称，在代码中可以使用jQuery代替它，但一般为了方便都是直接使用。</p><p>2.$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用它包装成jQuery对象，就可以调用jQuery的方法。</p><h3 id="jQuery对象和DOM对象"><a href="#jQuery对象和DOM对象" class="headerlink" title="jQuery对象和DOM对象"></a>jQuery对象和DOM对象</h3><p>DOM对象与jQuery对象之间是可以相互转换的。</p><p>因为原生JS比jQuery更大，原生的一些属性和方法jQuery没有给我们封装，想要使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p><ul><li><p>DOM对象转换为jQuery对象</p><ul><li>$(‘div’)</li></ul></li><li><p>jQuery对象转化为DOM对象（两种方式）</p><ul><li>$(‘div’)[index]index是索引号</li><li>$(‘div’).get(index)      index是索引号</li></ul></li></ul><h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><h5 id="jQuery基础选择器"><a href="#jQuery基础选择器" class="headerlink" title="jQuery基础选择器"></a>jQuery基础选择器</h5><p>原生JS获取元素的方式有很多、很杂，而且兼容情况不一样，因此jQuery给我们做了封装，使获取元素统一标准。</p><p>$(“选择器”)&#x2F;&#x2F;里面选择器直接写CSS选择器即可，但要加引号</p><h5 id="jQuery设置样式"><a href="#jQuery设置样式" class="headerlink" title="jQuery设置样式"></a>jQuery设置样式</h5><p>$(“div”).css(“属性”,”值”)</p><h5 id="隐式迭代（重要）"><a href="#隐式迭代（重要）" class="headerlink" title="隐式迭代（重要）"></a>隐式迭代（重要）</h5><p>遍历内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代。</p><p>简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。</p><h5 id="jQuery筛选选择器"><a href="#jQuery筛选选择器" class="headerlink" title="jQuery筛选选择器"></a>jQuery筛选选择器</h5><p>用法如$(“li:first”)</p><ul><li>:first  获取第一个元素</li><li>:last       获取最后一个元素</li><li>:eq(index)      获取到的元素中，选择索引号为2的元素，index从0开始。</li><li>:odd      获取到的元素中，索引号为奇数的元素</li><li>:even      获取到的元素中，索引号为偶数的元素</li></ul><h5 id="jQuery筛选方法"><a href="#jQuery筛选方法" class="headerlink" title="jQuery筛选方法"></a>jQuery筛选方法</h5><p>用法如$(“li”).parent()</p><ul><li>parent()  查找父级</li><li>children(selector)  相当于$(“ul&gt;li”),最近一级（亲儿子）</li><li>find(selector)   相当于$(“ul li”), 后代选择器</li><li>siblings(selector)      查找兄弟节点，不包括自己本身</li><li>nextAll([expr])      查找当前元素之后所有的同辈元素</li><li>prevAll([expr])       查找当前元素之前所有的同辈元素</li><li>hasClass(class)       检查当前的元素是否含有某个特定的类，如果有，返回true</li><li>eq(index)       相当于$(“li:eq(2)”),index从0开始.</li></ul><h5 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h5><p>链式编程是为了节省代码量，看起来更优雅。</p><h3 id="jQuery样式操作"><a href="#jQuery样式操作" class="headerlink" title="jQuery样式操作"></a>jQuery样式操作</h3><h5 id="操作CSS方法"><a href="#操作CSS方法" class="headerlink" title="操作CSS方法"></a>操作CSS方法</h5><p>jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。</p><ul><li>参数只写属性名，则是返回属性值。</li><li>参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号。</li><li>参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号。如$(“div”).css({width:400,height:400})</li></ul><h5 id="设置类样式方法"><a href="#设置类样式方法" class="headerlink" title="设置类样式方法"></a>设置类样式方法</h5><ul><li>添加类：$(“div”).addClass(“current”);</li><li>移除类：$(“div”).removeClass(“current”);</li><li>切换类：$(“div”).toggleClass(“current”);</li></ul><h5 id="类操作与className区别"><a href="#类操作与className区别" class="headerlink" title="类操作与className区别"></a>类操作与className区别</h5><p>原生JS中className会覆盖元素原先里面的类名</p><p>jQuery里面类操作只是对指定类进行操作，不影响原先的类名。</p><h3 id="jQuery效果"><a href="#jQuery效果" class="headerlink" title="jQuery效果"></a>jQuery效果</h3><h5 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h5><ul><li><p>显示语法规范：show([speed],[easing],[fn])</p></li><li><p>显示参数：</p><ul><li>参数都可以省略，无动画直接显示</li><li>speed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值</li><li>easing：用于指定切换效果，默认是”swing”</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li><li><p>show()</p></li><li><p>hide()</p></li><li><p>toggle()</p></li></ul><h5 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h5><ul><li><p>滑动语法规范：slideDown([speed],[easing],[fn])</p></li><li><p>滑动参数：</p><ul><li>参数都可以省略，无动画直接显示</li><li>speed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值</li><li>easing：用于指定切换效果，默认是”swing”</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li><li><p>slideDown()</p></li><li><p>slideUp()</p></li><li><p>slideToggle()</p></li></ul><h5 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h5><ul><li><p>淡入淡出语法规范：fadeIn([speed],[easing],[fn])</p></li><li><p>淡入淡出参数：</p><ul><li>参数都可以省略，无动画直接显示</li><li>speed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值</li><li>easing：用于指定切换效果，默认是”swing”</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li><li><p>fadeIn()</p></li><li><p>fadeOut()</p></li><li><p>fadeToggle()</p></li><li><p>fadeTo()</p><ul><li>渐进方式调整到指定的不透明度：fadeTo([speed],opacity,[easing],[fn])</li><li>opacity透明度必须写，取值0~1之间。</li><li>speed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值</li><li>easing：用于指定切换效果，默认是”swing”</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li></ul><h5 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h5><ul><li>animate(params,[speed],[easing],[fn])</li><li>参数<ul><li>params:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法</li><li>speed：三种预定速度之一的字符串(“slow”,”normal”,”fast”)或是表示动画时长的毫秒数值</li><li>easing：用于指定切换效果，默认是”swing”</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li></ul><h5 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h5><ul><li>hover([over],out);<ul><li>over:鼠标移到元素上要触发的函数（相当于mouseenter）</li><li>out:鼠标移出元素要触发的函数（相当于mouseleave）</li></ul></li></ul><h5 id="动画队列以及停止排队的方法"><a href="#动画队列以及停止排队的方法" class="headerlink" title="动画队列以及停止排队的方法"></a>动画队列以及停止排队的方法</h5><ul><li>动画或效果队列：动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</li><li>停止排队<ul><li>stop()</li><li>stop()方法用于停止动画或效果</li><li>注意：stop()写到动画或者效果的前面，相当于停止结束上一次的动画。</li></ul></li></ul><h3 id="jQuery属性操作"><a href="#jQuery属性操作" class="headerlink" title="jQuery属性操作"></a>jQuery属性操作</h3><h5 id="设置或获取元素固有属性值prop"><a href="#设置或获取元素固有属性值prop" class="headerlink" title="设置或获取元素固有属性值prop()"></a>设置或获取元素固有属性值prop()</h5><p>所谓元素固有属性就是元素本身自带的属性，比如<a>元素中的href</p><ul><li>获取属性语法：prop(“属性”)</li><li>设置属性语法：prop(“属性”，”属性值”)</li></ul><h5 id="设置或获取元素自定义属性值attr"><a href="#设置或获取元素自定义属性值attr" class="headerlink" title="设置或获取元素自定义属性值attr()"></a>设置或获取元素自定义属性值attr()</h5><p>用户自己给元素添加的属性</p><ul><li>获取属性语法：attr(“属性”)  &#x2F;&#x2F;类似原生getAttribute()</li><li>设置属性语法：attr(“属性”，”属性值”)</li></ul><h3 id="jQuery内容文本值"><a href="#jQuery内容文本值" class="headerlink" title="jQuery内容文本值"></a>jQuery内容文本值</h3><p>主要针对元素的内容还有表单的值操作</p><h5 id="普通元素内容html-（相当于inner-HTML）"><a href="#普通元素内容html-（相当于inner-HTML）" class="headerlink" title="普通元素内容html()（相当于inner HTML）"></a>普通元素内容html()（相当于inner HTML）</h5><p>html()—-&gt;获取元素的内容</p><p>html(“内容”)—-&gt;设置元素的内容</p><h5 id="普通元素文本内容text-（相当于inner-Text）"><a href="#普通元素文本内容text-（相当于inner-Text）" class="headerlink" title="普通元素文本内容text()（相当于inner Text）"></a>普通元素文本内容text()（相当于inner Text）</h5><p>text()—-&gt;获取元素的文本内容</p><p>text(“内容”)—-&gt;设置元素的文本内容</p><h5 id="表单的值val-（相当于原生value）"><a href="#表单的值val-（相当于原生value）" class="headerlink" title="表单的值val()（相当于原生value）"></a>表单的值val()（相当于原生value）</h5><p>val()—-&gt;获取表单的值</p><p>val(“内容”)—-&gt;设置表单的值</p><h3 id="jQuery元素操作"><a href="#jQuery元素操作" class="headerlink" title="jQuery元素操作"></a>jQuery元素操作</h3><p>主要是遍历、创建、添加、删除元素操作。</p><h5 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h5><p>jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作，就要用到遍历。</p><ul><li>$(“div”).each(function(index,domEle){xxx;})<ul><li>each()方法遍历匹配的每一个元素。主要用DOM处理。</li><li>里面的回调函数有两个参数：index是每一个元素的索引号；domEle是每一个DOM元素对象，不是jQuery对象</li><li>所以要想使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle)</li></ul></li></ul><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><ul><li>$(“<li></li>“)</li><li>动态创建了一个<li></li></ul><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><ul><li>内部添加<ul><li>element.appent(“内容”)  把内容放入匹配元素后面，类似原生appendChild</li></ul></li><li>外部添加<ul><li>element.after(“内容”)</li><li>element.before(“内容”)</li></ul></li></ul><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><ul><li>element.remove()   &#x2F;&#x2F;删除匹配的元素</li><li>element.empty()    &#x2F;&#x2F;删除匹配的元素集合中所有的子节点</li><li>element.html(“”)    &#x2F;&#x2F;清空匹配的元素内容</li></ul><h3 id="jQuery尺寸、位置操作"><a href="#jQuery尺寸、位置操作" class="headerlink" title="jQuery尺寸、位置操作"></a>jQuery尺寸、位置操作</h3><h5 id="jQuery尺寸"><a href="#jQuery尺寸" class="headerlink" title="jQuery尺寸"></a>jQuery尺寸</h5><ul><li><p>width()&#x2F;height()取得匹配元素宽度和高度值 只算width&#x2F;height</p></li><li><p>innerWidth()&#x2F;innerHeight()取得匹配元素宽度和高度值 包含padding</p></li><li><p>outerWidth()&#x2F;outerHeight()取得匹配元素宽度和高度值 包含padding、border</p></li><li><p>outerWidth(true)&#x2F;outerHeight(true)取得匹配元素宽度和高度值 包含padding、border、margin</p></li><li><p>以上参数为空，则是获取相应值，返回的是数字型</p></li><li><p>如果参数为数字，则是修改相应值</p></li><li><p>参数可以不必写单位</p></li></ul><h5 id="jQuery位置"><a href="#jQuery位置" class="headerlink" title="jQuery位置"></a>jQuery位置</h5><p>位置主要有三个：offset()、position()、scrollTop()&#x2F;scrollLeft()</p><ul><li>offset()设置或获取元素偏移<ul><li>此方法设置或返回被选元素相当于文档的偏移坐标，跟父级没有关系。</li><li>该方法有两个属性left、top。</li><li>可以设置元素的偏移：offset({top:10,left:10})</li></ul></li><li>position()获取元素偏移<ul><li>position()方法用于被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为标准</li></ul></li><li>scrollTop()&#x2F;scrollLeft()设置或获取元素被卷去的头部和左侧<ul><li>scrollTop()方法设置或返回被选元素被卷去的头部。</li></ul></li></ul><h3 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h3><h5 id="单个事件注册"><a href="#单个事件注册" class="headerlink" title="单个事件注册"></a>单个事件注册</h5><ul><li>语法：element.事件(function(){})</li></ul><h5 id="单个事件处理"><a href="#单个事件处理" class="headerlink" title="单个事件处理"></a>单个事件处理</h5><p>事件处理on()绑定事件—-&gt;on()方法在匹配元素上绑定一个或多个事件的事件处理函数。</p><p>element.on(events,[selector],fn)</p><ul><li><p>events:一个或多个用空格分隔的事件类型，如”click”或”keydown”</p></li><li><p>selector:元素的子元素选择器。</p></li><li><p>fn:回调函数，即绑定在元素上的侦听函数</p></li><li><p>优势</p><ul><li>一：可以绑定多个事件，多个处理事件处理程序。$(“div”).on({mouseover:function(){},mouseout:function(){}})</li><li>二：可以事件委派操作。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。</li><li>三：动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件</li></ul></li></ul><p>off()方法可以移出通过on()方法添加的事件处理程序。</p><p>如果有的事件只想触发一次，可以使用one()来绑定事件</p><h5 id="自动触发事件trigger"><a href="#自动触发事件trigger" class="headerlink" title="自动触发事件trigger()"></a>自动触发事件trigger()</h5><p>有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发</p><p>element.trigger(“type”)</p><h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>事件被触发，就会有事件对象的产生。</p><p>阻止默认行为：event.preventDefault() 或者 return false</p><p>阻止冒泡：event.stopPropagation()</p><h3 id="jQuery其他方法"><a href="#jQuery其他方法" class="headerlink" title="jQuery其他方法"></a>jQuery其他方法</h3><h5 id="jQuery对象拷贝"><a href="#jQuery对象拷贝" class="headerlink" title="jQuery对象拷贝"></a>jQuery对象拷贝</h5><p>如果想要把某个对象拷贝给另一个对象使用，此时可以使用$.extend()方法</p><p>$extend([deep],target,object1,[objectn])</p><ul><li>deep:如果设为true为深拷贝，默认为false浅拷贝</li><li>target:要拷贝的目标对象</li><li>object1:待拷贝到的第一个对象</li><li>objectn:待拷贝到的第N个对象</li><li>浅拷贝是把拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。</li></ul><h5 id="jQuery多库共存"><a href="#jQuery多库共存" class="headerlink" title="jQuery多库共存"></a>jQuery多库共存</h5><ul><li><p>问题概述：jQuery使用$作为标识符，随着jQuery的流行，其他js库也会用其作为标识符，这样一起使用会起冲突。</p></li><li><p>客观需求：需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。</p></li><li><p>jQuery解决方案：</p><ul><li>把里面的$符号统一改为jQuery，例如jQuery(“div”)</li><li>jQuery变量规定新的名称：$.noConflict()</li></ul></li></ul><h5 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h5><p>jQuery功能比较有限，想要更复杂的特技效果，可以借助jQuery插件完成。</p><p>注意这些插件也是依赖jQuery来完成的，所以必须要先引入jQuery文件，因此页被称为jQuery插件。</p><ul><li><p>常用网站：</p><ul><li><a href="https://www.jq22.com/">jQuery插件库</a></li><li><a href="https://www.htmleaf.com/">jQuery之家</a></li></ul></li><li><p>jQuery插件使用步骤</p><ul><li>引入相关文件。(jQuery文件和插件文件)</li><li>复制相关html、css、js（调用插件）</li></ul></li><li><p>插件演示</p><ul><li>瀑布流</li><li>懒加载：页面滑动到可视区域，再加载图片。我们使用jQuery插件库EazyLazyLoad。注意，此时的js引入文件和js调用必须写到DOM元素（图片）后面 </li><li>全屏滚动（明日方舟）（fullpage.js）：github:<a href="https://github.com/alvarotrigo/fullPage.js">https://github.com/alvarotrigo/fullPage.js</a></li></ul></li><li><p>bootstrap JS插件：bootstrap插件也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件。<a href="https://v3.bootcss.com">Bootstrap中文文档</a></p></li></ul>]]></content>
    
    
    <summary type="html">一个便于使用的JavaScript库</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/2023/06/24/HTML/"/>
    <id>http://example.com/2023/06/24/HTML/</id>
    <published>2023-06-24T10:01:35.000Z</published>
    <updated>2024-04-23T14:41:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><ul><li>单标签</li><li>双标签</li></ul><h1 id="文字样式变形"><a href="#文字样式变形" class="headerlink" title="文字样式变形"></a>文字样式变形</h1><ul><li>strong <strong>加粗</strong></li><li>em <em>倾斜</em></li><li>del <del>删除线</del></li><li>ins 下划线</li><li>p&gt; </p>换行</li></ul><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><ul><li><pre><code class="hljs">img src=&quot;链接&quot; alt=&quot;若显示失败输入的字符&quot; width=&quot;左右大小&quot; height=&quot;高低&quot;  title=&quot;鼠标放在图片上显示的字&quot;/&gt;(src必须)</code></pre></li></ul><h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><ul><li>相对路径<ul><li>下一条路径img src&#x3D;”本路径中含有图片的文件夹&#x2F;图片名称（包含后缀）”&#x2F;&gt;</li><li>上一条路径img src&#x3D;”..&#x2F;图片名称（包含后缀）”&#x2F;&gt;</li></ul></li><li>绝对路径</li><li>此电脑中的文件img src&#x3D;”C.........\图片名称（包含后缀）”&gt;(注意相对和绝对的斜杠不一样)</li><li>完整的网络地址img src&#x3D;”直接将网址输入”&#x2F;&gt;</li></ul><h1 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h1><table><thead><tr><th>链接类型</th><th>说明</th><th>标签</th></tr></thead><tbody><tr><td>外部链接</td><td>target中为下划线self就是关本界面开新界面，下划线blank就是直接开一个新界面</td><td>a href&#x3D;”直接将网址输入” target&#x3D;”…”&gt;显示出的字符</a></td></tr><tr><td>内部链接</td><td>即自己多个网页之间转跳的链接</td><td>a href&#x3D;”直接输入html的名字（加后缀”&gt;显示出的字符</a></td></tr><tr><td>空链接</td><td>常用于页面尚未完善时的框架</td><td>a href&#x3D;”#”&gt;显示出的字符</a></td></tr><tr><td>下载链接</td><td>当href指向一个zip或exe文件时，点击链接会直接下载，如果需要不点击，可以使用a.download来实现</td><td></td></tr><tr><td>网页元素链接</td><td>文本、表格、音频、视频都能进行超链接</td><td>a href&#x3D;”…”&gt; img src&#x3D;”…”&#x2F;&gt;</a></td></tr><tr><td>锚点链接</td><td>可以直接转跳到页面内上下文 首先要对跳的地方进行设置 然后进行设置超链接</td><td>h1 id&#x3D;”…”&gt;显示出的字符</h1> a href&#x3D;”#…”&gt;显示出的字符</a></td></tr><tr><td>注释</td><td>ctrl+&#x2F;</td><td>!–输入想要输入的注释–&gt;</td></tr></tbody></table><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码(前面都加&amp;)</th></tr></thead><tbody><tr><td></td><td>空格</td><td>nbsp;</td></tr><tr><td>&lt;</td><td>小于号</td><td>lt;</td></tr><tr><td>&gt;</td><td>大于号</td><td>gt;</td></tr><tr><td>&amp;</td><td>和号</td><td>amp;</td></tr><tr><td>￥</td><td>人民币号</td><td>yen;</td></tr><tr><td>©</td><td>版权</td><td>copy;</td></tr><tr><td></td><td>注册商标</td><td>reg;</td></tr><tr><td>°</td><td>摄氏度</td><td>deg;</td></tr><tr><td>+-</td><td>正负号</td><td>plusmn;</td></tr><tr><td>×</td><td>乘号</td><td>times;</td></tr><tr><td>➗</td><td>除号</td><td>divide;</td></tr><tr><td>^2^</td><td>二次方</td><td>sup2;</td></tr><tr><td>^3^</td><td>三次方</td><td>sup3;</td></tr></tbody></table><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><ul><li><p>表格的基本语法 </p><ul><li>table&gt;</table>是用于定义表格的标签。</li><li>tr&gt;</tr>标签用于定义表格中的行，必须嵌套在table标签中。</li><li>td&gt;</td>标签用于定义表格中的单元格，必须嵌套在tr标签中。</li><li>th&gt;</th>标签用于制作表头，必须嵌套在tr标签中。</li><li>thead&gt;</thead>标签用于制作表头区域，必须嵌套在table标签中。</li><li>tbody&gt;</tbody>用于制作表格主体部分，必须嵌套在table标签中。</li></ul></li><li><p>表格属性（都要写到table标签中，CSS还会学，小小掌握即可）</p><ul><li>align&#x3D;”…”表示表格与文字的对齐方式</li><li>border&#x3D;”…”表示边框厚度</li><li>cellpadding&#x3D;”…” 规定文字与表格之间的空白，默认为一像素</li><li>cellspacing&#x3D;”…”规定单元格之间的空隙，默认为2像素</li><li>width、height&#x3D;”…” 规定单元格的宽度、高度</li></ul></li><li><p>合并单元格（必须在第一行和第一列添加标签 且记得删除多余的单元格，必须用于td标签中）</p><ul><li><p>rowspan&#x3D;”要合并的行”</p></li><li><p>colspan&#x3D;”要合并的列”</p></li></ul></li></ul><h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><ul><li>无序列表（重点）–&gt;整齐简单不要求顺序用无需列表<ul><li>ul&gt;</ul>表示无序列表，一般以项目符号呈现列表项（ul标签中只能存放li标签）</li><li>li&gt;</li>定义列表项 可以存放任何元素 相当于一个容器</li></ul></li><li>有序列表<ul><li>ol&gt;</ol>表示有序列表 同样使用li标签</li></ul></li><li>自定义列表（重点）–&gt;当有很多小分支对一个大分支进行说明时使用自定义列表<ul><li>dl&gt;</dl>用于描述自定义列表（dl标签中只能存在dt和dd标签）</li><li>dt&gt;</dt>用于描述名词</li><li>dd&gt;</dd>用于对名词进行解释</li></ul></li></ul><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><h5 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h5><ul><li>form action&#x3D;”url地址” method&#x3D;”提交方式” name&#x3D;”表单域名称”&gt;</form><ul><li>action属性用于指定接收并处理表单数据的服务器程序的url地址 <strong>还没学完后面会扩展</strong></li><li>method属性用于设置表单数据的提交方式，其取值为get或post</li><li>name属性用于指定表单的名称，以区分同一个页面中的多个表单域</li></ul></li></ul><h5 id="表单控件（表单元素）"><a href="#表单控件（表单元素）" class="headerlink" title="表单控件（表单元素）"></a>表单控件（表单元素）</h5><ul><li><p>input type&#x3D;”属性值” name&#x3D;”名称” value&#x3D;”用户自定义” checked&#x3D;”checked” maxlength&#x3D;”一个正整数”&gt;输入表单元素</p><ul><li><p>type的属性值：</p><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下用于通过javascript启动脚本）</td></tr><tr><td>checkbox</td><td>定义复选框（与radio相对）</td></tr><tr><td>file</td><td>定义输入字段和浏览按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>password</td><td>定义密码字段，该字段中的字符被掩码</td></tr><tr><td>radio</td><td>定义单选按钮（与checkbox相对，多选一必须有相同name）</td></tr><tr><td>reset</td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td>submit</td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本，默认宽度为20个字符</td></tr></tbody></table></li><li><p>name属性：定义input元素的名称</p></li><li><p>value属性：规定input元素的值</p></li><li><p>checked属性：规定此input元素首次加载时应当被选中 （用于单选和多选按钮 页面一打开就被选中就加这个属性）</p></li><li><p>maxlength属性：规定输入字段中的字符的最大长度</p></li></ul></li><li><p>label for&#x3D;”名称”&gt;要点击的字符或图片</label>标签：用于绑定一个表单元素，当点击label标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，增加用户体验。</p><ul><li>id属性：与label标签搭配使用 放在input里面</li></ul></li><li><p>select&gt;</select>下拉表单元素用于多个选项选一个简洁页面 </p><ul><li>option&gt;选项</option>只能嵌套在select元素中 （在option标签中定义selected&#x3D;”selected”，当前项为默认选项）</li></ul></li><li><p>textarea&gt;</textarea>文本域元素用于键入大量内容时</p></li></ul><h5 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h5><ul><li>记得添加增加用户体验的提示信息</li></ul><h1 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h1><ul><li>标签*n+tab可以快速生成n个标签</li><li>父子级关系输入标签一&gt;标签二+tab可以快速生成父子级标签</li><li>兄弟级关系输入标签1+标签二+tab可以快速生成兄弟级标签</li><li>输入标签.类名可以快速生成有类名的标签（类名后面加$*n可以生成很多不同的类名）</li></ul><h1 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h1><p>新特性虽然强大 但是都有兼容问题 基本是IE9+以上的版本才支持，如果不考虑兼容性问题，可以大量使用这些新特性</p><h3 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h3><p>参见CSS规范使用标签 打*的是语义化</p><h3 id="HTML5新增的多媒体文件"><a href="#HTML5新增的多媒体文件" class="headerlink" title="HTML5新增的多媒体文件"></a>HTML5新增的多媒体文件</h3><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><ul><li><p>尽量放mp4文件</p></li><li><p>样式为video src&#x3D;””是一个双标签</p></li><li><p>常见属性为autoplay（自动播放）&#x2F;controls（播放控件显示）&#x2F;width&#x2F;height&#x2F;loop（循环播放）&#x2F;preload（是否预加载 属性值为auto&#x2F;none）&#x2F;src&#x2F;poster（等待加载的画面图片）&#x2F;muted（静音播放）</p></li></ul><h5 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h5><ul><li>尽量放mp3文件</li><li>样式基本同视频 属性只有autoplay&#x2F;controls&#x2F;loop&#x2F;src</li></ul><h3 id="HTML新增的表单类型"><a href="#HTML新增的表单类型" class="headerlink" title="HTML新增的表单类型"></a>HTML新增的表单类型</h3><ul><li><p>input type后面的属性值增加了很多 例如email&#x2F;url&#x2F;date&#x2F;time&#x2F;month&#x2F;week&#x2F;number&#x2F;tel&#x2F;search&#x2F;color</p></li><li><p>新增了很多表单属性 </p><ul><li>required:required；表示该表单不能为空  </li><li>placeholder:提示文本； 表示表单的提示信息  </li><li>autofocus:autofocus;自动聚焦</li><li>autocomplete:on&#x2F;off; 当用户在字段开始键入时，浏览器基于之前键入过的值，显示出字段中填写的选项</li><li>mutiple:mutiple; 可以多选文件提交</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前端三剑客之一</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://example.com/2023/06/24/ES6/"/>
    <id>http://example.com/2023/06/24/ES6/</id>
    <published>2023-06-24T10:01:27.000Z</published>
    <updated>2024-03-16T11:53:36.072Z</updated>
    
    <content type="html"><![CDATA[<p>ES 是脚本语言的规范，而平时经常编写的 JS 是 ES 的一种体现，所以 ES 的新特性其实指的就是 JS 的新特性</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>相当于局部变量</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>常量，不可修改</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>可以用 let [ …… ] &#x3D; 数组名、let { ……. } &#x3D; 对象名 ，这样的方式来快速取值</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>通常情况下你str是没办法换行的，想要换行的话就要用”” + 这样 但是 ES6 中给到了&#96;&#96;反引号 在反引号中可以随便换行 :laughing:</p><h3 id="对象的简便写法"><a href="#对象的简便写法" class="headerlink" title="对象的简便写法"></a>对象的简便写法</h3><p>如果对象的名字和值一样 就可以直接写一个</p><p>还有就是对象函数 可以省略function 直接写 名字(){} 这样</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>函数声明 变成了</p><blockquote><p>let fn &#x3D; (a,b) &#x3D;&gt; {<br>    return a+b;<br>} </p></blockquote><p>这样 省略了function</p><ul><li><p>this 是静态的 this 始终指向函数声明时所在作用域下的 this 的值</p></li><li><p>不能作为构造函数实名化对象</p></li><li><p>不能使用 arguments 变量</p></li><li><p>当形参只有一个的时候可以省略小括号，当代码体只有一个的时候可以省略花括号</p></li></ul><h3 id="函数参数的默认值设置"><a href="#函数参数的默认值设置" class="headerlink" title="函数参数的默认值设置"></a>函数参数的默认值设置</h3><p>在小括号里可以直接等于</p><blockquote><p>add &#x3D; (c&#x3D;1) &#x3D;&gt;<br>    return c;</p><p>结果是1 </p></blockquote><p>与结构赋值结合</p><blockquote><p>connect &#x3D; (username,password)  &#x3D;&gt; {<br>    console.log(username)<br>}<br>connect({<br>    username:”111”<br>    password:”222”<br>})</p></blockquote><p>可以这样使用</p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6引用 rest 参数，用于获取函数的实参，用来代替 arguments </p><p>用法如下</p><blockquote><p>fn &#x3D; (a,b,…args){<br>    输出…<br>}<br>fn(传值)</p></blockquote><p>值得一提的是 rest 函数必须要放到参数最后</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>… 运算符可以把数组转化为逗号分割的参数序列</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol是一种类似于字符串的数据类型</p><h3 id="迭代器-interator"><a href="#迭代器-interator" class="headerlink" title="迭代器 interator"></a>迭代器 interator</h3><p>一个用于快速遍历数组的 新属性<br>next()会迭代调用数组元素，每次迭代一个，直到用完</p><blockquote><p>const num &#x3D; [1,2,3,4];<br>let it &#x3D; num[Symbol.interator] ();&#x2F;&#x2F;调用必须<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());&#x2F;&#x2F; 这样就会快速生成四个对象 value 会遍历 对象中还有一个 done 值 如果被遍历完了 done 就会变成true</p></blockquote><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>其实就是一个特殊的函数，异步编程 纯回调函数</p><blockquote><p>function * gen(){<br>    part1;<br>    yield ‘sign1’;<br>    part2;<br>    yield ‘sign2’;<br>    part3;<br>}</p><p>let it &#x3D; gen();<br>it.next();<br>it.next();<br>it.next();</p></blockquote><p>这样的话会逐渐执行part1，然后part2，然后part3</p><p>甚至可以用 yield 来传参，这里截取片段来展示</p><blockquote><p>let one &#x3D; yield 111;<br>console.log(one);</p><p>…</p><p>it.next(‘AAA’) &#x2F;&#x2F;这样就会输出AAA</p></blockquote><h3 id="Promise-比较重要-面试常问"><a href="#Promise-比较重要-面试常问" class="headerlink" title="Promise (比较重要 面试常问)"></a>Promise (比较重要 面试常问)</h3><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p><p>使用Promise方案主要有以下好处</p><ul><li>可以很好的解决回调地狱的问题（避免了层层嵌套的回调函数</li><li>语法非常简洁。promise对象提供了简洁的API 使得控制异步操作更加容易</li></ul><p>&#x3D;&#x3D;简单学学 如果想要了解还可以再看&#x3D;&#x3D;</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ES6提供了新的数据结构 Set (集合)。类似于数组，但是成员的值都是唯一的，集合实现了 iterator 接口 所以可以使用扩展运算符和for of进行遍历</p><p>会自动去重 类似数学中的集合 </p><p>.size是个数 .add增加 .delete删除 .has检测 .clear清空</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了 iterator 接口，所以可以使用 扩展运算符 和 for  of 进行遍历</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class 这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上 ES6 的 class 可以看作 只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更面向对象编程的语法而已。</p><h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><ul><li><p>Object.assign(a,b) 对象的合并<br>该方法可以使两个对象合并 由后面的覆盖前面的 </p></li><li><p>Object.setPrototypeOf 设置原型对象 可以放到_proto_中去</p></li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小的文件组合起来</p><p>模块化的优势有以下几点：</p><ul><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ul><h5 id="ES6模块化语法"><a href="#ES6模块化语法" class="headerlink" title="ES6模块化语法"></a>ES6模块化语法</h5><p>模块化语法主要由两个命令构成：export 和 import</p><ul><li>export 命令用于规范模块的对外接口</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">teach</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><span class="hljs-keyword">export</span> &#123;name,teach&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;name&quot;</span>;<br>    <span class="hljs-attr">teach</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>import 命令用于输入其他模块提供的功能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">import</span> &#123;name,teach&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;ES7~ES11没学&#x3D;&#x3D;</p>]]></content>
    
    
    <summary type="html">Javascript自我进阶</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="http://example.com/2023/06/24/CSS/"/>
    <id>http://example.com/2023/06/24/CSS/</id>
    <published>2023-06-24T10:01:20.000Z</published>
    <updated>2024-04-25T15:05:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>CSS参考手册：<a href="https://www.w3school.com.cn/cssref/index.asp">Ctrl+单击</a></p><h1 id="特殊样式制作方案"><a href="#特殊样式制作方案" class="headerlink" title="特殊样式制作方案"></a>特殊样式制作方案</h1><p>这里是一些CSS特殊样式设计的方案。</p><h3 id="CSS三角形绘制"><a href="#CSS三角形绘制" class="headerlink" title="CSS三角形绘制"></a>CSS三角形绘制</h3><ul><li><p>方案一🎯：<strong>使用边框实现三角形</strong>：</p><p>原理：设置一个高宽为0的div，然后设置border-方向即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid yellowgreen;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid deeppink;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid bisque;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid chocolate;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：快捷简单。</p><p>缺点：只能实现45deg的三角形。</p></li><li><p>方案二🎯：<strong>使用背景渐变颜色实现三角形</strong></p><p>原理：使用渐变色让其颜色变成固定的两种颜色，也可以是透明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 线性渐变 */</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, deeppink, deeppink <span class="hljs-number">50%</span>, yellowgreen <span class="hljs-number">50%</span>, yellowgreen <span class="hljs-number">100%</span>);<br>&#125;<br><br><span class="hljs-comment">/* 角向渐变 */</span><br><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">background</span>: <span class="hljs-built_in">conic-gradient</span>(from <span class="hljs-number">90deg</span> at <span class="hljs-number">50%</span> <span class="hljs-number">0</span>, deeppink <span class="hljs-number">0</span>, deeppink <span class="hljs-number">45deg</span>, transparent <span class="hljs-number">45.1deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：可以多角度自由斜角。</p><p>缺点：三角形形态比较难以调试。</p></li><li><p>方案三🎯：<strong>使用盒子旋转实现三角形</strong></p><p>原理：通过伪元素或内置盒子旋转和隐藏子元素溢出来实现三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.triangle</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <br>    &amp;<span class="hljs-selector-pseudo">::before</span> &#123;<br>        <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">background</span>: deeppink;<br>        <span class="hljs-attribute">transform-origin</span>: left bottom;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：直观、可塑性高。</p><p>缺点：盒子容易偏移。</p></li><li><p>方案四🎯：<strong>使用容器剪裁实现三角形</strong></p><p>原理：有一个css属性叫做clip-path，适用于创建一个只有元素部分区域可以显示的剪切区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background</span>: deeppink;<br>    <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">100%</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：不只是三角形，能剪裁出任何想要的图形。</p><p>缺点：操作量大。</p></li><li><p>方案五🎯：<strong>使用icon实现三角形</strong></p><p>原理：直接使用字体中的icon。</p><p>优点：太快了，什么都不用想直接输入一个字符即可。</p><p>缺点：三角形不可调整，三角形可能随着不同字体变形。</p></li></ul><h3 id="缺角盒子实现"><a href="#缺角盒子实现" class="headerlink" title="缺角盒子实现"></a>缺角盒子实现</h3><ul><li><p>方案一：<strong>盒子遮挡实现</strong></p><p>原理：做两个同背景颜色的三角形进行遮挡。</p><p>优点：快速。</p><p>缺点：颜色死板，背景是图片则没办法。</p></li><li><p>方案二：<strong>使用背景渐变颜色实现三角形</strong></p><p>原理：同三角形绘制。</p><p>优点：不用定位。</p><p>缺点：同上方案。</p></li><li><p>方案三：<strong>使用盒子旋转实现缺角盒子</strong></p><p>原理：使用一个较长的div和元素溢出隐藏样式。</p><p>优点：可以设置缺角的边框。</p><p>缺点：调试麻烦。</p></li></ul><h3 id="计算器类型数码字体实现"><a href="#计算器类型数码字体实现" class="headerlink" title="计算器类型数码字体实现"></a>计算器类型数码字体实现</h3><ul><li><p>方案：<strong>直接去寻找对应字体</strong></p><p>原理：使用字体更改数字字体比自己手写js+css容易太多了。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1.可以在https://www.dafont.com/上找到喜欢的字体。<br>2.字体的文件一般都是以.tff为后缀，可以改成.eot或者.woff格式，兼容浏览器。<br>3.在style.css中使用@font-face配置，如<br>@font-face&#123;font-family: &#x27;digital&#x27;;src:url(&#x27;/public/DS-DIGIT.woff&#x27;) format(&#x27;woff&#x27;)&#125;<br>4.在需要使用的地方使用font-family属性。<br></code></pre></td></tr></table></figure><p>优点：快速有效。</p><p>缺点：字体寻找花费时间。</p></li></ul><h3 id="毛玻璃"><a href="#毛玻璃" class="headerlink" title="毛玻璃"></a>毛玻璃</h3><ul><li><p>方案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br><span class="hljs-attribute">height</span>: auto;<br><span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, .<span class="hljs-number">7</span>);<br>webkit-backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br>backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">10px</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="文字颜色渐变"><a href="#文字颜色渐变" class="headerlink" title="文字颜色渐变"></a>文字颜色渐变</h3><ul><li><p>方案一：静态渐变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to right, #颜色, #颜色); <br>-webkit-<span class="hljs-attribute">background-clip</span>: text;<br>-webkit-text-fill-<span class="hljs-attribute">color</span>: transparent;<br></code></pre></td></tr></table></figure></li><li><p>方案二：动态渐变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">-webkit-linear-gradient</span>(<br>  <span class="hljs-number">0deg</span>,<br>  #颜色<span class="hljs-number">1</span>,<br>  #颜色<span class="hljs-number">2</span> <span class="hljs-number">25%</span>,<br>  #颜色<span class="hljs-number">3</span> <span class="hljs-number">50%</span>,<br>  #颜色<span class="hljs-number">4</span> <span class="hljs-number">75%</span>,<br>  #颜色<span class="hljs-number">1</span><br>);<br>-webkit-<span class="hljs-attribute">background-clip</span>: text;<br><span class="hljs-attribute">color</span>: transparent;<br></code></pre></td></tr></table></figure></li></ul><h1 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h1><ul><li>CSS规则由两个主要的部分构成：选择器及一条或多条声明。</li><li>属性和属性值以”键值对“的形式出现。</li><li>属性和属性值之间用英文冒号来分割。</li><li>多个”键值对“之间用英文分号进行区分。</li></ul><h1 id="CSS代码风格"><a href="#CSS代码风格" class="headerlink" title="CSS代码风格"></a>CSS代码风格</h1><ul><li>展开风格书写代码。</li><li>使用小写字母书写。</li><li>空格规范：<ul><li>属性值前，冒号后面，保留一个空格。</li><li>选择器和大括号之间保留一个空格。</li></ul></li></ul><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><ul><li><p>作用是选择标签</p></li><li><p>CSS做两件事</p><ul><li>选对人（选择标签）</li><li>做对事（更改标签样式）</li></ul></li></ul><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><ul><li><p>是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定。</p></li><li><p>（类名 {属性: 属性值;…} ）</p></li><li><p>优点：快速将页面中同类型的标签统一设置样式。</p></li><li><p>缺点：不能设计差异化样式，只能选择全部的当前标签。</p></li></ul><h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><ul><li><p>如果想要差异化选择不同的标签，单独选择一个或者某几个标签，可以使用类选择器。</p></li><li><p>（.类名 {属性: 属性值;…} 在要改的标签使用class&#x3D;”…”） class键入类名可以使用多类名格式为class&#x3D;”类名1 类名2”（作用于交叉编辑）</p></li><li><p>最常使用。</p></li><li><p>不能使用标签名作为类选择器的类名，可以使用中横线命名，不要使用纯数字、中文进行命名。</p></li><li><p>命名要有意义。</p><table><thead><tr><th align="left">类名</th><th>命名</th></tr></thead><tbody><tr><td align="left">头</td><td>header*</td></tr><tr><td align="left">内容</td><td>content&#x2F;container（article*）</td></tr><tr><td align="left">尾</td><td>footer*</td></tr><tr><td align="left">导航</td><td>nav*</td></tr><tr><td align="left">侧栏</td><td>sidebar（aside*）</td></tr><tr><td align="left">定义文档某个区域</td><td>（section*）</td></tr><tr><td align="left">栏目</td><td>column</td></tr><tr><td align="left">页面外围控制整体布局宽度</td><td>wrapper</td></tr><tr><td align="left">左右中</td><td>left right center</td></tr><tr><td align="left">登录条</td><td>loginbar</td></tr><tr><td align="left">标志</td><td>logo</td></tr><tr><td align="left">广告</td><td>banner</td></tr><tr><td align="left">页面主体</td><td>main</td></tr><tr><td align="left">热点</td><td>hot</td></tr><tr><td align="left">新闻</td><td>news</td></tr><tr><td align="left">下载</td><td>download</td></tr><tr><td align="left">子导航</td><td>subnav</td></tr><tr><td align="left">菜单</td><td>menu</td></tr><tr><td align="left">子菜单</td><td>submenu</td></tr><tr><td align="left">搜索</td><td>search</td></tr><tr><td align="left">友情链接</td><td>friendlink</td></tr><tr><td align="left">页脚</td><td>footer*</td></tr><tr><td align="left">版权</td><td>copyright</td></tr><tr><td align="left">滚动</td><td>scroll</td></tr><tr><td align="left">内容</td><td>content</td></tr><tr><td align="left">标签页</td><td>tab</td></tr><tr><td align="left">文章列表</td><td>list</td></tr><tr><td align="left">提示信息</td><td>msg</td></tr><tr><td align="left">小技巧</td><td>tips</td></tr><tr><td align="left">栏目标题</td><td>title</td></tr><tr><td align="left">加入</td><td>joinus</td></tr><tr><td align="left">指南</td><td>guild</td></tr><tr><td align="left">服务</td><td>service</td></tr><tr><td align="left">注册</td><td>regsiter</td></tr><tr><td align="left">状态</td><td>status</td></tr><tr><td align="left">投票</td><td>vote</td></tr><tr><td align="left">合作伙伴</td><td>partner</td></tr></tbody></table></li></ul><h5 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h5><ul><li><p>（#类名{属性：属性值；}）</p></li><li><p>只能调用一次，如果有调用一次后，别的标签不允许再次使用。（后期于js结合使用）</p></li></ul><h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><ul><li>（*{属性：属性值；}）</li><li>对网页中所有的标签进行修改。</li></ul><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h5><ul><li>同类选择器只不过在要选的深一层和第一层之间加了空格</li></ul><h5 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h5><ul><li>只选择某标签中的 一个子标签 样式为父标签&gt;子标签{… …}</li></ul><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h5><ul><li><p>可以作用于链接、表单的特殊选择器</p></li><li><p>样式为:link&#x2F;visited&#x2F;active&#x2F;hover&#x2F;focus{… …}</p><ul><li>link为未被访问过的元素</li><li>visited为已经被访问过的元素</li><li>active表示鼠标按下但未弹起的元素</li><li>hover表示鼠标悬停的元素</li><li>focus表示鼠标选定的元素（焦点）</li></ul></li></ul><h5 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h5><ul><li><p><a href="https://blog.csdn.net/m0_37989980/article/details/103502518">Ctrl+单击</a></p></li><li><p>字体属性：font的复合属性：将标签中的字体进行很多次变换可能很不方便，可以使用符合属性，格式为font: font-style font-weight font-size&#x2F;line-height font-family; 如此书写可以一行代码解决样式 粗细 大小 字体的四种属性。 （但是必须要有字号和字 体否则不起效果）</p></li><li><p>文本属性：  </p><ul><li>文本的颜色color：可以通过预定颜色值、十六进制、RGB代码进行修改。</li><li>对齐文本text-align：属性值为left、right、center</li><li>装饰文本text-decoration：可以给文本加下划线上划线删除线，属性值有none、underline、overline、line-through</li><li>文本缩进text-indent：输入像素可以缩进距离 （可以输入负值）单位不只是px 还有em（相当于当前字体大小的一个字体的距离）</li><li>行间距line-height用于设置行间的距离（行高）设置的距离包括文字距离，是一整行的高低（&#x3D;&#x3D;让文字垂直居中方法：让行间距等于盒子高度&#x3D;&#x3D;）</li></ul></li></ul><h1 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h1><h5 id="行内样式表（行内式）"><a href="#行内样式表（行内式）" class="headerlink" title="行内样式表（行内式）"></a>行内样式表（行内式）</h5><ul><li>在某个标签内写入style，优先级非常高</li></ul><h5 id="内部样式表（嵌入式）"><a href="#内部样式表（嵌入式）" class="headerlink" title="内部样式表（嵌入式）"></a>内部样式表（嵌入式）</h5><ul><li>放在head的style 练习时使用的方式</li></ul><h5 id="外部样式表（链接式）"><a href="#外部样式表（链接式）" class="headerlink" title="外部样式表（链接式）"></a>外部样式表（链接式）</h5><ul><li>单独写一个CSS文件，再将此文件引入到HTML中。（使用方法为建一个CSS的文件，直接在里面写样式，但要在引用的HTML文件中加入link标签） </li><li>专业</li></ul><h1 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h1><ul><li>采取简写形式：如w200+tab可以生成width:200px;</li></ul><h1 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h1><h5 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h5><ul><li><p>常见的块元素有h1~h6、p、div、ul、ol、li等（li前原点去除：list-style:none;)</p></li><li><p>独占一行</p></li><li><p>宽度、高度、外边距、内边距都控制</p></li><li><p>默认宽度是父级容器的100%</p></li><li><p>是一个容器及盒子，里面可以放行内或块级元素</p></li></ul><h5 id="行内元素（内联元素）"><a href="#行内元素（内联元素）" class="headerlink" title="行内元素（内联元素）"></a>行内元素（内联元素）</h5><ul><li><p>常见的行内元素有a、strong、b、em、i、del、s、ins、u、span等</p></li><li><p>相邻行内元素在一行上，一行可以显示多个</p></li><li><p>高宽的设置是无效的</p></li><li><p>默认宽度就是它本身内容的宽度</p></li><li><p>行内元素只能容纳文本或其他行内元素</p></li><li><p>链接里不能再放链接，特殊情况链接可以放块级元素</p></li></ul><h5 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h5><ul><li><p>常见的行内块元素有img&#x2F;、input&#x2F;、td他们同时具有块元素和行内元素的特点</p></li><li><p>和相邻行内元素在一行上，但是他们之间会有空白间隙。一行可以显示多个（行内元素特点）</p></li><li><p>默认宽度就是它本身内容的宽度（行内元素特点）</p></li><li><p>行高、高度、外边距和内边距都可以控制（块级元素特点）</p></li></ul><h5 id="元素显示模式的转化"><a href="#元素显示模式的转化" class="headerlink" title="元素显示模式的转化"></a>元素显示模式的转化</h5><ul><li>想转化什么就在style里面加入display:block&#x2F;inline&#x2F;inline-block;</li></ul><h1 id="CSS的背景"><a href="#CSS的背景" class="headerlink" title="CSS的背景"></a>CSS的背景</h1><h5 id="背景颜色及半透明"><a href="#背景颜色及半透明" class="headerlink" title="背景颜色及半透明"></a>背景颜色及半透明</h5><ul><li>样式为 background-color:颜色;(颜色不写默认是transparent 透明的)；</li><li>想实现半透明只需在rgb颜色后加个a表示透明度即可 如rgba（0，0，0，0.5）即为半透明的黑色</li></ul><h5 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h5><ul><li>样式为 background-image:url(…);</li></ul><h5 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h5><ul><li>样式为 background-repeat:……;</li><li>属性值为no-repeat为取消平铺；属性值为repeat-x为横向铺一行，属性值为repeat-y为竖向铺一列；</li></ul><h5 id="背景图片位置"><a href="#背景图片位置" class="headerlink" title="背景图片位置"></a>背景图片位置</h5><ul><li>样式为 background-position:… …;</li><li>前一个为x轴，后一个为y轴。可使用center这种方位名词，也可使用精确的位置，甚至可以混合。</li></ul><h5 id="背景固定"><a href="#背景固定" class="headerlink" title="背景固定"></a>背景固定</h5><ul><li><p>可以用于制作视差滚动效果</p></li><li><p>样式为 background-attachment:scroll&#x2F;fixed;(默认滚动)</p><ul><li>scroll为滚动</li><li>fixed为固定</li></ul></li></ul><h5 id="复合写法"><a href="#复合写法" class="headerlink" title="复合写法"></a>复合写法</h5><ul><li>background:………………;</li></ul><h1 id="CSS的三大特性"><a href="#CSS的三大特性" class="headerlink" title="CSS的三大特性"></a>CSS的三大特性</h1><h5 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h5><ul><li><p>相同选择器给设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。</p></li><li><p>样式冲突，遵循的是就近原则，哪个样式离结构近，就执行哪个样式。</p></li><li><p>样式不冲突，不层叠。</p></li></ul><h5 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h5><ul><li><p>子标签会继承父标签中的某些样式。（恰当使用可以降低CSS的复杂性）</p></li><li><p>通常继承：text font line color这些属性</p></li><li><p>特殊继承：font: 12px&#x2F;24px;表示行高为24px，但可以写成font:12px&#x2F;1.5;表示行高为当前字体的1.5倍，子代继承同样适用1.5倍。</p></li></ul><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><ul><li><p>当同一个元素指定多个选择器，就会有优先级的产生</p></li><li><p>选择器相同，则执行层叠性</p></li><li><p>优先级为：！important&gt;行内样式（直接在标签里面写style）&gt;id&gt;类&gt;伪类&#x3D;标签&#x3D;属性选择&gt;继承&gt;通配符；</p></li><li><p>复合选择器有权重叠加的问题，如子元素选择器就会相当于两个标签选择器的叠加。</p></li></ul><h1 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h1><p>网页布局的本质：利用CSS摆盒子</p><ul><li><p>先准备好相应的网页元素，网页元素基本都是盒子box</p></li><li><p>利用CSS设置好盒子样式，然后摆放到相应位置</p></li><li><p>往盒子里转内容</p></li></ul><h3 id="常见网页布局"><a href="#常见网页布局" class="headerlink" title="常见网页布局"></a>常见网页布局</h3><p>+ </p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li><p>所谓盒子模型：就是将HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器</p></li><li><p>CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容</p></li><li><p>盒子模型的组成 每个元素都可以只设置上下左右 在元素后加-top&#x2F;bottom&#x2F;left&#x2F;right即可</p><ul><li><p>border边框 可以使用复合写法 边框会影响盒子实际大小 测量要减去边框宽度</p><ul><li>border-width设置边框粗细</li><li>border-style设置边框样式 solid实线边框 dashed虚线边框 dotted点线边框  outset3D边框</li><li>border-color设置边框颜色</li><li>border-collapse用于合并相邻的边框</li></ul></li><li><p>content内容</p></li><li><p>padding内边距（内边距影响盒子的大小，当有宽度和高度属性时使用padding会撑大盒子，解决方法用宽度、高度减去padding*2 ）（当高、宽未指定时padding不再影响）  </p><ul><li>改变盒子边框和盒子内容距离</li><li>可单写也可上下左右一起</li><li>值个数为1一圈，值个数为2上下 左右，值个数为3上 左右 下，值个数为4顺时针</li></ul></li><li><p>margin外边距</p><ul><li><p>改变盒子与盒子之间的距离</p></li><li><p>输入方式和padding基本一样 </p></li><li><p>常见应用：块级盒子居中对齐 条件：有宽度、左右外边距写为auto；行内、行内块元素水平居中给其父级元素添加text-align:center;即可。</p></li><li><p><a href="https://blog.csdn.net/weixin_43334673/article/details/107177421">嵌套块元素塌陷</a>：父元素和子元素的外边距会合并 解决方案：为父元素添加overflow:hidden或定义上内边距或定义上边框</p></li></ul></li></ul></li><li><p>CSS第一行代码就是清除内外边距即*{padding:0;margin:0;}且行内元素尽量只设置左右边距（因为上下不起作用）。</p></li></ul><h5 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h5><ul><li><p>样式：border-radius:…;</p></li><li><p>radius意为半径后面输入的值越大盒子越圆；</p></li><li><p>可以输入4个值表示四个角</p></li></ul><h5 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h5><ul><li><p>样式为 box-shadow:…; 盒子的阴影不占空间。</p></li><li><p>h-shadow 表示水平位置的阴影</p></li><li><p>v-shadow 表示竖直方向的阴影</p></li><li><p>blur 表示阴影的模糊距离</p></li><li><p>spread 表示阴影的尺寸</p></li><li><p>color 表示阴影的颜色</p></li><li><p>inset 改为内部阴影</p></li></ul><h5 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h5><ul><li>样式为 text-shadow:…;</li><li>属性值为盒子阴影的前三个和color</li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><ul><li>页面由标准流（普通流&#x2F;文档流）、浮动、定位构成。</li><li>为什么需要浮动？1.将多个块级盒子在一行显示且不留空隙。2.实现两个盒子的左右对其。</li><li>网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</li><li>样式为 float:属性值; 属性值可以为left和right和none float是用于创建浮动框的，将其移动到一边，直到左边缘或右边缘触及块或者另一个浮动框的边缘。</li><li>浮动元素经常和标准流父级搭配使用 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</li></ul><h5 id="浮动特性"><a href="#浮动特性" class="headerlink" title="浮动特性"></a>浮动特性</h5><ul><li><p>浮动的元素会脱离标准流</p><ul><li>脱离标准普通流的控制（浮）移动到指定位置（动）（俗称脱标）</li><li>浮动的盒子不再保留原先的位置</li></ul></li><li><p>浮动的元素会一行内显示并且元素顶部对齐</p><ul><li>当父级元素装不下时，多出的盒子会另起一行。</li></ul></li><li><p>浮动的元素会具有行内块元素的特性</p><ul><li>任何种类的元素都可以加浮动，但是加了浮动之后就会变成行内块元素。</li><li>如果块级元素没有设置宽度，默认宽度是和父级一样宽，但是添加浮动后，它的大小根据内容决定。</li></ul></li></ul><h5 id="浮动布局的注意点"><a href="#浮动布局的注意点" class="headerlink" title="浮动布局的注意点"></a>浮动布局的注意点</h5><ul><li><p>通常是规定父级元素是标准流，然后子元素再规定为浮动。</p></li><li><p>&#x3D;&#x3D;理论上一个元素浮动了，其他兄弟元素也需要浮动。&#x3D;&#x3D;</p></li><li><p>浮动的盒子只会影响后面的标准流</p></li></ul><h5 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h5><ul><li>由于父级盒子很多情况下不方便给高度，但是盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子</li><li>由于浮动元素不再占有原文档流的位置，所以它会对后面的元素排版产生影响</li><li>样式 选择器{clear:left&#x2F;right&#x2F;both;}</li><li>清除浮动方法<ul><li>额外标签法（隔墙法 不常用）：在需要清除浮动的最后一个元素后写一个盒子（必须是块级元素  div最好），加上clear both。</li><li>父级添加overflow：可以给父级元素添加overflow属性，将其属性值设置为hidden、auto、或scroll。hidden可以清除浮动。</li><li>after伪元素法：在父元素后面插入一个新盒子。</li><li>双伪元素清除浮动：在新盒子的内部前面后面都插入一个盒子。</li></ul></li></ul><h3 id="ps切图"><a href="#ps切图" class="headerlink" title="ps切图"></a>ps切图</h3><h5 id="常见的图片格式"><a href="#常见的图片格式" class="headerlink" title="常见的图片格式"></a>常见的图片格式</h5><ul><li>jpg图片格式：jpg对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的</li><li>gif图像格式：GIF格式最多只能存储256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果，实际通常用于一些图片动画效果。</li><li>png图像格式：是一种新兴的网络图形格式，结合了jpg和gif的特点，能够保持透明背景，如果想要切成透明背景的图片，就选用png格式的图像。</li><li>PSD图像格式：是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计稿，对前端人员来说最大的优点就是可以直接从上面复制文字、测量距离和大小。</li></ul><h5 id="常见的切图方式"><a href="#常见的切图方式" class="headerlink" title="常见的切图方式"></a>常见的切图方式</h5><ul><li>图层切图： 选中图层右键快速导出为PNG</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h5 id="定位的应用"><a href="#定位的应用" class="headerlink" title="定位的应用"></a>定位的应用</h5><p>用于使盒子自由的在某个盒子内移动位置或者固定屏幕中的某个位置，并且可以压住盒子。</p><h5 id="定位的组成"><a href="#定位的组成" class="headerlink" title="定位的组成"></a>定位的组成</h5><ul><li>定位模式 属性为position<ul><li>static为静态定位 相当于无定位 按照标准流摆放 通常不使用</li><li>&#x3D;&#x3D;relative为相对定位&#x3D;&#x3D; 相对于自己原来的位置进行移动 只与自己原来的位置有关系 且原来在标准流的位置继续占有（人飞了，但是后面的人还给他留空）用于限制绝对定位（父相子绝）</li><li>&#x3D;&#x3D;absolute为绝对定位&#x3D;&#x3D; 要看祖先元素 <ul><li>若无祖先 以浏览器界面对齐 </li><li>若祖先元素有定位 以最近一级的有定位祖先元素对齐</li><li>绝对定位的位置不再进行保留</li></ul></li><li>&#x3D;&#x3D;fixed为固定定位&#x3D;&#x3D; 固定住盒子 即使滑动页面也不会改变盒子  以可视窗口的距离来移动位置<ul><li>让固定的盒子以版心对其：先让固定的盒子left50%，然后margin版心宽度的一半</li></ul></li><li>sticky为粘性定位 刚开始相对定位 拉到盒子即将出可视空间时就变成固定定位</li></ul></li><li>边偏移 是定位的一个属性 有top&#x2F;bottom&#x2F;left&#x2F;right 后面可以直接加距离</li></ul><h5 id="定位的叠放次序"><a href="#定位的叠放次序" class="headerlink" title="定位的叠放次序"></a>定位的叠放次序</h5><ul><li>使用z-index属性值可以控制盒子的叠放顺序 </li><li>数值可以时正整数、负整数、或是0，默认是auto，数值越大，盒子越靠上</li><li>如果属性值相同，则按照书写顺序，后来者居上</li><li>数字后面不可以加单位</li><li>只有定位的盒子才有z-index属性</li></ul><h5 id="定位的扩展"><a href="#定位的扩展" class="headerlink" title="定位的扩展"></a>定位的扩展</h5><ul><li>加了绝对定位的盒子不可以通过margin水平居中 但是可以通过left50%＋margin-left半个盒子的距离来实现居中（垂直居中同理）</li><li>行内元素添加固定或者绝对定位，可以直接设置高度和宽度</li><li>浮动元素、绝对定位元素都不会触发外边距合并的问题</li><li>浮动元素只会压住其底下标准流的盒子，但是不会压住下面标准流盒子里面的文字和图片，但绝对定位会完全压住下面标准流中的所有内容。（浮动不会压住文字图片的原因是，浮动本来就是用于文字围绕图片的）</li></ul><p>如果一个盒子既有left属性又有right属性，则会默认执行left属性 同理有top bottom属性会执行top属性</p><h3 id="属性的显示与隐藏"><a href="#属性的显示与隐藏" class="headerlink" title="属性的显示与隐藏"></a>属性的显示与隐藏</h3><p>本质是让一个元素显示或者隐藏</p><ul><li>&#x3D;&#x3D;display显示隐藏元素&#x3D;&#x3D;<ul><li>属性值为none时表示隐藏对象</li><li>属性值为block时表示转换为块级元素，同时还有显示元素的意思</li><li>隐藏元素后盒子消失且占有的位置消失</li></ul></li><li>visibility可见性<ul><li>属性值为visible元素可视</li><li>属性值为hidden元素隐藏</li><li>隐藏元素的盒子消失但是占有的位置还在</li></ul></li><li>overflow溢出<ul><li>对内容超过盒子宽度高度的内容进行影响</li><li>属性值visible显示</li><li>属性值hidden隐藏</li><li>属性值scroll溢出部分显示滚动条</li><li>属性值auto自动添加滚动条（溢出显示滚动条，不溢出不显示）</li><li>有定位的盒子慎用hidden属性值，因为其会隐藏多余的部分</li></ul></li></ul><h1 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h1><p>建议遵循以下顺序：</p><p>1.布局定位属性：display、float……</p><p>2.自身属性：width、margin、background…….</p><p>3.文本属性：font、color、text…….</p><p>4.其他：border-radius、box-shadow……</p><h1 id="页面设计整体思路"><a href="#页面设计整体思路" class="headerlink" title="页面设计整体思路"></a>页面设计整体思路</h1><p>1.必须确认页面的版心（核心区）</p><p>2.分析页面中的行模块，以及每个行模块中的列模块</p><p>3.一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置</p><p>4.制作HTML先制作结构最后写样式</p><p>5.一定要先清除布局结构，再写代码</p><h3 id="导航栏nav制作"><a href="#导航栏nav制作" class="headerlink" title="导航栏nav制作"></a>导航栏nav制作</h3><ul><li>实际开发中，我们不会直接用链接a而是用li包含链接（li+a）的做法。</li><li>li+a的语义更为清晰，且如果直接用a，搜索引擎容易辨别为有堆砌关键字的嫌疑，从而影响网站排名。<ul><li>通过网站内容、网站关键词、网站外链、用户体验方面可以怎加网站排名。</li></ul></li></ul><h1 id="CSS高级技术"><a href="#CSS高级技术" class="headerlink" title="CSS高级技术"></a>CSS高级技术</h1><h3 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h3><p>为什么使用精灵图：为了有效的减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites）（CSS 雪碧）</p><p>核心原理 将全部图片加载到一个大图片中 包含所有需要请求的小图片</p><h5 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h5><ul><li><p>精灵技术主要针对背景图片使用，就是将多个小背景图片整合到一张大的图片中</p></li><li><p>通过移动背景图片的位置，此时可以使用background-position</p></li><li><p>移动的距离就是这个目标图片的x和y坐标。注意网页中的坐标有所不同</p></li><li><p>坐标系有所不同 往上往左走都是负值</p></li></ul><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>主要用于显示网页中通用的、常用的一些小图标</p><h5 id="字体图标的优点"><a href="#字体图标的优点" class="headerlink" title="字体图标的优点"></a>字体图标的优点</h5><ul><li><p>轻量：一个字体图标要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求</p></li><li><p>灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等</p></li><li><p>兼容性：几乎支持所有浏览器</p></li></ul><h5 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h5><ul><li><p>在相应网站选择需要的图标后下载 将font文件复制一份安装到放HTML文件的目录里</p></li><li><p>将压缩包中的style.css文件中第一个大括号所包含的复制到CSS中</p></li><li><p>需要字体图标的地方点击demo.html后选择需要的字体图标进行复制</p></li><li><p>最后再写一个font-family:’icomoon’;就可以了</p></li></ul><h5 id="字体图标的追加"><a href="#字体图标的追加" class="headerlink" title="字体图标的追加"></a>字体图标的追加</h5><ul><li>点击import icons点击selection.json 就可以重新加载</li><li>重新加载后需要重新下载，就要把以前的删除</li></ul><h3 id="CSS三角"><a href="#CSS三角" class="headerlink" title="CSS三角"></a>CSS三角</h3><p>只需要使用CSS就可以实现</p><ul><li>给一个盒子没有高宽 但是有border 改变颜色大小就可以出来小三角</li></ul><h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h3><h5 id="如何更改用户鼠标的样式"><a href="#如何更改用户鼠标的样式" class="headerlink" title="如何更改用户鼠标的样式"></a>如何更改用户鼠标的样式</h5><ul><li>鼠标样式的属性为cursor 常用属性值为default&#x2F;pointer&#x2F;move&#x2F;text&#x2F;not-allow</li></ul><h5 id="表单轮廓"><a href="#表单轮廓" class="headerlink" title="表单轮廓"></a>表单轮廓</h5><ul><li>表单轮廓的属性为outline 可以改变表单轮廓</li></ul><h5 id="防止表单域进行拖拽"><a href="#防止表单域进行拖拽" class="headerlink" title="防止表单域进行拖拽"></a>防止表单域进行拖拽</h5><ul><li>防止拖拽文本域resize 右下角的小拖拽可以取消掉</li></ul><h3 id="图片文字居中对其"><a href="#图片文字居中对其" class="headerlink" title="图片文字居中对其"></a>图片文字居中对其</h3><p>vertical-align属性常用于设置图片或者表单（行内块元素）和文字垂直对齐</p><p>属性值常为baseline（默认）&#x2F;top&#x2F;middle&#x2F;bottom</p><p>也可用于消除图片和border之间的空白线</p><h3 id="文字溢出用省略号表示"><a href="#文字溢出用省略号表示" class="headerlink" title="文字溢出用省略号表示"></a>文字溢出用省略号表示</h3><h5 id="单行溢出"><a href="#单行溢出" class="headerlink" title="单行溢出"></a>单行溢出</h5><p>想要完成这样的操作–必须满足三个条件</p><p>先强制一行内显示文本：white-space:nowrap;（默认normal自动换行）</p><p>超出的部分隐藏：overflow:hidden;</p><p>文字用省略号代替超出的部分：text-overflow:ellipsis;</p><h5 id="多行溢出"><a href="#多行溢出" class="headerlink" title="多行溢出"></a>多行溢出</h5><p>多行文本溢出显示省略号，有较大兼容性问题。</p><p>代码如下：</p><p>overflow:hidden;</p><p>text-overflow:ellipsis;</p><p>弹性伸缩盒子模型显示：display:-webkit-box;</p><p>限制在一个块元素显示的文本的行数：-webkit-line-clamp:(number);</p><p>设置或检索伸缩盒子对象的子元素的排列方式：-webkit-box-orient:vertical;</p><p>（通常是后台人员制作）</p><h3 id="常见布局技巧"><a href="#常见布局技巧" class="headerlink" title="常见布局技巧"></a>常见布局技巧</h3><h5 id="margin负值的运用"><a href="#margin负值的运用" class="headerlink" title="margin负值的运用"></a>margin负值的运用</h5><p>两个盒子之间只有一条border 可以通过margin取负值（border宽度）来实现</p><p>当使用margin负值的时候 如果需要使用hover可以使用z-index来增加显示顺序</p><h5 id="行内块的巧妙运用"><a href="#行内块的巧妙运用" class="headerlink" title="行内块的巧妙运用"></a>行内块的巧妙运用</h5><p>有些多个小盒子水平对齐而且有空格 可以考虑用行内块元素制作</p><h5 id="CSS三角强化"><a href="#CSS三角强化" class="headerlink" title="CSS三角强化"></a>CSS三角强化</h5><p>不同的三角形可以通过更改border属性来获得 从而美化网页</p><p>如想要获得直角三角形可以让bottom&#x3D;0，left&#x3D;0，再让right为透明</p><h1 id="CSS3的新特性"><a href="#CSS3的新特性" class="headerlink" title="CSS3的新特性"></a>CSS3的新特性</h1><ul><li>新增的CSS3特性有兼容性问题，ie9+才支持</li><li>移动端支持有优于PC端</li></ul><h3 id="CSS边框图片"><a href="#CSS边框图片" class="headerlink" title="CSS边框图片"></a>CSS边框图片</h3><ul><li>border-image-source ：定义边框图像的路径；</li><li>border-image-slice ：定义边框图像从什么位置开始分割；</li><li>border-image-width ：定义边框图像的厚度（宽度）；</li><li>border-image-outset ：定义边框图像的外延尺寸（边框图像区域超出边框的量）；</li><li>border-image-repeat ：定义边框图像的平铺方式。</li></ul><h3 id="CSS新增选择器"><a href="#CSS新增选择器" class="headerlink" title="CSS新增选择器"></a>CSS新增选择器</h3><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><p>想要选择标签中某个属性</p><p>样式为 标签[属性]{……} 甚至[……]里可以是 属性&#x3D;属性值 或 属性^&#x3D;属性值（表示以某属性值开头） 或 属性&amp;&#x3D;属性值（表示以某属性值结尾） 或 属性*&#x3D;属性值（表示含有某属性值）</p><p>类选择器、属性选择器、伪类选择器权重都是10</p><h5 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h5><p>结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器里面的子元素</p><p>样式为 </p><p>标签:first-child&#x2F;last-child&#x2F;nth-child(n){……}  (n可以是数字、关键字（例如even偶数，odd奇数）、公式)</p><p>或 </p><p>标签:first-of-type&#x2F;last-of-type&#x2F;nth-of-type(n) 同上</p><p>两者的区别是 第一个是先排序 再看标签 没有就没有 第二个是先看标签 再排序</p><h5 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h5><p>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构</p><p>选择符 ::before&#x2F;after 分别是在元素内部的前面和后面插入内容 里面必须有属性content</p><p>伪元素是行内元素 不可设置宽高 想设置可以更改或浮动</p><h3 id="CSS3盒子模型"><a href="#CSS3盒子模型" class="headerlink" title="CSS3盒子模型"></a>CSS3盒子模型</h3><p>CSS3中可以通过box-sizing来指定盒子模型，有2个值：即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。</p><p>可以分为两种情况：</p><p>1.box-sizing:content-box 盒子大小为width+padding+border (默认)</p><p>2.box-sizing:border-box 盒子大小为width  以后可以在*中加这个</p><h3 id="CSS其他特性"><a href="#CSS其他特性" class="headerlink" title="CSS其他特性"></a>CSS其他特性</h3><h5 id="使图片变模糊"><a href="#使图片变模糊" class="headerlink" title="使图片变模糊"></a>使图片变模糊</h5><ul><li>样式 filter:函数();</li><li>例如blur函数 数值越大图像越模糊 有单位</li></ul><h5 id="计算盒子宽度width-calc函数"><a href="#计算盒子宽度width-calc函数" class="headerlink" title="计算盒子宽度width:calc函数"></a>计算盒子宽度width:calc函数</h5><ul><li>calc函数可以允许宽度进行运算 如width:calc(100%-30px);</li></ul><h3 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h3><p>太强了 不需要js或者flash也能做出动画效果</p><p>过渡：是从一个状态 慢慢的过渡到另一个状态 </p><p>可以让我们的页面更好看，更动感十足 常与hover搭配使用</p><ul><li>属性为transition:要过渡的属性 花费时间 运动曲线 何时开始;</li><li>过渡属性：选择自己想要的属性</li><li>花费时间：需要写单位</li><li>运动曲线：linear（匀速）&#x2F;ease（逐渐慢下来）&#x2F;ease-in（加速）&#x2F;ease-out（减速）&#x2F;ease-in-out（先加速后减速）  可以省略</li><li>何时开始：默认是0s 可以延迟触发 必须写单位 可以省略</li><li>如果想要写多个属性 用，分开</li></ul><h3 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h3><ul><li><p>转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、缩放等效果</p></li><li><p>属性为transfrom</p><ul><li>可以设置元素转换的中心点 transform-origin：x y；</li></ul></li><li><p>属性值为translate（x，y）</p><ul><li>优点 不会影响到其他的元素位置</li><li>translate的百分比单位是相对于自身元素的translate</li><li>对行内标签没有效果</li></ul></li><li><p>属性值为rotate（度数）    单位为deg</p><ul><li>可以配合别的属性做出表单下拉效果</li></ul></li><li><p>属性值为scale（x，y）表示放大缩小</p><ul><li>x为宽 y为高 （2，1）为宽两倍高不变</li></ul></li></ul><h3 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h3><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，通常用于实现复杂的动画效果、相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。</p><p>动画分两步，先<strong>定义</strong>动画，再<strong>使用</strong>动画</p><h5 id="用keyframes定义动画（类似定义类选择器）"><a href="#用keyframes定义动画（类似定义类选择器）" class="headerlink" title="用keyframes定义动画（类似定义类选择器）"></a>用keyframes定义动画（类似定义类选择器）</h5><p>样式为</p><p>@keyframes 动画名称{</p><p>0%{… : … ;}</p><p>…</p><p>100%{… : … ;}</p><p>}</p><h5 id="用animation调用动画"><a href="#用animation调用动画" class="headerlink" title="用animation调用动画"></a>用animation调用动画</h5><p>太帅啦</p><ul><li>animation-name:动画名称</li><li>animation-duration:持续时间</li><li>animation-timing-function:规定动画的速度曲线，默认是”ease”<ul><li>除了之前过渡的属性值 还增加了一个属性值 steps（）指定了时间函数中的间隔数量（步长）–&gt;可以用于制作打字机效果</li></ul></li><li>animation-delay:规定动画何时开始</li><li>animation-iteration-count:规定动画被播放的次数（无数次infinite）</li><li>animation-direction:规定下一周期是否逆播放（alternate逆播放）</li><li>animation-play-state:规定动画是否正在运行或暂停 默认是running还有paused （可以用于hover）</li><li>animation-fill-mode:规定动画结束后状态，保持forwards回到初始backwards</li><li>动画简写属性：animation:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态</li></ul><h3 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h3><p>特点 近大远小</p><p>物体后面遮挡不可见</p><p>x轴水平向右 y轴垂直向下 z轴垂直向屏幕外</p><h5 id="3D位移"><a href="#3D位移" class="headerlink" title="3D位移"></a>3D位移</h5><ul><li>样式 transform:translate3d(x,y,z);   其中z通常使用px</li></ul><h5 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h5><p>3D可以让元素在三维平面内沿着x轴，y轴，z轴或者自定义轴进行旋转</p><p>语法</p><ul><li>transforms:rotate3d(x,y,z,deg)</li><li>transforms:rotateX(deg)</li><li>transforms:rotateY(deg)</li><li>transforms:rotateZ( deg) —&gt;这个和2D旋转效果一样</li></ul><h5 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h5><p>perspective</p><ul><li>如果想要在网页中产生3D效果需要透视（理解成3D物体投影在2D平面中）</li><li>模拟人类的视觉位置 可认为安排一只眼睛去看</li><li>透视我们也称为视距：视距就是人的眼睛到屏幕的距离</li><li>距离视觉点越近的在电脑平面成像就越大，越远成像越小</li><li>透视的单位是像素</li><li>&#x3D;&#x3D;透视写在被观察元素的父盒子上&#x3D;&#x3D;</li><li>样式为perspective:…px;</li></ul><h5 id="3D呈现"><a href="#3D呈现" class="headerlink" title="3D呈现"></a>3D呈现</h5><p>属性为transform-style</p><ul><li>控制子元素是否开启三维立体环境</li><li>属性值为flat不开启、属性值为preserve-3d子元素开启立体空间</li><li>代码写给父级但影响的是子级</li></ul><h1 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h1><h3 id="样式的模块化开发"><a href="#样式的模块化开发" class="headerlink" title="样式的模块化开发"></a>样式的模块化开发</h3><p>可以写部分CSS用于多个HTML文件 每当使用时就引用</p><h3 id="制作网站favicon图标"><a href="#制作网站favicon图标" class="headerlink" title="制作网站favicon图标"></a>制作网站favicon图标</h3><p>将准备的图标切成png图片</p><p>将png图片转化为ico图标，这需要借助第三方的转化网站</p><p>将制作好的图标放在网页根目录下</p><p>在head标签中复制网站上的代码粘贴即可</p><h3 id="网站TDK三大标签SEO优化"><a href="#网站TDK三大标签SEO优化" class="headerlink" title="网站TDK三大标签SEO优化"></a>网站TDK三大标签SEO优化</h3><p>SEO汉译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。</p><p>前端人员不做SEO但是也要符合TDK三大标签优化</p><p>T：title </p><ul><li><p>title具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网站的入口和对网页主题归属的最佳判断点</p></li><li><p>建议：网站名（产品名）-网站的介绍（尽量不要超过30个汉字）</p></li></ul><p>D：description</p><ul><li>简要说明网站是干什么的</li><li>提倡description作为网站的总体业务和主题概括</li><li>前端人员只需要准备好meta name&#x3D;”description” content&#x3D;””&#x2F;单标签给准备好就行 接下来交给SEO开发人员</li></ul><p>K：keywords</p><ul><li>keywords是网站的关键词，是搜索引擎的关注点之一</li><li>keywords最好限制在6~8个关键词，关键词之间用英文逗号隔开</li><li>meta name&#x3D;”keywords” content&#x3D;””&#x2F;</li></ul><h5 id="LOGO-SEO-优化"><a href="#LOGO-SEO-优化" class="headerlink" title="LOGO SEO 优化"></a>LOGO SEO 优化</h5><ul><li><p>logo中首先放一个h1标签，目的是提权，告诉搜索引擎，这个地方很重要</p></li><li><p>h1里面再放一个链接 可以返回首页的 把logo的背景图片给链接即可</p></li><li><p>为了搜索引擎收录我们 我们来链接里面要放文字（网站名称），但是名字不要显示出来</p><ul><li>方法是font-size:0; 这样就看不见文字了</li></ul></li><li><p>最后给链接一个title属性，这样鼠标放在logo上就有提示文字了</p></li></ul><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p>服务器（也称主机）是提供计算服务的设备，它也是一台计算机。在网络环境下，根据服务器提供的服务类型不同，服务器又分为文件服务器、数据库服务器、应用程序服务器、web服务器等。</p><p>远程服务器是别的公司为我们提供的一台电脑，我们只要把网站项目传到这台电脑上，任何人都可以利用域名</p><h1 id="Flex布局原理"><a href="#Flex布局原理" class="headerlink" title="Flex布局原理"></a>Flex布局原理</h1><ul><li><p>flex是“弹性布局”，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局</p></li><li><p>当为父元素设置flex布局之后，子元素的float、clear、vertical-align属性将失效</p></li><li><p>定义为display:flex；</p></li></ul><h3 id="常见父项属性"><a href="#常见父项属性" class="headerlink" title="常见父项属性"></a>常见父项属性</h3><ul><li>flex-direction：设置主轴的方向<ul><li>主轴与侧轴 默认主轴为x 侧轴为y</li><li>属性值为row（x轴）&#x2F;row-reverse（从右到左）&#x2F;column（y轴）&#x2F;column-reverse（从下到上）</li></ul></li><li>justify-content：设置主轴上子元素的排列方式<ul><li>属性值为flex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;space-around（平分空间）&#x2F;&#x3D;&#x3D;space-between（先两边贴边 再平分剩余空间）&#x3D;&#x3D;</li></ul></li><li>flex-wrap：设置子元素是否换行<ul><li>flex布局中 默认的子元素是不换行的 如果装不开 会缩小子元素的宽度 放到父元素里面</li></ul></li><li>align-items：设置侧轴上的子元素的排列方式（单行）<ul><li>属性值为flex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;stretch（拉伸）–&gt;变得和父级一样</li></ul></li><li>align-content：设置侧轴上的子元素的排列方式（多行）<ul><li>设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况，在单行下是没有效果的</li><li>flex-start（默认）&#x2F;flex-end（从尾部开始）&#x2F;center（居中）&#x2F;space-around（平分空间）&#x2F;space-between（先两边贴边 再平分剩余空间）&#x2F;stretch（设置子项元素高度平分父元素高度）</li></ul></li><li>flex-flow：复合属性</li></ul><h3 id="常见子项属性"><a href="#常见子项属性" class="headerlink" title="常见子项属性"></a>常见子项属性</h3><ul><li><p>flex子项目占的份数</p><ul><li><p>分配的是&#x3D;&#x3D;剩余空间&#x3D;&#x3D;</p></li><li><p>样式为flex:数字;</p></li></ul></li><li><p>align-self控制子项自己在侧轴的排列方式</p><ul><li>align-self允许某单个项目有与其他项目不同的对齐方式 可以覆盖align-items</li></ul></li><li><p>order属性定义子项的排列顺序（先后顺序）</p><ul><li>数值越小 排列越靠前 默认为0</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前端三剑客之一</summary>
    
    
    
    <category term="技术栈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="迁移" scheme="http://example.com/tags/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
</feed>
